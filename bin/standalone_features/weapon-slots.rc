## Standalone BRC Feature: weapon-slots
## Generated from: lua/features/weapon-slots.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false
BRC.Config.mpr = BRC.Config.mpr or {}
BRC.Config.mpr.show_debug_messages = false
BRC.Config.mpr.debug_to_stderr = false

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)


-- BRC module tables
BRC.it = {}
BRC.mpr = {}
BRC.txt = {}

-- BRC.it module
function BRC.it.is_magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

function BRC.it.is_polearm(it)
  return it and it.weap_skill:contains("Polearms")
end

-- BRC.mpr module
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, color)
  -- Avoid referencing BRC, to stay robust during startup
  color = color or "lightgrey"
  local msg = "[BRC] " .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

function BRC.mpr.debug(message, context)
  if BRC.Config.mpr.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Debug) " .. message)
  end
end

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end


---------------------------------------------------------------------------------------------------
-- BRC feature module: weapon-slots
-- @module f_weapon_slots
-- Automatically keeps weapons in slots a/b/w. Prioritizes slots by weapon type + skill.
---------------------------------------------------------------------------------------------------

f_weapon_slots = {}


---- Local variables ----
local do_cleanup_weapon_slots
local slots_changed
local priorities_ab
local priorities_w

---- Initialization ----
function f_weapon_slots.init()
  do_cleanup_weapon_slots = false
  slots_changed = false
  priorities_ab = nil
  priorities_w = nil
end

---- Local functions ----
local function get_first_empty_slot()
  -- First try to avoid same slot as a consumable, then find first empty equipment slot
  local used_slots = {}
  for _, inv in ipairs(items.inventory()) do
    used_slots[inv.slot] = true
  end

  for slot = 0, 51 do
    if not used_slots[slot] then return slot end
  end

  for slot = 0, 51 do
    if not items.inslot(slot) then return slot end
  end
end

local function get_priority_ab(it)
  if not it.is_weapon then return -1 end
  if it.equipped then return 1 end

  if BRC.it.is_magic_staff(it) then return 3 end
  if it.is_ranged then return (you.skill("Ranged Weapons") >= 4) and 2 or 5 end
  if BRC.it.is_polearm(it) then return (you.skill("Polearms") >= 4) and 2 or 4 end
  return 2
end

local function get_priority_w(it)
  if not it.is_weapon then return -1 end
  if it.is_ranged then return 1 end
  if BRC.it.is_polearm(it) then return 2 end
  if BRC.it.is_magic_staff(it) then return 3 end
  return 4
end

local function generate_priorities()
  priorities_ab = { -1, -1, -1, -1, -1 }
  priorities_w = { -1, -1, -1, -1 }

  for _, inv in ipairs(items.inventory()) do
    local p = get_priority_w(inv)
    if p > 0 then
      if priorities_w[p] == -1 then
        priorities_w[p] = inv.slot
      else
        priorities_w[p + 1] = inv.slot
      end
    end

    p = get_priority_ab(inv)
    if p > 0 then
      if priorities_ab[p] == -1 then
        priorities_ab[p] = inv.slot
      else
        priorities_ab[p + 1] = inv.slot
      end
    end
  end
end

local function cleanup_ab(slot)
  local inv = items.inslot(slot)
  if inv and inv.is_weapon then return end

  for p = 1, #priorities_ab do
    if priorities_ab[p] > slot then -- Not from earlier slot
      items.swap_slots(priorities_ab[p], slot)
      slots_changed = true
      priorities_ab[p] = -1
      return
    end
  end
end

local function cleanup_w()
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if inv and inv.is_weapon then return end

  for p = 1, #priorities_w do
    if priorities_w[p] > 1 then -- Not from slots a or b
      items.swap_slots(priorities_w[p], slot_w)
      slots_changed = true
      return
    end
  end
end

local function cleanup_weapon_slots()
  generate_priorities()
  cleanup_ab(0)
  cleanup_ab(1)
  cleanup_w()
end

---- Crawl hook functions ----
function f_weapon_slots.c_assign_invletter(it)
  if not it.is_weapon then return end

  for _, s in ipairs({ "a", "b", "w" }) do
    local slot = items.letter_to_index(s)
    local inv = items.inslot(slot)
    if not inv then return slot end
    if not inv.is_weapon then
      items.swap_slots(slot, get_first_empty_slot())
      slots_changed = true
      return slot
    end
  end
end

function f_weapon_slots.c_message(text, channel)
  do_cleanup_weapon_slots = channel == "plain" and text:contains("ou drop ")
end

function f_weapon_slots.ready()
  if do_cleanup_weapon_slots then
    cleanup_weapon_slots()
    do_cleanup_weapon_slots = false
  end
  if slots_changed then
    BRC.mpr.debug("Weapon slots updated (ab+w).")
    crawl.redraw_screen()
    slots_changed = false
  end
end


-- Crawl hook wrappers
function c_assign_invletter(...)
  return f_weapon_slots.c_assign_invletter(...)
end

function c_message(...)
  return f_weapon_slots.c_message(...)
end

local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_weapon_slots.ready(...)
  end
end


-- Initialize feature
if f_weapon_slots.init then f_weapon_slots.init() end
}
