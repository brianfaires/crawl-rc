## BRC Core files - Copy/paste any features above this line.

################################### Begin lua/core/config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Configuration - Various configs, overriding default values in feature configs.
Author: buehler
Dependencies: (none)
Usage:
  - Update BRC.config_to_use to load the corresponding config.
  - Update each config or create new ones.
  - Values that aren't defined will first fall back to Configs.Default, then to the defaults defined in feature configs.
  - Define `init = function() ... end` in a config to run code after it loads, and before overrides are applied.
  - If using config_memory == "full", the function needs to be saved as a string instead. --]]
  -- To do this, just replace `function()` and `end` with double square brackets: [[ ... ]]


---- Initialize BRC namespace and Public modules
BRC = BRC or {}
BRC.Profiles = {}
BRC.config_to_use = "ask"
BRC.config_memory = "name"

-- Default Config Profile (defines all non-feature values)
BRC.Profiles.Default = {
  emojis = false, -- Use emojis in alerts and announcements
  show_debug_messages = false,
} -- BRC.Profiles.Default (do not remove this comment)
BRC.Config = BRC.Profiles.Default-- Always init to Default profile

-- Testing Config Profile: Isolate and test specific features
BRC.Profiles.Testing = {
  show_debug_messages = true,
  disable_other_features = false,
  ["pickup-alert"] = {
    Alert = {
      armour_sensitivity = 0.1,
      weapon_sensitivity = 0.1,
    },
  },
  init = [[
    if BRC.Config.disable_other_features then
      for _, v in pairs(_G) do
        if BRC.is_feature_module(v) and not BRC.Config[v.BRC_FEATURE_NAME] then
          BRC.Config[v.BRC_FEATURE_NAME] = { disabled = true }
        end
      end
    end
  ]],
} -- BRC.Profiles.Testing (do not remove this comment)

-- Custom Config Profile: Personalized settings
BRC.Profiles.Custom = {
  ["misc-alerts"] = {
    alert_low_hp_threshold = 0.35, -- % max HP to alert; 0 to disable
  },
  ["announce-hp-mp"] = {
    dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
    dmg_fm_threshold = 0.30,    -- Force more for losing this % of max HP
    always_on_bottom = false,   -- Rewrite HP/MP meters after each turn with messages
  },
  ["inscribe-stats"] = {
    inscribe_weapons = true, -- Inscribe weapon stats on pickup and keep updated
    inscribe_armour = true,  -- Inscribe armour stats on pickup and keep updated
  },
  ["remind-id"] = {
    stop_on_scrolls_count = 2, -- Stop when largest un-ID'd scroll stack increases and is >= this
    stop_on_pots_count = 3,    -- Stop when largest un-ID'd potion stack increases and is >= this
  },
  ["runrest-features"] = {
    ignore_portal_exits = true, -- don't stop explore on portal exits
    temple_search = true,       -- on enter or explore, auto-search altars
    gauntlet_search = true,     -- on enter or explore, auto-search gauntlet with filters
  },
  ["startup"] = {
    show_skills_on_startup = false, -- Open skills menu on startup
    auto_set_skill_targets = {
      { "Stealth", 2.0 },  -- First, focus stealth to 2.0
      { "Fighting", 2.0 }, -- If already have stealth, focus fighting to 2.0
    },
  },
  ["pickup-alert"] = {
    Pickup = {
      armour = true,
      staves = true,
      weapons = true,
      weapons_pure_upgrades_only = true, -- Only pick up better versions of same exact weapon
    },

    Alert = {
      armour_sensitivity = 0.1, -- Adjust all armour alerts; range [0.5-2.0]; 0 = disable all armour alerts
      weapon_sensitivity = 2, -- Adjust all weapon alerts; range [0.5-2.0]; 0 = disable all weapon alerts
      orbs = true,
      staff_resists = true, -- When a staff gives a missing resistance
      talismans = true,

      one_time = { -- Alert the first time each item is found
        "wand of digging", "buckler", "kite shield", "tower shield", "crystal plate armour",
        "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales",
        "quick blade", "demon blade", "eudemon blade", "double sword", "triple sword",
        "broad axe", "executioner's axe",
        "demon whip", "eveningstar", "giant spiked club", "morningstar", "sacred scourge",
        "lajatang", "bardiche", "demon trident", "partisan", "trishula", "hand cannon", "triple crossbow",
      },
      OTA_require_skill = { weapon = 2, armour = 2.5, shield = 0 }, -- One-time alert only when skill level >= this

      More = { -- Which alerts generate a force_more_message (some categories overlap)
        early_weap = false,       -- Good weapons found early
        upgrade_weap = false,     -- Better DPS / weapon_score
        weap_ego = false,         -- New or diff egos
        body_armour = false,
        shields = true,
        aux_armour = false,
        armour_ego = true,        -- New or diff egos
        high_score_weap = false,  -- Highest damage found
        high_score_armour = true, -- Highest AC found
        one_time_alerts = true,
        artefact = false,         -- Any artefact
        trained_artefacts = true, -- Artefacts where you have corresponding skill > 0
        orbs = false,
        talismans = you.class() == "Shapeshifter", -- True for shapeshifter, false for everyone else
        staff_resists = false,
      },
    },
  },
} -- BRC.Profiles.Custom (do not remove this comment)

-- Speed Config Profile: For speed runs
BRC.Profiles.Speed = {
  ["after-shaft"] = { disabled = true },
  ["alert-monsters"] = { disabled = true },
  ["safe-consumables"] = { disabled = true },
  ["safe-stairs"] = { disabled = true },
  ["announce-hp-mp"] = {
    dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
    dmg_fm_threshold = 1,    -- Force more for losing this % of max HP
    always_on_bottom = true,   -- Rewrite HP/MP meters after each turn with messages
  },
  ["misc-alerts"] = {
    alert_low_hp_threshold = 0, -- % max HP to alert; 0 to disable
    save_with_msg = false, -- Shift-S to save and leave yourself a message
  },
  ["remind-id"] = {
    stop_on_scrolls_count = 9, -- Stop when largest un-ID'd scroll stack increases and is >= this
    stop_on_pots_count = 9,    -- Stop when largest un-ID'd potion stack increases and is >= this
  },
  ["startup"] = {
    show_skills_on_startup = false, -- Open skills menu on startup
  },
  ["pickup-alert"] = {
    Pickup = {
      armour = true,
      staves = false,
      weapons = true,
      weapons_pure_upgrades_only = false, -- Only pick up better versions of same exact weapon
    },

    Alert = {
      armour_sensitivity = 1.1, -- Adjust all armour alerts; range [0.5-2.0]; 0 = disable all armour alerts
      weapon_sensitivity = 1.2, -- Adjust all weapon alerts; range [0.5-2.0]; 0 = disable all weapon alerts
      orbs = false,
      staff_resists = false, -- When a staff gives a missing resistance
      talismans = false,

      one_time = { -- Alert the first time each item is found
        "kite shield", "tower shield", "crystal plate armour",
        "gold dragon scales", "pearl dragon scales", "storm dragon scales",
        "broad axe", "demon whip", "eveningstar", "morningstar",
      },
      OTA_require_skill = { weapon = 6, armour = 0, shield = 0 }, -- One-time alert only when skill level >= this

      More = { }, -- All nil / false
    },
    Tuning = {
      Armour = {
        encumb_penalty_weight = 0, -- Penalizes heavier armour when training spellcasting/ranged. 0 to disable
        early_xl = 0, -- Alert all usable runed body armour if XL <= `early_xl`
      },
    },
  },

  init = [[
    BRC.Config.startup.auto_set_skill_targets = { { BRC.get.preferred_weapon_type(), 8.0 } }
  ]],
} -- BRC.Profiles.Speed (do not remove this comment)

-- Turncount Config Profile: For turncount runs
BRC.Profiles.Turncount = {
  ["after-shaft"] = { disabled = true },
  ["alert-monsters"] = {
    sensitivity = 1.25, -- 0 to disable all; at 2.0, alerts will fire at 1/2 HP
  },
} -- BRC.Profiles.Turncount (do not remove this comment)

-- Streak Config Profile: For win streaks
BRC.Profiles.Streak = {
  ["alert-monsters"] = {
    sensitivity = 1.5, -- 0 to disable all; at 2.0, alerts will fire at 1/2 HP
  },

} -- BRC.Profiles.Streak (do not remove this comment)

}
############################### End lua/core/config.lua ###############################
##########################################################################################

################################### Begin lua/core/constants.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Constants - All constant definitions
Author: buehler
Dependencies: (none)
--]]

---- Initialize BRC namespace
BRC = BRC or {}

---- Cosmetic settings
BRC.EMOJI = {
  CAUTION = BRC.Config.emojis and "⚠️" or "<yellow>!</yellow>",
  EXCLAMATION = BRC.Config.emojis and "❗" or "<magenta>!</magenta>",
  EXCLAMATION_2 = BRC.Config.emojis and "‼️" or "<lightmagenta>!!</lightmagenta>",
  SUCCESS = BRC.Config.emojis and "✅" or nil,
} -- BRC.EMOJI (do not remove this comment)

---- Items ----
BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine", "horn of Geryon",
  "lightning rod", "phantom mirror", "phial of floods", "sack of spiders", "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

-- This is checked against the full text of the pickup message, so use patterns to match
BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)

-- Could be removed after https://github.com/crawl/crawl/issues/4606 is addressed
BRC.SPELLBOOKS = {
  "parchment of", "book of", "Necronomicon", "Grand Grimoire", "tome of obsoleteness",
  "Everburning Encyclopedia", "Ozocubu's Autobiography", "Maxwell's Memoranda",
  "Young Poisoner's Handbook", "Fen Folio", "Inescapable Atlas", "There-And-Back Book",
  "Great Wizards, Vol. II", "Great Wizards, Vol. VII", "Trismegistus Codex",
  "the Unrestrained Analects", "Compendium of Siegecraft", "Codex of Conductivity",
  "Handbook of Applied Construction", "Treatise on Traps", "My Sojourn through Swampland",
  "Akashic Record",
  -- Include prefixes for randart books
  "Almanac", "Anthology", "Atlas", "Book", "Catalogue", "Codex", "Compendium",
  "Compilation", "Cyclopedia", "Directory", "Elucidation", "Encyclopedia", "Folio",
  "Grimoire", "Handbook", "Incunable", "Incunabulum", "Octavo", "Omnibus", "Papyrus",
  "Parchment", "Precepts", "Quarto", "Secrets", "Spellbook", "Tome", "Vellum", "Volume",
} -- BRC.SPELLBOOKS (do not remove this comment)

---- Races ----
BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant", }
BRC.NONLIVING_RACES = { "Djinni", "Gargoyle", }
BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant", }
BRC.LITTLE_RACES = { "Spriggan", }
BRC.SMALL_RACES = { "Kobold", }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll", }

---- Skills ----
BRC.STAFF_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", necromancy = "Necromancy",
  earth = "Earth Magic", fire = "Fire Magic", conjuration = "Conjurations",
} -- BRC.STAFF_SCHOOLS (do not remove this comment)

BRC.TRAINING_SKILLS = {
  "Air Magic", "Alchemy", "Armour", "Axes", "Conjurations", "Dodging", "Earth Magic", "Evocations", "Fighting",
  "Fire Magic", "Forgecraft", "Hexes", "Ice Magic", "Invocations", "Long Blades", "Maces & Flails", "Necromancy",
  "Polearms", "Ranged Weapons", "Shapeshifting", "Shields", "Short Blades", "Spellcasting", "Staves", "Stealth",
  "Summonings", "Translocations", "Unarmed Combat", "Throwing",
} -- BRC.TRAINING_SKILLS (do not remove this comment)

BRC.WEAP_SCHOOLS = {
  "axes", "maces & flails", "polearms", "long blades", "short blades", "staves", "unarmed combat", "ranged weapons",
} -- BRC.WEAP_SCHOOLS (do not remove this comment)

---- Branches ----
BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar", }
BRC.PORTAL_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "Ice Cave", "Necropolis",
  "Ossuary", "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_NAMES (do not remove this comment)

---- Egos + artefact properties ----
BRC.BAD_ART_PROPS = { "Bane", "*Corrode", "*Noise", "*Rage", "*Silence", "*Slow", "*Tele", "-Cast", "-Move", "-Tele", }
BRC.RISKY_EGOS = { "antimagic", "chaos", "distort", "harm", "heavy", "Infuse", "Ponderous", }
BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect", }

---- Other ----
-- BRC.COLOR:Would prefer to use integer values, but they don't work in all menus
BRC.COLOR = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COLOR (do not remove this comment)

BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg with no associated damage type
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.MUTATIONS = {
  antennae = "antennae", augmentation = "augmentation", beak = "beak", claws = "claws", deformed = "deformed body",
  demonic_touch = "demonic touch", hooves = "hooves", horns = "horns", missing_hand = "missing a hand",
  pseudopods = "pseudopods", sharp_scales = "sharp scales", sturdy_frame = "sturdy frame", talons = "talons",
} -- BRC.MUTATIONS (do not remove this comment)

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2, }

}
############################### End lua/core/constants.lua ###############################
##########################################################################################

################################### Begin lua/core/util.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Utility Functions - All utility functions organized into logical tables
Author: buehler
Dependencies: core/config.lua, core/constants.lua
--]]

---- Initialize BRC namespace
BRC = BRC or {}

---- Local variables ----
local _mpr_queue = {}

---- Local constants ----
local SPECIAL_CHARS = table.concat({ "(", "[", "%", "^", "$", "(", ")", "%", ".", "[", "]", "*", "+", "-", "?", ")" })

---- Local functions ----
local function cap_lines(str)
  if BRC.Data.Config.max_lines_per_table and BRC.Data.Config.max_lines_per_table > 0 then
    local lines = BRC.util.count_lines(str)
    if lines > BRC.Data.Config.max_lines_per_table then
      return string.format("{ %s lines... }", lines)
    end
  end
  return str
end

local function log_message(message, context, color)
  color = color or BRC.COLOR.lightgrey
  local msg = string.format("[BRC] %s", tostring(message))
  if context then msg = string.format("%s (%s)", msg, context) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

local function serialize_chk_lua_save()
  local tokens = { BRC.text.lightblue("\n---CHK_LUA_SAVE---") }
  for _, func in ipairs(chk_lua_save) do
    local result = func()
    if #result > 0 then tokens[#tokens + 1] = util.trim(result) end
  end

  return table.concat(tokens, "\n")
end

local function serialize_inventory()
  local tokens = { BRC.text.lightcyan("\n---INVENTORY---\n") }
  for inv in iter.invent_iterator:new(items.inventory()) do
    tokens[#tokens + 1] = string.format("%s: (%s) Qual: %s", inv.slot, inv.quantity, inv.name("qual"))
    local base = inv.name("base") or "N/A"
    local cls = inv.class(true) or "N/A"
    local st = inv.subtype() or "N/A"
    tokens[#tokens + 1] = string.format("  Base: %s Class: %s, Subtype: %s\n", base, cls, st)
  end

  return table.concat(tokens)
end

local function serialize_config()
  local tokens = { BRC.text.lightcyan("\n---BRC Config---\n") .. BRC.util.tostring(BRC.Config, true) }
  local all_features = BRC.get_registered_features()
  local keys = util.keys(all_features)
  util.sort(keys)

  for i = 1, #keys do
    local name = keys[i]
    local feature = all_features[name]
    if feature.Config then
      local header = BRC.text.cyan("\n\n---Feature Config: " .. name .. "---\n")
      tokens[#tokens + 1] = header .. BRC.util.tostring(feature.Config, true)
    end
  end

  return table.concat(tokens)
end

-----------------------------------
---- BRC.log - Logging methods ----
BRC.log = {}

function BRC.log.error(message, context)
  log_message("(Error) " .. message, context, BRC.COLOR.lightred)
  you.stop_activity()
  crawl.redraw_screen()
  crawl.more()
  crawl.redraw_screen()
end

function BRC.log.warning(message, context)
  log_message(message, context, BRC.COLOR.yellow)
  you.stop_activity()
end

function BRC.log.info(message, context)
  log_message(message, context, BRC.COLOR.white)
end

function BRC.log.debug(message, context)
  if not BRC.Config.show_debug_messages then return end
  log_message(message, context, BRC.COLOR.lightblue)
end

---------------------------------------------------
---- BRC.text - Text color + parsing functions ----
BRC.text = {}

-- Remove tags from text, and optionally escape special characters
function BRC.text.clean(text, escape_chars)
  text = text:gsub("\n", "")
  if escape_chars then text = text:gsub(SPECIAL_CHARS, "%%%1") end
  return text:gsub("<[^>]*>", "")
end

-- Wrap text in a color tag, Usage: BRC.text.blue("Hello"), or BRC.text["1"]("Hello")
for k, v in pairs(BRC.COLOR) do
  BRC.text[k] = function(text)
    return string.format("<%s>%s</%s>", v, tostring(text), v)
  end
  BRC.text[v] = BRC.text[k]
end

function BRC.text.color(color, text)
  return color and BRC.text[color](text) or tostring(text)
end

function BRC.text.contains(self, text)
  return self:find(text, 1, true) ~= nil
end

-- Connect string:contains() to BRC.text.contains()
getmetatable("").__index.contains = BRC.text.contains

function BRC.text.get_pickup_info(text)
  local cleaned = BRC.text.clean(text, false)
  if cleaned:sub(2, 4) ~= " - " then return nil end
  return { slot = items.letter_to_index(cleaned:sub(1, 1)), item = cleaned:sub(5, #cleaned) }
end

---------------------------------------------
---- BRC.mpr - Wrappers around crawl.mpr ----
BRC.mpr = {}

-- Output message in color. Usage: BRC.mpr.white("Hello"), or BRC.mpr["15"]("Hello")
for k, v in pairs(BRC.COLOR) do
  BRC.mpr[k] = function(text, channel)
    crawl.mpr(BRC.text.color(v, text), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.color(text, color, channel)
  if color then
    BRC.mpr[color](text, channel)
  else
    crawl.mpr(tostring(text), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.okay(suffix)
  BRC.mpr.darkgrey("Okay, then." .. (suffix and " " .. suffix or ""))
end

-- Message plus stop travel/activity
function BRC.mpr.stop(text, color, channel)
  BRC.mpr.color(text, color, channel)
  you.stop_activity()
end

-- Message as a force_more_message
function BRC.mpr.more(text, color, channel)
  BRC.mpr.color(text, color, channel)
  you.stop_activity()
  crawl.redraw_screen()
  crawl.more()
  crawl.redraw_screen()
end

-- Conditional force_more_message
function BRC.mpr.optmore(show_more, text, color, channel)
  if show_more then
    BRC.mpr.more(text, color, channel)
  else
    BRC.mpr.color(text, color, channel)
  end
end

-- Queue the message, to dispay at start of next turn
function BRC.mpr.que(text, color, channel)
  for _, msg in ipairs(_mpr_queue) do
    if msg.text == text and msg.channel == channel then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { text = BRC.text.color(color, text), channel = channel, show_more = false }
end

-- Queue msg w/ conditional force_more_message
function BRC.mpr.que_optmore(show_more, text, color, channel)
  for _, msg in ipairs(_mpr_queue) do
    if msg.text == text and msg.channel == channel and msg.show_more == show_more then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { text = BRC.text.color(color, text), channel = channel, show_more = show_more }
end

-- Display queued messages and clear the queue
function BRC.mpr.consume_queue()
  local do_more = false
  for _, msg in ipairs(_mpr_queue) do
    crawl.mpr(tostring(msg.text), msg.channel)
    crawl.flush_prev_message()
    if msg.show_more then do_more = true end
  end

  if do_more then
    you.stop_activity()
    crawl.redraw_screen()
    crawl.more()
    crawl.redraw_screen()
  end

  _mpr_queue = {}
end

-- Get a selection from the user, from a list of options
function BRC.mpr.select(text, options, color)
  if not (options and type(options) == "table" and #options > 0) then
    BRC.log.error("No options provided for BRC.mpr.select")
    return false
  end

  color = color or BRC.COLOR.lightcyan
  local msg = string.format("%s:\n", text)
  for i, option in ipairs(options) do
    msg = msg .. string.format("%s: %s\n", i, BRC.text.white(option))
  end
  crawl.formatted_mpr(BRC.text.color(color, msg), "prompt")
  for _ = 1, 10 do
    local res = crawl.getch()
    if res then
      local num = res - string.byte("0")
      if num > 0 and num <= #options then return options[num] end
    end
    BRC.mpr.magenta("Invalid option, try again.")
  end

  BRC.mpr.lightmagenta("Fine then. Using option 1: " .. options[1])
  return options[1]
end

-- Get a yes/no response
function BRC.mpr.yesno(text, color, capital_only)
  local msg = string.format("%s (%s)", text, capital_only and "Y/N" or "y/n")

  for i = 1, 10 do
    crawl.formatted_mpr(BRC.text.color(color, msg), "prompt")
    local res = crawl.getch()
    if res and res >= 0 and res <= 255 then
      if string.char(res) == "Y" or string.char(res) == "y" and not capital_only then return true end
      if string.char(res) == "N" or string.char(res) == "n" and not capital_only then return false end
    end
    if i == 1 and capital_only then msg = "[CAPS ONLY] " .. msg end
  end

  BRC.mpr.lightmagenta("Feels like a no.")
  return false
end

-----------------------------------------------------
---- BRC.get - Functions to get non-boolean data ----
BRC.get = {}

function BRC.get.num_equip_slots(it)
  local player_race = you.race()
  if it.is_weapon then return player_race == "Coglin" and 2 or 1 end
  if BRC.is.aux_armour(it) then
    if player_race == "Formicid" then return it.subtype() == "gloves" and 2 or 1 end
    return player_race == "Poltergeist" and 6 or 1
  end

  return 1
end

function BRC.get.command_key(cmd)
  local key = crawl.get_command(cmd)
  if not key then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  if key:contains("Ctrl") then return BRC.util.control_key(char_key) end
  return char_key
end

--[[
BRC.get.equipped_at() - Returns 2 values (usually a list of length 1, with num_slots==1):
  1. A list of equipped items at the same slot as the item
  2. the num_slots (ie maximum size the list can ever be)
--]]
function BRC.get.equipped_at(it)
  local all_aux = {}
  local num_slots = BRC.get.num_equip_slots(it)
  local slot_name = it.is_weapon and "weapon" or BRC.is.body_armour(it) and "armour" or it.subtype()
  for i = 1, num_slots do
    local eq = items.equipped_at(slot_name, i)
    all_aux[#all_aux + 1] = eq
  end
  return all_aux, num_slots
end

function BRC.get.mut(mutation, include_all)
  return you.get_base_mutation_level(mutation, true, include_all, include_all)
end

function BRC.get.preferred_weapon_type()
  local max_weap_skill = 0
  local pref = nil
  for _, v in ipairs(BRC.WEAP_SCHOOLS) do
    if BRC.get.skill(v) > max_weap_skill then
      max_weap_skill = BRC.get.skill(v)
      pref = v
    end
  end
  return pref
end

function BRC.get.skill(skill)
  if skill and not skill:contains(",") then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local sum = 0
  local count = 0
  for _, s in ipairs(skills) do
    sum = sum + you.skill(s)
    count = count + 1
  end
  return sum / count
end

function BRC.get.skill_with(it)
  if BRC.is.magic_staff(it) then return math.max(BRC.get.skill(BRC.get.staff_school(it)), BRC.get.skill("Staves")) end
  if it.is_weapon then return BRC.get.skill(it.weap_skill) end
  if BRC.is.body_armour(it) then return BRC.get.skill("Armour") end
  if BRC.is.shield(it) then return BRC.get.skill("Shields") end
  if BRC.is.talisman(it) then return BRC.you.shapeshifting_skill() end

  BRC.log.error("Unknown skill for item: " .. it.name())
end

function BRC.get.staff_school(it)
  for k, v in pairs(BRC.STAFF_SCHOOLS) do
    if it.subtype() == k then return v end
  end
end

function BRC.get.talisman_min_level(it)
  if it.name() == "protean talisman" then return 6 end

  -- Parse the item description
  local tokens = crawl.split(it.description, "\n")
  for _, v in ipairs(tokens) do
    if v:sub(1, 4) == "Min " then
      local start_pos = v:find("%d", 4)
      if start_pos then
        local end_pos = v:find("[^%d]", start_pos)
        return tonumber(v:sub(start_pos, end_pos - 1))
      end
    end
  end

  BRC.log.error("Failed to find skill required for: " .. it.name())
  return -1
end

------------------------------------------
---- BRC.is - Boolean checks of items ----
BRC.is = {}

function BRC.is.amulet(it)
  return it and it.name("base") == "amulet"
end

function BRC.is.armour(it, include_orbs)
  -- exclude orbs by default
  if not it or it.class(true) ~= "armour" then return false end
  if not include_orbs and BRC.is.orb(it) then return false end
  return true
end

function BRC.is.aux_armour(it)
  return BRC.is.armour(it) and not (BRC.is.body_armour(it) or BRC.is.shield(it))
end

function BRC.is.body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.is.jewellery(it)
  return it and it.class(true) == "jewellery"
end

function BRC.is.list(value)
  return value and type(value) == "table" and #value > 0
end

function BRC.is.magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

function BRC.is.map(value)
  return value and type(value) == "table" and next(value) ~= nil and #value == 0
end

function BRC.is.ring(it)
  return it and it.name("base") == "ring"
end

function BRC.is.scarf(it)
  return it and it.class(true) == "armour" and it.subtype() == "cloak" and it.name():contains("scarf")
end

function BRC.is.shield(it)
  return it and it.is_shield()
end

function BRC.is.talisman(it)
  if not it then return false end
  local c = it.class(true)
  return c and (c == "talisman")
end

function BRC.is.orb(it)
  return it and it.class(true) == "armour" and it.subtype() == "offhand" and not it.is_shield()
end

function BRC.is.polearm(it)
  return it and it.weap_skill:contains("Polearms")
end

-------------------------------------------------------
---- BRC.you - Boolean attributes of the character ----
BRC.you = {}

function BRC.you.by_slimy_wall()
  for x = -1, 1 do
    for y = -1, 1 do
      if view.feature_at(x, y) == "slimy_wall" then return true end
    end
  end
  return false
end

function BRC.you.free_offhand()
  if BRC.get.mut(BRC.MUTATIONS.missing_hand, true) > 0 then return true end
  return not items.equipped_at("offhand")
end

function BRC.you.have_shield()
  return BRC.is.shield(items.equipped_at("offhand"))
end

function BRC.you.in_hell(exclude_vestibule)
  local branch = you.branch()
  if exclude_vestibule and branch == "Hell" then return false end
  return util.contains(BRC.HELL_BRANCHES, branch)
end

function BRC.you.miasma_immune()
  if util.contains(BRC.UNDEAD_RACES, you.race()) then return true end
  if util.contains(BRC.NONLIVING_RACES, you.race()) then return true end
  return false
end

function BRC.you.mutation_immune()
  return util.contains(BRC.UNDEAD_RACES, you.race())
end

function BRC.you.shapeshifting_skill()
  local skill = you.skill("Shapeshifting")
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.name() == "amulet of wildshape" then return skill + 5 end
  end
  return skill
end

function BRC.you.zero_stat()
  return you.strength() <= 0 or you.dexterity() <= 0 or you.intelligence() <= 0
end

--------------------------------------------------
---- BRC.set - Wrappers around crawl.setopt() ----
BRC.set = {}

function BRC.set.autopickup_exceptions(pattern, add_pattern)
  local op = add_pattern and "^=" or "-="
  crawl.setopt(string.format("autopickup_exceptions %s %s", op, pattern))
end

function BRC.set.explore_stop(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop %s %s", op, pattern))
end

function BRC.set.explore_stop_pickup_ignore(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop_pickup_ignore %s %s", op, pattern))
end

function BRC.set.flash_screen_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("flash_screen_message %s %s", op, pattern))
end

function BRC.set.force_more_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("force_more_message %s %s", op, pattern))
end

-- Binds a macro to a key. Function must be global and not a member of a module.
function BRC.set.macro(key, function_name)
  BRC.log.debug(
    string.format(
      "Assigning macro: %s to key: %s",
      BRC.text.magenta(function_name .. "()"),
      BRC.text.lightred("<<< '" .. key .. "' >>")
    )
  )
  crawl.setopt(string.format("macros += M %s ===%s", key, function_name))
end

function BRC.set.message_mute(pattern, mute_pattern)
  local op = mute_pattern and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.set.runrest_ignore_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_ignore_message %s %s", op, pattern))
end

function BRC.set.runrest_stop_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_stop_message %s %s", op, pattern))
end

------------------------------------------------------------------------------
--- BRC.dump - Debugging messages for char dump or in-game lua interpreter ---
BRC.dump = {}

-- BRC.dump.all(): Main debug dump. Serializes from non-dependent modules, after checking for existence
-- Usage: In lua interpreter, usually `BRC.dump.all()`, or `BRC.dump.all(1)` for verbose output
function BRC.dump.all(verbose, skip_mpr)
  local tokens = {}
  tokens[#tokens + 1] = BRC.Data.serialize()
  if verbose then
    tokens[#tokens + 1] = serialize_chk_lua_save()
    tokens[#tokens + 1] = serialize_inventory()
    tokens[#tokens + 1] = _weapon_cache.serialize()
    tokens[#tokens + 1] = serialize_config()
  end

  local text = table.concat(tokens, "\n")
  if not skip_mpr then BRC.mpr.white(text) end

  return text
end

function BRC.dump.char(add_debug_info)
  if add_debug_info then
    crawl.take_note(BRC.dump.all(true, true))
    BRC.mpr.lightgrey("BRC debug info added to character dump.")
  else
    BRC.mpr.darkgrey("No debug info added.")
  end
  BRC.util.do_cmd("CMD_CHARACTER_DUMP")
end

function BRC.dump.var(v)
  crawl.mpr(BRC.util.tostring(v, true) or "nil")
end

function macro_brc_dump_character()
  if not BRC.active then BRC.util.do_cmd("CMD_CHARACTER_DUMP") end
  BRC.dump.char(BRC.mpr.yesno("Add BRC debug info to character dump?", BRC.COLOR.lightcyan))
end

----------------------------------------------
---- BRC.util - General utility functions ----
BRC.util = {}

function BRC.util.control_key(c)
  return string.byte(c:upper()) - 64
end

function BRC.util.count_lines(str)
  if type(str) ~= "string" then return 0 end
  local count = 1
  str:gsub("\n", function() count = count + 1 end)
  return count
end

-- BRC.util.do_cmd(): Tries keypress first, then crawl.do_commands() (which isn't always immediate)
function BRC.util.do_cmd(cmd)
  local key = BRC.get.command_key(cmd)
  if key then
    crawl.sendkeys({ key })
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.int2char(num)
  return string.char(string.byte("a") + num)
end

-- Sorts the keys of a dictionary/map: vars before tables, then alphabetically by key
-- If a list is passed, it assumed it is a list of global variable names
function BRC.util.get_sorted_keys(map_or_list)
  local keys_vars = {}
  local keys_tables = {}

  if BRC.is.map(map_or_list) then
    for key, v in pairs(map_or_list) do
      table.insert(type(v) == "table" and keys_tables or keys_vars, key)
    end
  else
    for _, key in ipairs(map_or_list) do
      table.insert(type(_G[key]) == "table" and keys_tables or keys_vars, key)
    end
  end

  util.sort(keys_vars)
  util.sort(keys_tables)
  util.append(keys_vars, keys_tables)
  return keys_vars
end

-- BRC.util.tostring(): Serializes a variable to a string, for chk_lua_save or data dumps.
-- If pretty = true, the string is formatted for readability and in-game display.
function BRC.util.tostring(var, pretty, indent_count)
  local var_type = type(var)
  if var_type == "string" then
    local s
    if var:contains("\n") then
      s = "[[\n" .. var .. "\n]]"
    else
      s = '"' .. var:gsub('"', "") .. '"'
    end
    if not pretty then return s end
    return s:gsub(">", "TempGT"):gsub("<", "TempLT"):gsub("TempGT", "<gt>"):gsub("TempLT", "<lt>")
  elseif var_type == "table" then
    indent_count = indent_count or 0
    local indent = string.rep("  ", indent_count)
    local child_indent = string.rep("  ", indent_count + 1)
    local list_separator = ",\n" .. child_indent

    if BRC.is.list(var) then
      local tokens = {}
      for _, v in ipairs(var) do
        tokens[#tokens + 1] = cap_lines(BRC.util.tostring(v, pretty, indent_count + 1))
      end
      if #tokens < 4 and not util.exists(var, function(t) return type(t) == "table" end) then
        return string.format("{ %s }", table.concat(tokens, ", "))
      else
        return "{\n" .. child_indent .. table.concat(tokens, list_separator) .. "\n" .. indent .. "}"
      end
    elseif BRC.is.map(var) then
      local tokens = {}
      if pretty then
        local keys = BRC.util.get_sorted_keys(var)
        local contains_table = false
        for i = 1, #keys do
          local v = cap_lines(BRC.util.tostring(var[keys[i]], true, indent_count + 1))
          if v then
            if type(var[keys[i]]) == "table" then
              contains_table = true
              tokens[#tokens + 1] = string.format('["%s"] = %s', keys[i], v)
            else
              tokens[#tokens + 1] = string.format("%s = %s", keys[i], v)
            end
          end
        end
        if #tokens <= 2 and not contains_table then
          return string.format("{ %s }", table.concat(tokens, ", "))
        end
      else
        for k, v in pairs(var) do
          tokens[#tokens + 1] = string.format('["%s"] = %s', k, BRC.util.tostring(v, pretty, indent_count + 1))
        end
      end
      return "{\n" .. child_indent .. table.concat(tokens, list_separator) .. "\n" .. indent .. "}"
    else
      return "{}"
    end
  else
    if BRC.Data.Config.skip_pointers and (type(var) == "function" or type(var) == "userdata") then
      return nil
    end
    return tostring(var)
  end
end

--[[
The functions above are general purpose: They should apply to any crawl RC file.
The functions below contain design choices or logic that are somewhat specific to BRC.
Examples: Weapon DPS calculation, treat dragon scales as branded, defining what a "risky item" is.
--]]

---- Local functions ---- (Often mirroring calculations that live in crawl.)
-- Last verified against: dcss v0.33.1

local function format_dmg(dmg)
  -- Format damage values for consistent display width (4 characters)
  if dmg < 10 then return string.format("%.2f", dmg) end
  if dmg > 99.9 then return ">100" end
  return string.format("%.1f", dmg)
end

local function format_stat(abbr, val, is_worn)
  -- Format stat changes for inscriptions: current values for equipped items(:), or relative for unequpped (+/-)
  local stat_str = string.format("%.1f", val)
  if val < 0 then
    return string.format("%s%s", abbr, stat_str)
  elseif is_worn then
    return string.format("%s:%s", abbr, stat_str)
  else
    return string.format("%s+%s", abbr, stat_str)
  end
end

local function get_size_penalty()
  if util.contains(BRC.LITTLE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LITTLE
  elseif util.contains(BRC.SMALL_RACES, you.race()) then
    return BRC.SIZE_PENALTY.SMALL
  elseif util.contains(BRC.LARGE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LARGE
  else
    return BRC.SIZE_PENALTY.NORMAL
  end
end

local function get_unadjusted_armour_pen(encumb)
  local pen = encumb - 2 * BRC.get.mut(BRC.MUTATIONS.sturdy_frame, true)
  if pen > 0 then return pen end
  return 0
end

local function get_adjusted_armour_pen(encumb, str)
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_adjusted_dodge_bonus(encumb, str, dex)
  local size_factor = -2 * get_size_penalty()
  local dodge_bonus = 8 * (10 + you.skill("Dodging") * dex) / (20 - size_factor) / 10
  local armour_dodge_penalty = get_unadjusted_armour_pen(encumb) - 3
  if armour_dodge_penalty <= 0 then return dodge_bonus end

  if armour_dodge_penalty >= str then return dodge_bonus * str / (armour_dodge_penalty * 2) end
  return dodge_bonus - dodge_bonus * armour_dodge_penalty / (str * 2)
end

local function get_shield_penalty(sh)
  return 2 * sh.encumbrance * sh.encumbrance * (27 - you.skill("Shields")) / 27 / (25 + 5 * you.strength())
end

local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Doesn't check brand or delay >=3, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):contains("woodcutter's axe") then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:contains("crossbow") or basename:contains("arbalest")
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

local function get_weap_delay(it)
  -- dcss v0.33.1
  local delay = it.delay - BRC.get.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.get.ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.is.shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

local function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaict
  for i = 0, 20 do
    local inv = items.equipped_at(i)
    if inv then
      if BRC.is.ring(inv) then
        if inv.artefact then
          local name = inv.name()
          local idx = name:find("Slay", 1, true)
          if idx then
            local slay = tonumber(name:sub(idx + 5, idx + 5))
            if slay == 1 then
              local next_digit = tonumber(name:sub(idx + 6, idx + 6))
              if next_digit then slay = 10 + next_digit end
            end

            if name:sub(idx + 4, idx + 4) == "+" then
              sum = sum + slay
            else
              sum = sum - slay
            end
          end
        elseif BRC.get.ego(inv) == "Slay" then
          sum = sum + inv.plus
        end
      elseif inv.artefact and (BRC.is.armour(inv, true) or BRC.is.amulet(inv)) then
        local slay = inv.artprops["Slay"]
        if slay then sum = sum + slay end
      end
    end
  end

  if you.race() == "Demonspawn" then
    sum = sum + 3 * BRC.get.mut(BRC.MUTATIONS.augmentation, true)
    sum = sum + BRC.get.mut(BRC.MUTATIONS.sharp_scales, true)
  end

  return sum
end

local function get_staff_bonus_dmg(it, dmg_type)
  -- dcss v0.33.1
  if dmg_type == BRC.DMG_TYPE.unbranded then return 0 end
  if dmg_type == BRC.DMG_TYPE.plain then
    local basename = it.name("base")
    if basename ~= "staff of earth" and basename ~= "staff of conjuration" then return 0 end
  end

  local spell_skill = BRC.get.skill(BRC.get.staff_school(it))
  local evo_skill = you.skill("Evocations")

  local chance = (2 * evo_skill + spell_skill) / 30
  if chance > 1 then chance = 1 end
  -- 0.75 is an acceptable approximation; most commonly 63/80
  -- Varies by staff type in sometimes complex ways
  local avg_dmg = 3 / 4 * (evo_skill / 2 + spell_skill)
  return avg_dmg * chance
end

-- Formatting for stat inscriptions & alerts
function BRC.get.armour_stats(it)
  if not BRC.is.armour(it) then return "", "" end

  local cur = items.equipped_at(it.equip_type)
  local is_worn = it.equipped or (it.ininventory and cur and cur.slot == it.slot)
  local cur_ac = 0
  local cur_sh = 0
  local cur_ev = 0
  -- Never show deltas if multiple equip slots
  if cur and not is_worn and BRC.get.num_equip_slots(it) == 1 then
    -- Show deltas if not worn, else compare against 0
    if BRC.is.shield(cur) then
      cur_sh = BRC.get.shield_sh(cur)
      cur_ev = -get_shield_penalty(cur)
    else
      cur_ac = BRC.get.armour_ac(cur)
      cur_ev = BRC.get.armour_ev(cur)
    end
  end

  if BRC.is.shield(it) then
    local sh_str = format_stat("SH", BRC.get.shield_sh(it) - cur_sh, is_worn)
    local ev_str = format_stat("EV", -get_shield_penalty(it) - cur_ev, is_worn)
    return sh_str, ev_str
  else
    local ac_str = format_stat("AC", BRC.get.armour_ac(it) - cur_ac, is_worn)
    if not BRC.is.body_armour(it) then return ac_str end
    local ev_str = format_stat("EV", BRC.get.armour_ev(it) - cur_ev, is_worn)
    return ac_str, ev_str
  end
end

function BRC.get.weapon_stats(it, dmg_type)
  if not it.is_weapon then return end
  if not dmg_type then
    if f_inscribe_stats and f_inscribe_stats.Config and f_inscribe_stats.Config.inscribe_dps_type then
      dmg_type = BRC.DMG_TYPE[f_inscribe_stats.Config.inscribe_dps_type]
    else
      dmg_type = BRC.DMG_TYPE.plain
    end
  end
  local dmg = format_dmg(BRC.get.weap_damage(it, dmg_type))
  local delay = get_weap_delay(it)
  local delay_str = string.format("%.1f", delay)
  if delay < 1 then
    delay_str = string.format("%.2f", delay)
    delay_str = delay_str:sub(2, #delay_str)
  end

  local dps = format_dmg(dmg / delay)
  local acc = it.accuracy + (it.plus or 0)
  if acc >= 0 then acc = string.format("+%s", acc) end

  --TODO: This would be nice if it worked in all UIs
  --return string.format("DPS:<w>%s</w> (%s/%s), Acc<w>%s</w>", dps, dmg, delay_str, acc)
  return string.format("DPS: %s (%s/%s), Acc%s", dps, dmg, delay_str, acc)
end

-- BRC.get.ego() - Weapon + Armour egos, with custom logic:
-- Treats unusable egos as no ego. Consistently lowercases non-artefacts.
-- Includes: artefacts, armours with innate egos (except steam dragon scales)
-- If an artefact has a normal brand, it returns just that. (ie a return value of "flame" could be an artefact or not)
function BRC.get.ego(it, exclude_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    if BRC.is.unusable_ego(ego) or (exclude_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.is.body_armour(it) then
    local qualname = it.name("qual")
    if qualname:contains("troll leather") or qualname:contains("dragon scales") and not qualname:contains("steam") then
      return qualname
    end
  end

  if it.artefact then return it.name() end
end

function BRC.get.hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  local st = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end

function BRC.get.items_in_slot(slot)
  local inv_items = {}
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.slot == slot then inv_items[#inv_items + 1] = inv end
  end
  return inv_items
end

function BRC.is.risky_item(it)
  if it.artefact then
    for k, v in pairs(it.artprops) do
      if util.contains(BRC.BAD_ART_PROPS, k) or v < 0 then return true end
    end
  end

  local ego_name = BRC.get.ego(it)
  return ego_name and util.contains(BRC.RISKY_EGOS, ego_name)
end

function BRC.is.unusable_ego(ego)
  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
      or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
      or ego == "pain" and you.skill("Necromancy") == 0
end

-- Armour stats
function BRC.get.armour_ac(it)
  -- dcss v0.33.1
  local it_plus = it.plus or 0

  if it.artefact and it.is_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end

  local ac = it.ac * (1 + you.skill("Armour") / 22) + it_plus
  if not BRC.is.body_armour(it) then return ac end

  local deformed = BRC.get.mut(BRC.MUTATIONS.deformed, true) > 0
  local pseudopods = BRC.get.mut(BRC.MUTATIONS.pseudopods, true) > 0
  if pseudopods or deformed then return ac * 6 / 10 end

  return ac
end

function BRC.get.armour_ev(it)
  -- dcss v0.33.1
  -- This function computes the armour-based component to standard EV (not paralysed, etc)
  -- Factors in stat changes from this armour and removing current one
  local str = you.strength()
  local dex = you.dexterity()
  local no_art_str = str
  local no_art_dex = dex
  local art_ev = 0

  -- Adjust str/dex/EV for artefact stat changes
  local worn = items.equipped_at("armour")
  if worn and worn.artefact then
    if worn.artprops["Str"] then str = str - worn.artprops["Str"] end
    if worn.artprops["Dex"] then dex = dex - worn.artprops["Dex"] end
    if worn.artprops["EV"] then art_ev = art_ev - worn.artprops["EV"] end
  end

  if it.artefact then
    if it.artprops["Str"] then str = str + it.artprops["Str"] end
    if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
    if it.artprops["EV"] then art_ev = art_ev + it.artprops["EV"] end
  end

  if str <= 0 then str = 1 end

  local dodge_bonus = get_adjusted_dodge_bonus(it.encumbrance, str, dex)
  local naked_dodge_bonus = get_adjusted_dodge_bonus(0, no_art_str, no_art_dex)
  return (dodge_bonus - naked_dodge_bonus) + art_ev - get_adjusted_armour_pen(it.encumbrance, str)
end

function BRC.get.shield_sh(it)
  -- dcss v0.33.1
  local dex = you.dexterity()
  if it.artefact and it.is_identified then
    local art_dex = it.artprops["Dex"]
    if art_dex then dex = dex + art_dex end
  end

  local cur = items.equipped_at("offhand")
  if BRC.is.shield(cur) and cur.artefact and cur.slot ~= it.slot then
    local art_dex = cur.artprops["Dex"]
    if art_dex then dex = dex - art_dex end
  end

  local it_plus = it.plus or 0

  local base_sh = it.ac * 2
  local shield = base_sh * (50 + you.skill("Shields") * 5 / 2)
  shield = shield + 200 * it_plus
  shield = shield + 38 * (you.skill("Shields") + 3 + dex * (base_sh + 13) / 26)
  return shield / 200
end

-- Weapon stats
function BRC.get.weap_dps(it, dmg_type)
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  return BRC.get.weap_damage(it, dmg_type) / get_weap_delay(it)
end

function BRC.get.weap_damage(it, dmg_type)
  -- Returns an adjusted weapon damage = damage * speed
  -- Includes stat/slay changes between weapon and the one currently wielded
  -- Aux attacks not included
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  local it_plus = it.plus or 0
  -- Adjust str/dex/slay from artefacts
  local str = you.strength()
  local dex = you.dexterity()

  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local wielded = items.equipped_at("weapon")
    if wielded and wielded.artefact then
      if wielded.artprops["Str"] then str = str - wielded.artprops["Str"] end
      if wielded.artprops["Dex"] then dex = dex - wielded.artprops["Dex"] end
      if wielded.artprops["Slay"] then it_plus = it_plus - wielded.artprops["Slay"] end
    end

    if it.artefact and it.is_identified then
      if it.artprops["Str"] then str = str + it.artprops["Str"] end
      if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
      if it.artprops["Slay"] then it_plus = it_plus + it.artprops["Slay"] end
    end
  end

  local stat = str
  if it.is_ranged or it.weap_skill:contains("Blades") then stat = dex end

  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + BRC.get.skill(it.weap_skill) / 25 / 2) * (1 + you.skill("Fighting") / 30 / 2)

  it_plus = it_plus + get_slay_bonuses()

  local pre_brand_dmg_no_plus = it.damage * stat_mod * skill_mod
  local pre_brand_dmg = pre_brand_dmg_no_plus + it_plus

  if BRC.is.magic_staff(it) then return pre_brand_dmg + get_staff_bonus_dmg(it, dmg_type) end

  if dmg_type == BRC.DMG_TYPE.plain then
    local ego = BRC.get.ego(it)
    if ego and util.contains(BRC.NON_ELEMENTAL_DMG_EGOS, ego) then
      local bonus = BRC.Data.Config.BrandBonus[ego] or BRC.Data.Config.BrandBonus.subtle[ego]
      return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset
    end
  elseif dmg_type >= BRC.DMG_TYPE.branded then
    local ego = BRC.get.ego(it)
    if ego then
      local bonus = BRC.Data.Config.BrandBonus[ego]
      if not bonus and dmg_type == BRC.DMG_TYPE.scoring then bonus = BRC.Data.Config.BrandBonus.subtle[ego] end
      if bonus then return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset end
    end
  end

  return pre_brand_dmg
end

}
############################### End lua/core/util.lua ###############################
##########################################################################################

################################### Begin lua/core/data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC.Data - Persistent data management module
Manages persistent data across games and saves
Author: buehler
Dependencies: core/constants.lua, core/util.lua
--]]

---- Initialize BRC namespace and Data module
BRC = BRC or {}
BRC.Data = {}
BRC.Data.BRC_FEATURE_NAME = "data-manager" -- Included as a feature, just for the Config override feature

-- Config values for data dumps
BRC.Data.Config = {
  max_lines_per_table = 200, -- Avoid huge tables in debug dumps, like alert_monsters.Config.Alerts
  skip_pointers = true, -- Don't dump functions and userdata (they only show a hex address)

  BrandBonus = {
    chaos = { factor = 1.15, offset = 2.0 }, -- Approximate weighted average
    distort = { factor = 1.0, offset = 6.0 },
    drain = { factor = 1.25, offset = 2.0 },
    elec = { factor = 1.0, offset = 4.5 },   -- 3.5 on avg; fudged up for AC pen
    flame = { factor = 1.25, offset = 0 },
    freeze = { factor = 1.25, offset = 0 },
    heavy = { factor = 1.8, offset = 0 },    -- Speed is accounted for elsewhere
    pain = { factor = 1.0, offset = you.skill("Necromancy") / 2 },
    spect = { factor = 1.7, offset = 0 },    -- Fudged down for increased incoming damage
    venom = { factor = 1.0, offset = 5.0 },  -- 5 dmg per poisoning

    subtle = { -- Values estimated for weapon comparisons
      antimagic = { factor = 1.1, offset = 0 },
      holy = { factor = 1.15, offset = 0 },
      penet = { factor = 1.3, offset = 0 },
      protect = { factor = 1.15, offset = 0 },
      reap = { factor = 1.3, offset = 0 },
      vamp = { factor = 1.2, offset = 0 },
    },
  },
} -- BRC.Data.Config (do not remove this comment)

---- Local constants ----
local RESTORE_TABLE = "_brc_persist_restore_table"

---- Local variables ----
local failed_restores = {}
local pushed_restore_table_creation = false
local _persist_names = {}

---- Local functions ----
local function is_usable_backup()
  if
    type(c_persist.BRC) ~= "table"
    or type(c_persist.BRC.Backup) ~= "table"
    or c_persist.BRC.Backup.backup_name ~= you.name()
    or c_persist.BRC.Backup.backup_race ~= you.race()
    or c_persist.BRC.Backup.backup_class ~= you.class()
  then
    return false
  end

  local turn_diff = you.turns() - c_persist.BRC.Backup.backup_turn
  if turn_diff == 0 then return true end
  for _ = 1, 5 do
    if BRC.mpr.yesno(string.format("Use backup from %s turns ago?", turn_diff)) then return true end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return false end
  end
  return true
end

---- Public API ----

--[[
BRC.Data.persist() Creates a persistent global variable or table, initialized to the default value if it doesn't exist.
The variable/table is automatically persisted across saves.
Returns the current value.
Usage: variable_name = BRC.Data.persist("variable_name", default_value)
--]]
function BRC.Data.persist(name, default_value)
  if not util.contains({ "table", "string", "number", "boolean", "nil" }, type(default_value)) then
    BRC.log.error(string.format("Cannot persist %s. Default value is of type %s", name, type(default_value)))
    return default_value
  end

  -- Try to restore from persistent restore table
  if you.turns() == 0 then
    _G[name] = default_value
  elseif _G[RESTORE_TABLE] and _G[RESTORE_TABLE][name] ~= nil then
    _G[name] = _G[RESTORE_TABLE][name]
    _G[RESTORE_TABLE][name] = nil
  elseif default_value ~= nil then -- default of nil means only restore if the var is set
    _G[name] = default_value
    failed_restores[#failed_restores + 1] = name
    BRC.log.debug(BRC.text.red(name .. " failed to restore from chk_lua_save."))
  end

  -- Create persistent restore table on next startup
  if not pushed_restore_table_creation then
    table.insert(chk_lua_save, function()
      return RESTORE_TABLE .. " = {}\n"
    end)
    pushed_restore_table_creation = true
  end

  -- Set up persist on next startup
  if not util.contains(_persist_names, name) then
    _persist_names[#_persist_names + 1] = name
    table.insert(chk_lua_save, function()
      if _G[name] == nil then return "" end
      return RESTORE_TABLE .. "." .. name .. " = " .. BRC.util.tostring(_G[name]) .. "\n"
    end)
  end

  return _G[name]
end

function BRC.Data.serialize()
  local tokens = { BRC.text.lightmagenta("\n---PERSISTENT VARIABLES---\n") }
  local sorted_keys = BRC.util.get_sorted_keys(_persist_names)
  for _, key in ipairs(sorted_keys) do
    tokens[#tokens + 1] = string.format("%s = %s\n", key, BRC.util.tostring(_G[key], true))
  end
  return table.concat(tokens)
end

function BRC.Data.erase()
  if _persist_names then
    for _, name in ipairs(_persist_names) do
      _G[name] = nil
    end
  end

  _persist_names = {}
  BRC.active = false
  BRC.log.warning("Erased all persistent data and disabled BRC. Restart crawl to reload defaults.")
end

-- verify_reinit(): Returns true if all data successful, and a list of failed variables
function BRC.Data.verify_reinit()
  if #failed_restores == 0 then return true, nil end
  local patt = "%s persistent variables did not restore: (%s)"
  BRC.log.error(string.format(patt, #failed_restores, table.concat(failed_restores, ", ")))

  for _ = 1, 5 do
    if BRC.mpr.yesno("Try restoring from backup?") then return false, failed_restores end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return false, nil end
  end
  return false
end

-- Backup and Restore from c_persist.BRC.Backup
function BRC.Data.backup()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
  c_persist.BRC.Backup = {}
  c_persist.BRC.Backup.backup_name = you.name()
  c_persist.BRC.Backup.backup_race = you.race()
  c_persist.BRC.Backup.backup_class = you.class()
  c_persist.BRC.Backup.backup_turn = you.turns()
  for _, name in ipairs(_persist_names) do
    c_persist.BRC.Backup[name] = _G[name]
  end
end

function BRC.Data.try_restore(failures)
  if not is_usable_backup() then
    BRC.mpr.red("[BRC] Unable to restore from backup. Persistent data reset to defaults. ")
    BRC.log.info("For detailed startup info, set BRC.Config.show_debug_messages=True.")
    return false
  end

  for _, name in ipairs(failures) do
    _G[name] = BRC.Data.persist(name, c_persist.BRC.Backup[name])
  end
  BRC.mpr.green("[BRC] Restored data from backup.")
  return true
end

}
############################### End lua/core/data.lua ###############################
##########################################################################################

################################### Begin lua/core/brc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC (Buehler RC) Core Module
This module serves as the central coordinator for all feature modules
It automatically loads any global module/table that defines `BRC_FEATURE_NAME`
It then manages the feature's lifecycle and hook dispatching
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua
--]]

---- Initialize BRC namespace and non-persistent public variables
BRC = BRC or {}
BRC.VERSION = "1.2.0"
BRC.active = nil

---- Persistent variables ----
brc_config_full = BRC.Data.persist("brc_config_full", nil)
brc_config_name = BRC.Data.persist("brc_config_name", nil)

---- Local constants ----
local HOOK_FUNCTIONS = {
  autopickup = "autopickup",
  c_answer_prompt = "c_answer_prompt",
  c_assign_invletter = "c_assign_invletter",
  c_message = "c_message",
  init = "init",
  ready = "ready",
} -- HOOK_FUNCTIONS (do not remove this comment)

---- Local variables ----
local _features = {}
local _hooks = {}
local turn_count = nil
local depth = nil

---- Local functions ----
local function feature_is_disabled(f)
  return f.Config and f.Config.disabled or BRC.Config[f.BRC_FEATURE_NAME] and BRC.Config[f.BRC_FEATURE_NAME].disabled
end

local function handle_feature_error(feature_name, hook_name, result)
  BRC.log.error(string.format("Failure in %s.%s", feature_name, hook_name), result)
  if BRC.mpr.yesno(string.format("Deactivate %s?", feature_name), BRC.COLOR.yellow) then
    BRC.unregister(feature_name)
  else
    BRC.mpr.okay()
  end
end

local function handle_core_error(hook_name, result, ...)
  local params = {}
  for i = 1, select("#", ...) do
    local param = select(i, ...)
    if param and param.name and type(param.name) == "function" then
      params[#params + 1] = param.name()
    else
      params[#params + 1] = BRC.util.tostring(param, true)
    end
  end
  local param_str = table.concat(params, ", ")

  BRC.log.error("BRC failure in safe_call_all_hooks(" .. hook_name .. ", " .. param_str .. ")", result)
  if BRC.mpr.yesno("Deactivate BRC." .. hook_name .. "?", BRC.COLOR.yellow) then
    _hooks[hook_name] = nil
    BRC.mpr.brown("Unregistered hook: " .. tostring(hook_name))
  else
    BRC.mpr.okay("Returning nil to " .. hook_name .. ".")
  end
end

-- Config management
local function get_validated_config_name(input_name)
  if type(input_name) ~= "string" then
    BRC.log.warning(string.format("Non-string config name: '%s'", tostring(input_name)))
  else
    local config_name = input_name:lower()
    if config_name == "ask" then
      if you.turns() > 0 and brc_config_name then
        return get_validated_config_name(brc_config_name)
      end
    elseif config_name == "previous" then
      if c_persist.BRC and c_persist.BRC.current_config then
        return get_validated_config_name(c_persist.BRC.current_config)
      else
        BRC.log.warning("No previous config found.")
      end
    else
      for k, _ in pairs(BRC.Profiles) do
        if config_name == k:lower() then return k end
      end
      BRC.log.warning(string.format("Could not load config: '%s'", tostring(input_name)))
    end
  end

  return BRC.mpr.select("Select a config", util.keys(BRC.Profiles))
end

local function safe_call_string(str, module_name)
  local chunk, err = loadstring(str)
  if not chunk then
    BRC.log.error("Error loading " .. module_name .. ".Config.init string: ", err)
  else
    local success, result = pcall(chunk)
    if not success then
      BRC.log.error("Error executing " .. module_name .. ".Config.init string: ", result)
    end
  end
end

local function override_feature_config_table(source, dest)
  for key, value in pairs(source) do
    if BRC.is.map(value) then
      if not dest[key] then dest[key] = {} end
      override_feature_config_table(value, dest[key])
    elseif key ~= "init" then
      dest[key] = value
    end
  end
end

local function override_feature_config(feature_name)
  if not _features[feature_name].Config then _features[feature_name].Config = {} end
  if type(_features[feature_name].Config.init) == "function" then
    _features[feature_name].Config.init()
  elseif type(_features[feature_name].Config.init) == "string" then
    safe_call_string(_features[feature_name].Config.init, feature_name)
  end

  if not BRC.Config[feature_name] then return end
  override_feature_config_table(BRC.Config[feature_name], _features[feature_name].Config)
end

-- Hook management
local function call_all_hooks(hook_name, ...)
  local last_return_value = nil
  local returning_feature = nil

  for i = #_hooks[hook_name], 1, -1 do
    local hook_info = _hooks[hook_name][i]
    if not feature_is_disabled(_features[hook_info.feature_name]) then
      if hook_name == HOOK_FUNCTIONS.init then
        BRC.log.debug(string.format("Initialize %s...", BRC.text.lightcyan(hook_info.feature_name)))
      end
      local success, result = pcall(hook_info.func, ...)
      if not success then
        handle_feature_error(hook_info.feature_name, hook_name, result)
      else
        if last_return_value and result and last_return_value ~= result then
          BRC.log.warning(string.format("Return value mismatch in %s:\n  (first) %s -> %s\n  (final) %s -> %s",
              hook_name,
              returning_feature,
              BRC.util.tostring(last_return_value, true),
              hook_info.feature_name,
              BRC.util.tostring(result, true)
          ))
        end

        last_return_value = result
        returning_feature = hook_info.feature_name
      end
    end
  end

  return last_return_value
end

-- safe_call_all_hooks() - Errors in this function won't show up in crawl, so it's kept simple and safe.
-- Errors in call_all_hooks() or handle_core_error() are caught by this function.
local function safe_call_all_hooks(hook_name, ...)
  if not (_hooks and _hooks[hook_name] and #_hooks[hook_name] > 0) then return end

  local success, result = pcall(call_all_hooks, hook_name, ...)
  if success then return result end

  success, result = pcall(handle_core_error, hook_name, result, ...)
  if success then return end

  -- This is a serious error. Failed in the hook, and when we tried to report it.
  BRC.log.error("Failed to report BRC core error!", result)
  if BRC.mpr.yesno("Dump char and deactivate BRC?", BRC.COLOR.yellow) then
    BRC.active = false
    BRC.mpr.brown("BRC deactivated.", "Error in hook: " .. tostring(hook_name))
    pcall(BRC.dump.char, true)
  else
    BRC.mpr.okay()
  end
end

local function register_all_features()
  local loaded_count = 0

  -- Scan for feature modules and load them
  for name, value in pairs(_G) do
    if BRC.is_feature_module(value) then
      local success = BRC.register(value)
      if success then
        loaded_count = loaded_count + 1
      elseif success == false then
        BRC.log.error(string.format("Failed to register feature: %s. Aborting bulk registration.", name))
        return loaded_count
      end
    end
  end

  return loaded_count
end

---- Public API ----
function BRC.get_registered_features()
  return _features
end

function BRC.is_feature_module(f)
  return f
    and type(f) == "table"
    and f.BRC_FEATURE_NAME
    and type(f.BRC_FEATURE_NAME) == "string"
    and #f.BRC_FEATURE_NAME > 0
end

-- BRC.register(): Return true if success, false if error, nil if feature is disabled
function BRC.register(f)
  if not BRC.is_feature_module(f) then
    BRC.log.error("Tried to register a non-feature module! Module contents:")
    BRC.dump.var(f)
    return false
  elseif _features[f.BRC_FEATURE_NAME] then
    BRC.log.warning("Repeat registration of " .. f.BRC_FEATURE_NAME .. "! Will redo registration...")
    BRC.unregister(f.BRC_FEATURE_NAME)
  end

  if feature_is_disabled(f) then
    BRC.log.debug(string.format("%s is disabled. Skipped registration.", BRC.text.lightcyan(f.BRC_FEATURE_NAME)))
    return nil
  else
    if not BRC.Config[f.BRC_FEATURE_NAME] then BRC.Config[f.BRC_FEATURE_NAME] = {} end
    if not f.Config then f.Config = {} end
    f.Config.disabled = false
  end

  BRC.log.debug(string.format("Registering %s...", BRC.text.lightcyan(f.BRC_FEATURE_NAME)))
  _features[f.BRC_FEATURE_NAME] = f

  -- Register hooks
  for _, hook_name in pairs(HOOK_FUNCTIONS) do
    if f[hook_name] then
      if not _hooks[hook_name] then _hooks[hook_name] = {} end
      table.insert(_hooks[hook_name], {
        feature_name = f.BRC_FEATURE_NAME,
        hook_name = hook_name,
        func = f[hook_name],
      })
    end
  end

  -- Handle config init() and overrides
  if type(f.Config) == "table" and type(f.Config.init) == "function" then
    f.Config.init()
  end
  override_feature_config(f.BRC_FEATURE_NAME)

  return true
end

function BRC.unregister(name)
  if not _features[name] then
    BRC.log.error(string.format("%s is not registered. Cannot unregister.", BRC.text.yellow(name)))
    return false
  end

  _features[name] = nil
  local hooks_removed = {}
  for hook_name, hooks in pairs(_hooks) do
    for i = #hooks, 1, -1 do
      if hooks[i].feature_name == name then
        table.remove(hooks, i)
        hooks_removed[#hooks_removed + 1] = hook_name
      end
    end
  end

  BRC.log.info(string.format("Unregistered %s.", BRC.text.lightcyan(name)))
  BRC.log.debug(string.format("Unregistered hooks: (%s)", table.concat(hooks_removed, ", ")))
  return true
end

function BRC.init()
  _features = {}
  _hooks = {}
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end

  BRC.log.debug("Load config...")
  local config_name
  if BRC.config_memory and BRC.config_memory:lower() == "full" then
    config_name = BRC.load_config(brc_config_full or brc_config_name or BRC.config_to_use)
    brc_config_full = BRC.Config
  elseif BRC.config_memory and BRC.config_memory:lower() == "name" then
    config_name = BRC.load_config(brc_config_name or BRC.config_to_use)
  else
    config_name = BRC.load_config(BRC.config_to_use)
  end
  brc_config_name = config_name

  BRC.log.debug("Register features...")
  BRC.register(BRC.Data) -- Data must be the first feature registered (so it's last to initialize)
  register_all_features()

  BRC.log.debug("Initialize features...")
  safe_call_all_hooks(HOOK_FUNCTIONS.init)
  local suffix = BRC.text.blue(string.format(" (%s features)", #util.keys(_features)))

  BRC.log.debug("Add non-feature hooks...")
  add_autopickup_func(BRC.autopickup)
  BRC.set.macro(BRC.get.command_key("CMD_CHARACTER_DUMP") or "#", "macro_brc_dump_character")

  BRC.log.debug("Verify persistent data reload...")
  local success, failures = BRC.Data.verify_reinit()
  if not success and #failures > 0 then
    if not BRC.Data.try_restore(failures) and BRC.mpr.yesno("Deactivate BRC?" .. suffix, BRC.COLOR.yellow) then
      BRC.active = false
      BRC.mpr.lightred("\nBRC is off.\n")
      return false
    end
  end

  if success then
    BRC.Data.backup() -- Only backup after a clean startup
    local msg = string.format("Successfully initialized BRC v%s!", BRC.VERSION) .. suffix
    if BRC.EMOJI.SUCCESS then msg = string.format("%s %s %s", BRC.EMOJI.SUCCESS, msg, BRC.EMOJI.SUCCESS) end
    BRC.mpr.lightgreen(string.format("\n%s\n", msg))
  else
    local msg = string.format("Initialized BRC v%s with warnings", BRC.VERSION)
    BRC.mpr.magenta(string.format("\n%s\n", msg .. suffix))
  end

  -- We're a go!
  turn_count = -1
  depth = you.depth()
  BRC.active = true
  BRC.ready()
  return true
end

function BRC.load_config(input_config)
  local config_name
  if type(input_config) == "table" then
    BRC.Config = input_config
    config_name = brc_config_name or "Unknown"
  else
    config_name = get_validated_config_name(input_config)
    BRC.Config = util.copy_table(BRC.Profiles.Default)
    for k, v in pairs(BRC.Profiles[config_name]) do
      BRC.Config[k] = v
    end
  end

  -- Do config init() and feature overrides
  if type(BRC.Config.init) == "function" then
    BRC.Config.init()
  elseif type(BRC.Config.init) == "string" then
    safe_call_string(BRC.Config.init, "BRC")
  end
  for name, _ in pairs(_features) do
    override_feature_config(name)
  end

  BRC.log.info(string.format("Using config: %s", BRC.text.lightcyan(config_name)))
  return config_name
end

---- Crawl hooks ----
function BRC.autopickup(it, _)
  return safe_call_all_hooks(HOOK_FUNCTIONS.autopickup, it)
end

function BRC.ready()
  if not BRC.active then return end
  crawl.redraw_screen()

  if you.turns() == turn_count then return end
  turn_count = you.turns()

  if you.depth() ~= depth and not you.have_orb() then
    depth = you.depth()
    BRC.Data.backup()
  end

  safe_call_all_hooks(HOOK_FUNCTIONS.ready)
  BRC.mpr.consume_queue()
end

function BRC.c_message(text, channel)
  if not BRC.active then return end
  safe_call_all_hooks(HOOK_FUNCTIONS.c_message, text, channel)
end

function BRC.c_answer_prompt(prompt)
  if not BRC.active then return end
  if not prompt then return end -- This fires from crawl, e.g. Shop purchase confirmation
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_answer_prompt, prompt)
end

function BRC.c_assign_invletter(it)
  if not BRC.active then return end
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_assign_invletter, it)
end

}
############################### End lua/core/brc.lua ###############################
##########################################################################################
