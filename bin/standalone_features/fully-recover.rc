## Standalone BRC Feature: fully-recover
## Generated from: lua/features/fully-recover.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false
BRC.Config.mpr = BRC.Config.mpr or {}
BRC.Config.mpr.show_debug_messages = false
BRC.Config.mpr.logs_to_stderr = false

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.BAD_DURATIONS = {
    "berserk", "blind", "confused", "corroded", "diminished spells",
    "marked", "magic-sapped", "short of breath", "sign of ruin", "slowed",
    "sluggish", "tree%-form", "vulnerable", "weakened",
} -- BRC.BAD_DURATIONS (do not remove this comment)

BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.KEYS = { ENTER = 13, ESC = 27, ["Cntl-S"] = 20, ["Cntl-E"] = 5 }


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.mpr = BRC.mpr or {}
BRC.opt = BRC.opt or {}
BRC.txt = BRC.txt or {}
BRC.util = BRC.util or {}
BRC.you = BRC.you or {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.mpr module
BRC.mpr.brc_prefix = BRC.txt.darkgrey("[BRC] ")
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, msg_color)
  -- Avoid referencing BRC, to stay robust during startup
  msg_color = msg_color or "lightgrey"
  local msg = BRC.mpr.brc_prefix .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", msg_color, msg, msg_color))
  crawl.flush_prev_message()
end

function BRC.mpr.debug(message, context)
  if BRC.Config.mpr.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Debug) " .. message)
  end
end

function BRC.mpr.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  you.stop_activity()

  if not skip_more then
    crawl.redraw_screen()
    crawl.more()
  end

  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Error) " .. message)
  end
end

-- BRC.opt module
local _claimed_macro_keys = {}

function BRC.opt.macro(key, function_name, overwrite_existing)
  if type(_G[function_name]) ~= "function" then
    BRC.mpr.error("Function %s is not a global function", function_name)
    return
  end

  -- Format msg for debugging and keycode for crawl.setopt()
  local key_str = nil
  if type(key) == "number" then
    -- Try to convert to key name for better debug msg
    for k, v in pairs(BRC.KEYS) do
      if v == key then
        key_str = "<<< " .. k .. " >>"
        break
      end
    end
    -- Format keycode string for crawl.setopt()
    key = "\\{" .. key .. "}"
    if key_str == nil then key_str = "<<< \\" .. key .. " >>" end
  end

  if _claimed_macro_keys[key] and not overwrite_existing then
    BRC.mpr.debug("Macro key %s is already assigned to %s", key_str, _claimed_macro_keys[key])
    return
  end
  _claimed_macro_keys[key] = function_name

  -- The << >> formatting protects against crawl thinking '<' is a tag
  if key_str == nil then key_str = "<<< '" .. key .. "' >>" end

  crawl.setopt(string.format("macros += M %s ===%s", key, function_name))

  BRC.mpr.debug(
    string.format(
      "Assigned macro: %s to key: %s",
      BRC.txt.magenta(function_name .. "()"),
      BRC.txt.lightred(key_str)
    )
  )
end

function BRC.opt.message_mute(pattern, create)
  local op = create and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.opt.runrest_ignore_message(pattern, create)
  local op = create and "+=" or "-="
  crawl.setopt(string.format("runrest_ignore_message %s %s", op, pattern))
end

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end


-- BRC.util module
function BRC.util.cntl(c)
  if c >= '0' and c <= '9' or c >= 'a' and c <= 'z' then
    return string.byte(c) - 96
  elseif c >= 'A' and c <= 'Z' then
    return string.byte(c) - 64
  end

  BRC.mpr.error("Unsupported character sent to BRC.util.cntl: %s", c)
  return nil
end

function BRC.util.do_cmd(cmd)
  local key = BRC.util.get_cmd_key(cmd)
  if key then
    crawl.sendkeys({ key })
    crawl.flush_input()
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.get_cmd_key(cmd)
  local key = crawl.get_command(cmd)
  if not key or key == "NULL" then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  return key:contains("Ctrl") and BRC.util.cntl(char_key) or char_key
end

-- BRC.you module
function BRC.you.by_slimy_wall()
  for x = -1, 1 do
    for y = -1, 1 do
      if view.feature_at(x, y) == "slimy_wall" then return true end
    end
  end
  return false
end

function BRC.you.zero_stat()
  return you.strength() <= 0 or you.dexterity() <= 0 or you.intelligence() <= 0
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: fully-recover
-- @module f_fully_recover
-- Rests until no negative duration statuses. Doesn't stop rest on each status expiration.
-- @todo Can remove when crawl's explore_auto_rest_status setting reaches feature parity.
---------------------------------------------------------------------------------------------------

f_fully_recover = {}


---- Persistent variables ----
fr_bad_durations = BRC.Data.persist("fr_bad_durations", util.copy_table(BRC.BAD_DURATIONS))

---- Local constants ----
local MAX_TURNS_TO_WAIT = 500

---- Local variables ----
local recovery_start_turn
local explore_after_recovery

---- Initialization ----
function f_fully_recover.init()
  recovery_start_turn = 0
  explore_after_recovery = false

  BRC.opt.macro(BRC.util.get_cmd_key("CMD_EXPLORE") or "o", "macro_brc_explore")
  BRC.opt.macro(BRC.util.get_cmd_key("CMD_REST") or "5", "macro_brc_rest")
  BRC.opt.runrest_ignore_message("recovery:.*", true)
  BRC.opt.runrest_ignore_message("duration:.*", true)
  BRC.opt.message_mute("^HP restored", true)
  BRC.opt.message_mute("Magic restored", true)
end

---- Local functions ----
local function abort_fully_recover()
  recovery_start_turn = 0
  explore_after_recovery = false
  you.stop_activity()
end

local function finish_fully_recover()
  local turns = you.turns() - recovery_start_turn
  recovery_start_turn = 0
  BRC.mpr.lightgreen(string.format("Fully recovered (%d turns)", turns))

  you.stop_activity()

  if explore_after_recovery then
    explore_after_recovery = false
    BRC.util.do_cmd("CMD_EXPLORE")
  end
end

local function should_ignore_status(s)
  if s == "corroded" then
    return BRC.you.by_slimy_wall() or you.branch() == "Dis"
  elseif s == "slowed" then
    return BRC.you.zero_stat()
  end
  return false
end

local function fully_recovered()
  if you.contamination() > 0 then return false end
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  if hp ~= mhp then return false end
  if mp ~= mmp then return false end

  local status = you.status()
  for _, s in ipairs(BRC.BAD_DURATIONS) do
    if status:find(s) and not should_ignore_status(s) then return false end
  end

  return true
end

local function start_fully_recover(cmd)
  if BRC.active == false or f_fully_recover.Config.disabled or not you.feel_safe() then
    return BRC.util.do_cmd(cmd)
  end

  if fully_recovered() then
    if recovery_start_turn > 0 then
      finish_fully_recover()
    else
      BRC.util.do_cmd(cmd)
    end
  else
    if not you.feel_safe() then
      BRC.mpr.lightred("A monster is nearby!")
    else
      explore_after_recovery = cmd == "CMD_EXPLORE"
      recovery_start_turn = you.turns()
      BRC.util.do_cmd("CMD_WAIT")
    end
  end
end

local function remove_statuses_from_list()
  local status = you.status()
  local to_remove = {}
  for _, s in ipairs(fr_bad_durations) do
    if status:find(s) then table.insert(to_remove, s) end
  end
  for _, s in ipairs(to_remove) do
    util.remove(fr_bad_durations, s)
    BRC.mpr.error("  Removed: " .. s)
  end
end

---- Macro function: Attach full recovery to auto-explore ----
function macro_brc_explore()
  start_fully_recover("CMD_EXPLORE")
end

---- Macro function: Attach full recovery to auto-rest ----
function macro_brc_rest()
  start_fully_recover("CMD_REST")
end

---- Crawl hook functions ----
function f_fully_recover.c_message(_, channel)
  if recovery_start_turn <= 0 then return end
  if fully_recovered() then
    finish_fully_recover()
  elseif channel ~= "duration" and channel ~= "recovery" then
    abort_fully_recover()
  end
end

function f_fully_recover.ready()
  if recovery_start_turn <= 0 then
    explore_after_recovery = false
    return
  end

  if fully_recovered() then
    finish_fully_recover()
  elseif not you.feel_safe() then
    abort_fully_recover()
  elseif you.turns() - recovery_start_turn > MAX_TURNS_TO_WAIT then
    BRC.mpr.error("fully-recover timed out after " .. MAX_TURNS_TO_WAIT .. " turns.", true)
    BRC.mpr.error("fr_bad_durations:")
    remove_statuses_from_list()
    abort_fully_recover()
  else
    BRC.util.do_cmd("CMD_SAFE_WAIT")
  end
end


-- Crawl hook wrappers
function c_message(...)
  return f_fully_recover.c_message(...)
end

local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_fully_recover.ready(...)
  end
end


-- Initialize feature
if f_fully_recover.init then f_fully_recover.init() end
}
