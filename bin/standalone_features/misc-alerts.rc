## Standalone BRC Feature: misc-alerts
## Generated from: lua/features/misc-alerts.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false
BRC.Config.mpr = BRC.Config.mpr or {}
BRC.Config.mpr.show_debug_messages = false
BRC.Config.mpr.logs_to_stderr = false

f_misc_alerts = {}
f_misc_alerts.Config = {
  preferred_god = "", -- Stop on first altar with this text (Ex. "Wu Jian"); nil or "" disables
  force_more_on_pref_altar = true, -- Force more message on first altar for preferred god
  save_with_msg = true, -- Shift-S to save and leave yourself a message
  alert_low_hp_threshold = 35, -- % max HP to alert; 0 to disable
  alert_spell_level_changes = true, -- Alert when you gain additional spell levels
  alert_remove_faith = true, -- Reminder to remove amulet at max piety
  remove_faith_hotkey = true, -- Hotkey remove amulet
} -- f_misc_alerts.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.EMOJI = {}

BRC.KEYS = { ENTER = 13, ESC = 27, ["Cntl-S"] = 20, ["Cntl-E"] = 5, ["Cntl-5"] = 53 }


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.mpr = BRC.mpr or {}
BRC.opt = BRC.opt or {}
BRC.txt = BRC.txt or {}
BRC.util = BRC.util or {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.mpr module
BRC.mpr.brc_prefix = BRC.txt.darkgrey("[BRC] ")
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, msg_color)
  -- Avoid referencing BRC, to stay robust during startup
  msg_color = msg_color or "lightgrey"
  local msg = BRC.mpr.brc_prefix .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", msg_color, msg, msg_color))
  crawl.flush_prev_message()
end

function BRC.mpr.debug(message, context)
  if BRC.Config.mpr.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Debug) " .. message)
  end
end

function BRC.mpr.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  you.stop_activity()

  if not skip_more then
    crawl.redraw_screen()
    crawl.more()
  end

  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Error) " .. message)
  end
end

function BRC.mpr.more(msg, color, channel)
  BRC.mpr[color or BRC.COL.lightgrey](msg, channel)
  you.stop_activity()
  crawl.redraw_screen()
  crawl.more()
end

function BRC.mpr.okay(suffix)
  BRC.mpr.darkgrey("Okay, then." .. (suffix and " " .. suffix or ""))
end

function BRC.mpr.que_optmore(show_more, msg, msg_color, channel)
  for _, q in ipairs(_mpr_queue) do
    if q.m == msg and q.ch == channel and q.more == show_more then return end
  end
  msg_color = msg_color or BRC.COL.lightgrey
  if not msg or #msg == 0 then
    msg = ""
  else
    msg = BRC.txt[msg_color](msg)
  end
  _mpr_queue[#_mpr_queue + 1] = { m = msg, ch = channel, more = show_more }
end

function BRC.mpr.yesno(msg, color, capital_only)
  msg = string.format("%s (%s)", msg, capital_only and "Y/N" or "y/n")

  for i = 1, 10 do
    BRC.mpr[color or BRC.COL.lightgrey](msg, "prompt")
    local res = crawl.getch()
    if res and res >= 0 and res <= 255 then
      local c = string.char(res)
      if c == "Y" or c == "y" and not capital_only then return true end
      if c == "N" or c == "n" and not capital_only then return false end
    end
    if i == 1 and capital_only then msg = "[CAPS ONLY] " .. msg end
  end

  BRC.mpr.lightmagenta("Feels like a no.")
  return false
end

-- BRC.opt module
local _claimed_macro_keys = {}

function BRC.opt.flash_screen_message(pattern, create)
  local op = create and "+=" or "-="
  crawl.setopt(string.format("flash_screen_message %s %s", op, pattern))
end

function BRC.opt.force_more_message(pattern, create)
  local op = create and "+=" or "-="
  crawl.setopt(string.format("force_more_message %s %s", op, pattern))
end

function BRC.opt.macro(key, function_name, overwrite_existing)
  -- Format msg for debugging and keycode for crawl.setopt()
  local key_str = nil
  if type(key) == "number" then
    -- Try to convert to key name for better debug msg
    for k, v in pairs(BRC.KEYS) do
      if v == key then
        key_str = "<<< " .. k .. " >>"
        break
      end
    end
    -- Format keycode string for crawl.setopt()
    key = "\\{" .. key .. "}"
    if key_str == nil then key_str = "<<< \\" .. key .. " >>" end
  end

  -- The << >> formatting protects against crawl thinking '<' is a tag
  if key_str == nil then key_str = "<<< '" .. key .. "' >>" end

  if type(_G[function_name]) == "function" then
    if _claimed_macro_keys[key] and not overwrite_existing then
      BRC.mpr.debug("Macro key %s is already assigned to %s", key_str, _claimed_macro_keys[key])
      return
    end
    crawl.setopt(string.format("macros += M %s ===%s", key, function_name))
    _claimed_macro_keys[key] = function_name
    BRC.mpr.debug(
      string.format(
        "Assigned macro %s to key: %s",
        BRC.txt.magenta(function_name .. "()"),
        BRC.txt.lightred(key_str)
      )
    )
  else
    function_name = _claimed_macro_keys[key]
    if not function_name then
      crawl.mpr("no function name found for key: " .. key)
      return
    end
    crawl.setopt(string.format("macros += M %s %s", key, key))
    _claimed_macro_keys[key] = nil
    BRC.mpr.debug(
      string.format(
        "Cleared macro %s from key: %s",
        BRC.txt.magenta(function_name .. "()"),
        BRC.txt.lightred(key_str)
      )
    )
  end
end

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

function BRC.txt.wrap(text, wrapper, no_space)
  if not wrapper then return text end
  return table.concat({ wrapper, text, wrapper }, no_space and "" or " ")
end

-- BRC.util module
function BRC.util.cntl(c)
  if c >= '0' and c <= '9' or c >= 'a' and c <= 'z' then
    return string.byte(c) - 96
  elseif c >= 'A' and c <= 'Z' then
    return string.byte(c) - 64
  end

  BRC.mpr.error("Unsupported character sent to BRC.util.cntl: %s", c)
  return nil
end

function BRC.util.do_cmd(cmd)
  local key = BRC.util.get_cmd_key(cmd)
  if key then
    crawl.sendkeys({ key })
    crawl.flush_input()
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.get_cmd_key(cmd)
  local key = crawl.get_command(cmd)
  if not key or key == "NULL" then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  return key:contains("Ctrl") and BRC.util.cntl(char_key) or char_key
end

-- mpr queue support: _mpr_queue and BRC.mpr.consume_queue()
_mpr_queue = {}
function BRC.mpr.consume_queue()
  local do_more = util.exists(_mpr_queue, function(q) return q.more end)
  -- stop_activity() can generate more autopickups, and thus more queue'd messages
  if do_more then
    you.stop_activity()
  end

  for _, msg in ipairs(_mpr_queue) do
    if msg.m and #msg.m > 0 then
      crawl.mpr(tostring(msg.m), msg.ch)
      crawl.flush_prev_message()
    end
  end
  _mpr_queue = {}

  if do_more then
    crawl.redraw_screen()
    crawl.more()
  end
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: misc-alerts
-- @module f_misc_alerts
-- @author gammafunk (save game w/ msg), buehler
-- Various single-purpose alerts: save game w/ msg, low HP, faith amulet, spell level changes.
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
ma_alerted_max_piety = BRC.Data.persist("ma_alerted_max_piety", false)
ma_saved_msg = BRC.Data.persist("ma_saved_msg", "")
ma_found_altar = BRC.Data.persist("ma_found_altar", false)

---- Local constants ----
local REMOVE_FAITH_MSG = "6 star piety! Maybe ditch that amulet soon."
local GOD_ALTAR_TEXT = "Found.*altar.*"

---- Local variables ----
local C -- config alias
local below_hp_threshold
local prev_spell_levels
local removed_altar_alert

---- Initialization ----
function f_misc_alerts.init()
  C = f_misc_alerts.Config
  below_hp_threshold = false
  prev_spell_levels = you.spell_levels()
  removed_altar_alert = false

  if C.save_with_msg then
    BRC.opt.macro(BRC.util.get_cmd_key("CMD_SAVE_GAME") or "S", "macro_brc_save")
    if ma_saved_msg and ma_saved_msg ~= "" then
      BRC.mpr.white("MESSAGE: " .. ma_saved_msg)
      ma_saved_msg = nil
    end
  end

  if C.preferred_god and not ma_found_altar then
    if #C.preferred_god == 0 then
      ma_found_altar = true
    else
      GOD_ALTAR_TEXT = GOD_ALTAR_TEXT .. C.preferred_god
      BRC.opt.flash_screen_message(GOD_ALTAR_TEXT, true)
      BRC.opt.force_more_message(GOD_ALTAR_TEXT, C.force_more_on_pref_altar)
    end
  end
end

---- Local functions ----
local function alert_low_hp()
  local hp, mhp = you.hp()
  if below_hp_threshold then
    below_hp_threshold = hp ~= mhp
  elseif hp <= mhp * C.alert_low_hp_threshold / 100 then
    below_hp_threshold = true
    local low_hp_msg = "Dropped below " .. C.alert_low_hp_threshold .. "% HP"
    BRC.mpr.que_optmore(true, BRC.txt.wrap(BRC.txt.magenta(low_hp_msg), BRC.EMOJI.EXCLAMATION))
  end
end

local function alert_remove_faith()
  if not ma_alerted_max_piety and you.piety_rank() == 6 then
    local am = items.equipped_at("amulet")
    if am and am.subtype() == "amulet of faith" and not am.artefact then
      if you.god() == "Uskayaw" then return end
      BRC.mpr.more(REMOVE_FAITH_MSG, BRC.COL.lightcyan)
      ma_alerted_max_piety = true
      if C.remove_faith_hotkey and BRC.Hotkey then
        BRC.Hotkey.set("remove", "amulet of faith", false, function()
          items.equipped_at("amulet"):remove()
        end)
      end
    end
  end
end

local function alert_spell_level_changes()
  local new_spell_levels = you.spell_levels()
  if new_spell_levels > prev_spell_levels then
    local delta = new_spell_levels - prev_spell_levels
    local msg = string.format("Gained %s spell level%s", delta, delta > 1 and "s" or "")
    local suffix = string.format(" (%s available)", new_spell_levels)
    BRC.mpr.lightcyan(msg .. BRC.txt.cyan(suffix))
  elseif new_spell_levels < prev_spell_levels then
    BRC.mpr.magenta(new_spell_levels .. " spell levels remaining")
  end

  prev_spell_levels = new_spell_levels
end

---- Macro function: Save with message feature ----
function macro_brc_save()
  if BRC.active == false
    or f_misc_alerts.Config.disabled
    or not f_misc_alerts.Config.save_with_msg
  then
    return BRC.util.do_cmd("CMD_SAVE_GAME")
  end

  if not BRC.mpr.yesno("Save game and exit?", BRC.COL.lightcyan) then
    BRC.mpr.okay()
    return
  end

  BRC.mpr.white("Leave a message: ", "prompt")
  ma_saved_msg = crawl.c_input_line()
  BRC.util.do_cmd("CMD_SAVE_GAME_NOW")
end

---- Crawl hook functions ----
function f_misc_alerts.c_message(text, _)
  if C.preferred_god and not ma_found_altar and text:find(GOD_ALTAR_TEXT) then
    ma_found_altar = true
    local feature_name = "altar_" .. (C.preferred_god:match("^%S+") or C.preferred_god):lower()
    BRC.Hotkey.move_to_feature("altar of " .. C.preferred_god, true, feature_name)
  end
end

function f_misc_alerts.ready()
  if C.alert_remove_faith then alert_remove_faith() end
  if C.alert_low_hp_threshold > 0 then alert_low_hp() end
  if C.alert_spell_level_changes then alert_spell_level_changes() end
  if ma_found_altar and not removed_altar_alert then
    removed_altar_alert = true
    BRC.opt.flash_screen_message(GOD_ALTAR_TEXT, false)
    BRC.opt.force_more_message(GOD_ALTAR_TEXT, false)
  end
end


-- Crawl hook wrappers
function c_message(...)
  return f_misc_alerts.c_message(...)
end

local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_misc_alerts.ready(...)
  end
  BRC.mpr.consume_queue()
end


-- Initialize feature
if f_misc_alerts.init then f_misc_alerts.init() end
}
