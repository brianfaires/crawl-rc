## BRC Core files - Copy/paste any features above this line.

################################### Begin lua/core/config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Configuration - Various configs, overriding default values in feature configs.
Author: buehler
Dependencies: core/data.lua, core/util/*
Usage:
  - Update BRC.use_config to load the corresponding config.
  - Update each config or create new ones.
  - Undefined values first fall back to Configs.Default, then defaults in feature.Config.
  - `init` (function or multi-line comment of lua) executes after config loads, before overrides.
  - If using config_memory == "full", the function needs to be saved as a string instead. --]]
-- To do this, just replace `function()` and `end` with double square brackets: [[ ... ]]

---- Persistent variables ----
brc_config_full = BRC.Data.persist("brc_config_full", nil)
brc_config_name = BRC.Data.persist("brc_config_name", nil)
-- Default Config Profile (defines default values for everything not in a feature config)

BRC.Profiles.Default = {
  emojis = BRC.Config.emojis, -- Follow the value in _header.lua
  mpr = {
    show_debug_messages = false,
    debug_to_stderr = false,
  },

  dump = {
    max_lines_per_table = 200, -- Avoid huge tables (alert_monsters.Config.Alerts) in debug dumps
    omit_pointers = true, -- Don't dump functions and userdata (they only show a hex address)
  },

  unskilled_egos_usable = false, -- Does "Armour of <MagicSkill>" have an ego when skill is 0?

  --- How weapon damage is calculated for inscriptions+pickup/alert: (factor * DMG + offset)
  BrandBonus = {
    chaos = { factor = 1.15, offset = 2.0 }, -- Approximate weighted average
    distort = { factor = 1.0, offset = 6.0 },
    drain = { factor = 1.25, offset = 2.0 },
    elec = { factor = 1.0, offset = 4.5 },   -- 3.5 on avg; fudged up for AC pen
    flame = { factor = 1.25, offset = 0 },
    freeze = { factor = 1.25, offset = 0 },
    heavy = { factor = 1.8, offset = 0 },    -- Speed is accounted for elsewhere
    pain = { factor = 1.0, offset = you.skill("Necromancy") / 2 },
    spect = { factor = 1.7, offset = 0 },    -- Fudged down for increased incoming damage
    venom = { factor = 1.0, offset = 5.0 },  -- 5 dmg per poisoning

    subtle = { -- Values to use for weapon "scores" (not damage)
      antimagic = { factor = 1.1, offset = 0 },
      holy = { factor = 1.15, offset = 0 },
      penet = { factor = 1.3, offset = 0 },
      protect = { factor = 1.15, offset = 0 },
      reap = { factor = 1.3, offset = 0 },
      vamp = { factor = 1.2, offset = 0 },
    },
  },
} -- BRC.Profiles.Default (do not remove this comment)

---- Local functions ----
local function get_validated_config_name(input_name)
  if type(input_name) ~= "string" then
    BRC.mpr.warning("Non-string config name: " .. tostring(input_name))
  else
    local config_name = input_name:lower()
    if config_name == "ask" then
      if you.turns() > 0 and brc_config_name then
        return get_validated_config_name(brc_config_name)
      end
    elseif config_name == "previous" then
      if c_persist.BRC and c_persist.BRC.current_config then
        return get_validated_config_name(c_persist.BRC.current_config)
      else
        BRC.mpr.warning("No previous config found.")
      end
    else
      for k, _ in pairs(BRC.Profiles) do
        if config_name == k:lower() then return k end
      end
      BRC.mpr.warning("Could not load config: " .. tostring(input_name))
    end
  end

  return BRC.mpr.select("Select a config", util.keys(BRC.Profiles))
end

local function safe_call_string(str, module_name)
  local chunk, err = loadstring(str)
  if not chunk then
    BRC.mpr.error("Error loading " .. module_name .. ".Config.init string: ", err)
  else
    local success, result = pcall(chunk)
    if not success then
      BRC.mpr.error("Error executing " .. module_name .. ".Config.init string: ", result)
    end
  end
end

local function override_table(source, dest)
  if type(source) ~= "table" then return end

  for key, value in pairs(source) do
    if BRC.util.is_map(value) then
      if not dest[key] then dest[key] = {} end
      override_table(value, dest[key])
    elseif key ~= "init" then
      dest[key] = value
    end
  end
end

local function load_profile(input_config)
  local config_name
  if type(input_config) == "table" then
    BRC.Config = input_config
    config_name = brc_config_name or "Unknown"
  else
    config_name = get_validated_config_name(input_config)
    BRC.Config = util.copy_table(BRC.Profiles.Default)
    for k, v in pairs(BRC.Profiles[config_name]) do
      BRC.Config[k] = v
    end
  end

  -- Do config init() and feature overrides
  if type(BRC.Config.init) == "function" then
    BRC.Config.init()
  elseif type(BRC.Config.init) == "string" then
    safe_call_string(BRC.Config.init, "BRC")
  end
  for name, _ in pairs(BRC.get_registered_features()) do
    BRC.process_feature_config(name)
  end

  BRC.mpr.info("Using config: " .. BRC.txt.lightcyan(config_name))
  return config_name
end

---- Public API ----
function BRC.load_config()
  if BRC.store_config and BRC.store_config:lower() == "full" then
    brc_config_name = load_profile(brc_config_full or brc_config_name or BRC.use_config)
    brc_config_full = BRC.Config
  elseif BRC.store_config and BRC.store_config:lower() == "name" then
    brc_config_name = load_profile(brc_config_name or BRC.use_config)
  else
    brc_config_name = load_profile(BRC.use_config)
  end
end

function BRC.process_feature_config(feature_name)
  local f = BRC.get_registered_features()[feature_name]
  if not f.Config then
    f.Config = {}
  elseif type(f.Config.init) == "function" then
    f.Config.init()
  elseif type(f.Config.init) == "string" then
    safe_call_string(f.Config.init, feature_name)
  end

  override_table(BRC.Config[feature_name], f.Config)
end

--- Stringify BRC.Config and all feature configs, including headers
function BRC.serialize_config()
  local tokens = {}
  tokens[#tokens + 1] = BRC.txt.lightcyan("\n---BRC Config---\n")
  tokens[#tokens + 1] = BRC.txt.tostr(BRC.Config, true)

  local all_features = BRC.get_registered_features()
  local keys = util.keys(all_features)
  util.sort(keys)

  for i = 1, #keys do
    local name = keys[i]
    local feature = all_features[name]
    if feature.Config then
      local header = BRC.txt.cyan("\n\n---Feature Config: " .. name .. "---\n")
      tokens[#tokens + 1] = header .. BRC.txt.tostr(feature.Config, true)
    end
  end

  return table.concat(tokens)
end

}
############################### End lua/core/config.lua ###############################
##########################################################################################

################################### Begin lua/core/constants.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Constants - All constant definitions
Author: buehler
Dependencies: BRC.Config.emojis
--]]

---- Cosmetic settings
BRC.EMOJI = {
  CAUTION = BRC.Config.emojis and "⚠️" or "<yellow>!</yellow>",
  EXCLAMATION = BRC.Config.emojis and "❗" or "<magenta>!</magenta>",
  EXCLAMATION_2 = BRC.Config.emojis and "‼️" or "<lightmagenta>!!</lightmagenta>",
  SUCCESS = BRC.Config.emojis and "✅" or nil,
} -- BRC.EMOJI (do not remove this comment)

---- Items ----
BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine",
  "horn of Geryon", "lightning rod", "phantom mirror", "phial of floods", "sack of spiders",
  "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

-- This is checked against the full text of the pickup message, so use patterns to match
BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)

-- Could be removed after https://github.com/crawl/crawl/issues/4606 is addressed
BRC.SPELLBOOKS = {
  "parchment of", "book of", "Necronomicon", "Grand Grimoire", "tome of obsoleteness",
  "Everburning Encyclopedia", "Ozocubu's Autobiography", "Maxwell's Memoranda",
  "Young Poisoner's Handbook", "Fen Folio", "Inescapable Atlas", "There-And-Back Book",
  "Great Wizards, Vol. II", "Great Wizards, Vol. VII", "Trismegistus Codex",
  "the Unrestrained Analects", "Compendium of Siegecraft", "Codex of Conductivity",
  "Handbook of Applied Construction", "Treatise on Traps", "My Sojourn through Swampland",
  "Akashic Record",
  -- Include prefixes for randart books
  "Almanac", "Anthology", "Atlas", "Book", "Catalogue", "Codex", "Compendium",
  "Compilation", "Cyclopedia", "Directory", "Elucidation", "Encyclopedia", "Folio",
  "Grimoire", "Handbook", "Incunable", "Incunabulum", "Octavo", "Omnibus", "Papyrus",
  "Parchment", "Precepts", "Quarto", "Secrets", "Spellbook", "Tome", "Vellum", "Volume",
} -- BRC.SPELLBOOKS (do not remove this comment)

---- Races ----
BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant" }
BRC.NONLIVING_RACES = { "Djinni", "Gargoyle" }
BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant" }
BRC.LITTLE_RACES = { "Spriggan" }
BRC.SMALL_RACES = { "Kobold" }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll" }

---- Skills ----
BRC.MAGIC_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", conjuration = "Conjurations",
  death = "Necromancy", earth = "Earth Magic", fire = "Fire Magic",   necromancy = "Necromancy",
} -- BRC.MAGIC_SCHOOLS (do not remove this comment)

BRC.TRAINING_SKILLS = {
  "Air Magic", "Alchemy", "Armour", "Axes", "Conjurations", "Dodging", "Earth Magic",
  "Evocations", "Fighting", "Fire Magic", "Forgecraft", "Hexes", "Ice Magic",
  "Invocations", "Long Blades", "Maces & Flails", "Necromancy", "Polearms",
  "Ranged Weapons", "Shapeshifting", "Shields", "Short Blades", "Spellcasting", "Staves",
  "Stealth", "Summonings", "Translocations", "Unarmed Combat", "Throwing",
} -- BRC.TRAINING_SKILLS (do not remove this comment)

BRC.WEAP_SCHOOLS = {
  "axes", "maces & flails", "polearms", "long blades", "short blades",
  "staves", "unarmed combat", "ranged weapons",
} -- BRC.WEAP_SCHOOLS (do not remove this comment)

---- Branches ----
BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar" }
BRC.PORTAL_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "Ice Cave", "Necropolis",
  "Ossuary", "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_NAMES (do not remove this comment)

---- Egos + artefact properties ----
BRC.RISKY_EGOS = { "antimagic", "chaos", "distort", "harm", "heavy", "Infuse", "Ponderous" }
BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect" }
BRC.BAD_ART_PROPS = {
  "Bane", "-Cast", "-Move", "-Tele",
  "*Corrode", "*Noise", "*Rage", "*Silence", "*Slow", "*Tele",
} -- BRC.BAD_ART_PROPS (do not remove this comment)

---- Other ----
BRC.KEYS = { ESC = 27 }

BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg for non-elemental brands
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2 }

}
############################### End lua/core/constants.lua ###############################
##########################################################################################

################################### Begin lua/core/data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC.Data - Persistent data management module
Manages persistent data across games and saves
Author: buehler
Dependencies: core/constants.lua, core/util/*
--]]

---- Initialize BRC namespace and Data module
BRC.Data = {}
BRC.Data.BRC_FEATURE_NAME = "data-manager" -- Included as a feature for Config override

---- Local constants ----
local RESTORE_TABLE = "_brc_persist_restore_table"

---- Local variables ----
-- Init tables in declaration, so persist() can be called before init()
local _failures = {}
local _persist_names = {}
local _default_values = {}
local pushed_restore_table_creation
local cur_location

---- Local functions ----
local function is_usable_backup()
  if
    type(c_persist.BRC) ~= "table"
    or type(c_persist.BRC.Backup) ~= "table"
    or c_persist.BRC.Backup.backup_name ~= you.name()
    or c_persist.BRC.Backup.backup_race ~= you.race()
    or c_persist.BRC.Backup.backup_class ~= you.class()
  then
    return false
  end

  local turn_diff = you.turns() - c_persist.BRC.Backup.backup_turn
  if turn_diff == 0 then return true end
  for _ = 1, 5 do
    if BRC.mpr.yesno("Use backup from " .. turn_diff .. " turns ago?") then return true end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return false end
  end
  return true
end

local function try_restore(failed_vars)
  if not is_usable_backup() then
    BRC.mpr.red("[BRC] Unable to restore from backup. Persistent data reset to defaults.")
    BRC.mpr.info("For detailed startup info, set BRC.Config.mpr.show_debug_messages=True.")
    return false
  end

  for _, name in ipairs(failed_vars) do
    _default_values[name] = nil -- Avoid re-init warnings
    _G[name] = BRC.Data.persist(name, c_persist.BRC.Backup[name])
  end
  BRC.mpr.green("[BRC] Restored data from backup.")
  return true
end

---- Public API ----

--- Creates a persistent global variable or table, that retains its value through restarts.
-- Use this pattern to make the global definition obvious: `var = BRC.Data.persist("var", value)`
-- After restarting, the variable/table will not exist until this is called.
-- @param default_value - Variable set to this if it doesn't exist yet
-- @return The current value (whether default or persisted)
function BRC.Data.persist(name, default_value)
  local t = type(default_value)
  if not util.contains({ "table", "string", "number", "boolean", "nil" }, t) then
    BRC.mpr.error(string.format("Cannot persist %s. Default value is of type %s", name, t))
    return default_value
  end

  -- Keep default value for re-init
  if _default_values[name] then
    BRC.mpr.warning("Multiple calls to BRC.Data.persist(" .. name .. ", ...)")
  end
  _default_values[name] = default_value

  -- Try to restore from persistent restore table
  if you.turns() == 0 then
    _G[name] = default_value
  elseif _G[RESTORE_TABLE] and _G[RESTORE_TABLE][name] ~= nil then
    _G[name] = _G[RESTORE_TABLE][name]
    _G[RESTORE_TABLE][name] = nil
  elseif default_value ~= nil and not util.contains(_failures, name) then -- avoid inf loop
    _G[name] = default_value
    _failures[#_failures + 1] = name
    BRC.mpr.debug(BRC.txt.red(name .. " failed to restore from chk_lua_save."))
  end

  -- Create persistent restore table on next startup
  if not pushed_restore_table_creation then
    table.insert(chk_lua_save, function()
      return RESTORE_TABLE .. " = {}\n"
    end)
    pushed_restore_table_creation = true
  end

  -- Set up persist on next startup
  if not util.contains(_persist_names, name) then
    _persist_names[#_persist_names + 1] = name
    table.insert(chk_lua_save, function()
      if _G[name] == nil then return "" end
      return RESTORE_TABLE .. "." .. name .. " = " .. BRC.txt.tostr(_G[name]) .. "\n"
    end)
  end

  return _G[name]
end

function BRC.Data.serialize()
  local tokens = { BRC.txt.lightmagenta("\n---PERSISTENT VARIABLES---\n") }
  local sorted_keys = BRC.util.get_sorted_keys(_persist_names)
  for _, key in ipairs(sorted_keys) do
    tokens[#tokens + 1] = string.format("%s = %s\n", key, BRC.txt.tostr(_G[key], true))
  end
  return table.concat(tokens)
end

function BRC.Data.reset()
  if _persist_names then
    for _, name in ipairs(_persist_names) do
      _G[name] = _default_values[name]
    end
  end

  BRC.mpr.warning("Reset all persistent data to default values.")
end

-- @return true if no persist errors, false if failed restore, nil for user-accepted errors
function BRC.Data.handle_persist_errors()
  if #_failures == 0 then return true end
  local msg = "%s persistent variables did not restore: (%s)"
  BRC.mpr.error(msg:format(#_failures, table.concat(_failures, ", ")), true)

  for _ = 1, 5 do
    if BRC.mpr.yesno("Try restoring from backup?") then break end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return nil end
  end

  -- Whether restore works or not, we should reset _failures
  local failed_vars = _failures
  _failures = {}
  if try_restore(failed_vars) then return nil end
  return false
end

-- Backup and Restore from c_persist.BRC.Backup
function BRC.Data.backup()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
  c_persist.BRC.Backup = {}
  c_persist.BRC.Backup.backup_name = you.name()
  c_persist.BRC.Backup.backup_race = you.race()
  c_persist.BRC.Backup.backup_class = you.class()
  c_persist.BRC.Backup.backup_turn = you.turns()
  for _, name in ipairs(_persist_names) do
    c_persist.BRC.Backup[name] = _G[name]
  end
end

---- Hook functions ----
function BRC.Data.init()
  pushed_restore_table_creation = false
  cur_location = you.where()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
end

function BRC.Data.ready()
  if you.where() ~= cur_location and not you.have_orb() then
    cur_location = you.where()
    BRC.Data.backup()
  end
end

}
############################### End lua/core/data.lua ###############################
##########################################################################################

################################### Begin lua/core/brc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC (Buehler RC) Core Module
This module serves as the central coordinator for all feature modules
It automatically loads any global module/table that defines `BRC_FEATURE_NAME`
It then manages the feature's lifecycle and hook dispatching
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua
--]]

---- Local constants ----
BRC.VERSION = "1.2.0"
local HOOK_FUNCTIONS = {
  autopickup = "autopickup",
  c_answer_prompt = "c_answer_prompt",
  c_assign_invletter = "c_assign_invletter",
  c_message = "c_message",
  init = "init",
  ready = "ready",
} -- HOOK_FUNCTIONS (do not remove this comment)

---- Local variables ----
local _features
local _hooks
local turn_count

---- Local functions ----
local function char_dump(add_debug_info)
  if add_debug_info then
    crawl.take_note(BRC.dump(true, true))
    BRC.mpr.lightgrey("[BRC] Debug info added to character dump.")
  else
    BRC.mpr.darkgrey("[BRC] No debug info added.")
  end

  BRC.util.do_cmd("CMD_CHARACTER_DUMP")
end

local function feature_is_disabled(f)
  return f.Config and f.Config.disabled
    or BRC.Config[f.BRC_FEATURE_NAME] and BRC.Config[f.BRC_FEATURE_NAME].disabled
end

local function handle_feature_error(feature_name, hook_name, result)
  BRC.mpr.error(string.format("Failure in %s.%s", feature_name, hook_name), result, true)
  if BRC.mpr.yesno(string.format("Deactivate %s?", feature_name), BRC.COL.yellow) then
    BRC.unregister(feature_name)
  else
    BRC.mpr.okay()
  end
end

local function handle_core_error(hook_name, result, ...)
  local params = { hook_name }
  for i = 1, select("#", ...) do
    local param = select(i, ...)
    if param and type(param.name) == "function" then
      params[#params + 1] = "[" .. param.name() .. "]"
    else
      params[#params + 1] = BRC.txt.tostr(param, true)
    end
  end

  local msg = "BRC failure in safe_call_all_hooks(" .. table.concat(params, ", ") .. ")"
  BRC.mpr.error(msg, result, true)
  if BRC.mpr.yesno("Deactivate BRC." .. hook_name .. "?", BRC.COL.yellow) then
    _hooks[hook_name] = nil
    BRC.mpr.brown("Unregistered hook: " .. tostring(hook_name))
  else
    BRC.mpr.okay("Returning nil to " .. hook_name .. ".")
  end
end

-- Hook management
local function call_all_hooks(hook_name, ...)
  local last_return_value = nil
  local returning_feature = nil

  for i = #_hooks[hook_name], 1, -1 do
    local hook_info = _hooks[hook_name][i]
    if not feature_is_disabled(_features[hook_info.feature_name]) then
      if hook_name == HOOK_FUNCTIONS.init then
        BRC.mpr.debug(string.format("Initialize %s...", BRC.txt.lightcyan(hook_info.feature_name)))
      end
      local success, result = pcall(hook_info.func, ...)
      if not success then
        handle_feature_error(hook_info.feature_name, hook_name, result)
      else
        if last_return_value and result and last_return_value ~= result then
          BRC.mpr.warning(
            string.format(
              "Return value mismatch in %s:\n  (first) %s -> %s\n  (final) %s -> %s",
              hook_name,
              returning_feature,
              BRC.txt.tostr(last_return_value, true),
              hook_info.feature_name,
              BRC.txt.tostr(result, true)
            )
          )
        end

        last_return_value = result
        returning_feature = hook_info.feature_name
      end
    end
  end

  return last_return_value
end

--- Errors in this function won't show up in crawl, so it's kept simple and safe.
local function safe_call_all_hooks(hook_name, ...)
  if not (_hooks and _hooks[hook_name] and #_hooks[hook_name] > 0) then return end

  local success, result = pcall(call_all_hooks, hook_name, ...)
  if success then return result end

  success, result = pcall(handle_core_error, hook_name, result, ...)
  if success then return end

  -- This is a serious error. Failed in the hook, and when we tried to report it.
  BRC.mpr.error("Failed to handle BRC core error!", result, true)
  if BRC.mpr.yesno("Dump char and deactivate BRC?", BRC.COL.yellow) then
    BRC.active = false
    BRC.mpr.brown("BRC deactivated.", "Error in hook: " .. tostring(hook_name))
    pcall(char_dump, true)
  else
    BRC.mpr.okay()
  end
end

-- Register all features in the global namespace
local function register_all_features()
  -- Find all feature modules
  local feature_names = {}
  for name, value in pairs(_G) do
    if BRC.is_feature_module(value) then feature_names[#feature_names + 1] = name end
  end

  -- Sort alphabetically (for reproducable behavior)
  table.sort(feature_names)

  -- Register features
  local loaded_count = 0
  for _, name in ipairs(feature_names) do
    local success = BRC.register(_G[name])
    if success then
      loaded_count = loaded_count + 1
    elseif success == false then
      BRC.mpr.error("Failed to register feature: " .. name .. ". Aborting bulk registration.")
      return loaded_count
    end
  end

  return loaded_count
end


---- Public API ----
function BRC.get_registered_features()
  return _features
end

function BRC.is_feature_module(f)
  return f
    and type(f) == "table"
    and f.BRC_FEATURE_NAME
    and type(f.BRC_FEATURE_NAME) == "string"
    and #f.BRC_FEATURE_NAME > 0
end

-- BRC.register(): Return true if success, false if error, nil if feature is disabled
function BRC.register(f)
  if not BRC.is_feature_module(f) then
    BRC.mpr.error("Tried to register a non-feature module! Module contents:\n" .. BRC.txt.tostr(f))
    return false
  elseif _features[f.BRC_FEATURE_NAME] then
    BRC.mpr.warning(BRC.txt.lightcyan(f.BRC_FEATURE_NAME) .. " already registered! Repeating...")
    BRC.unregister(f.BRC_FEATURE_NAME)
  end

  if feature_is_disabled(f) then
    BRC.mpr.debug(BRC.txt.lightcyan(f.BRC_FEATURE_NAME) .. " is disabled. Skipped registration.")
    return nil
  else
    if not BRC.Config[f.BRC_FEATURE_NAME] then BRC.Config[f.BRC_FEATURE_NAME] = {} end
    if not f.Config then f.Config = {} end
    f.Config.disabled = false
  end

  BRC.mpr.debug(string.format("Registering %s...", BRC.txt.lightcyan(f.BRC_FEATURE_NAME)))
  _features[f.BRC_FEATURE_NAME] = f

  -- Register hooks
  for _, hook_name in pairs(HOOK_FUNCTIONS) do
    if f[hook_name] then
      if not _hooks[hook_name] then _hooks[hook_name] = {} end
      table.insert(_hooks[hook_name], {
        feature_name = f.BRC_FEATURE_NAME,
        hook_name = hook_name,
        func = f[hook_name],
      })
    end
  end

  BRC.process_feature_config(f.BRC_FEATURE_NAME)

  return true
end

function BRC.unregister(name)
  if not _features[name] then
    BRC.mpr.error(BRC.txt.yellow(name) .. " is not registered. Cannot unregister.")
    return false
  end

  _features[name] = nil
  local hooks_removed = {}
  for hook_name, hooks in pairs(_hooks) do
    for i = #hooks, 1, -1 do
      if hooks[i].feature_name == name then
        table.remove(hooks, i)
        hooks_removed[#hooks_removed + 1] = hook_name
      end
    end
  end

  BRC.mpr.info(string.format("Unregistered %s.", BRC.txt.lightcyan(name)))
  BRC.mpr.debug(string.format("Unregistered hooks: (%s)", table.concat(hooks_removed, ", ")))
  return true
end

function BRC.reset()
  BRC.active = false
  BRC.Data.reset()
  BRC.init()
end

function BRC.init()
  _features = {}
  _hooks = {}
  turn_count = -1

  BRC.load_config()
  BRC.mpr.debug("Config loaded.")

  BRC.mpr.debug("Register features...")
  BRC.register(BRC.Data) -- Data must be the first feature registered
  register_all_features()

  BRC.mpr.debug("Initialize features...")
  safe_call_all_hooks(HOOK_FUNCTIONS.init)
  local suffix = BRC.txt.blue(string.format(" (%s features)", #util.keys(_features)))

  BRC.mpr.debug("Add non-feature hooks...")
  add_autopickup_func(BRC.autopickup)
  BRC.opt.macro(BRC.util.get_cmd_key("CMD_CHARACTER_DUMP") or "#", "macro_brc_dump_character")
  BRC.opt.macro("\\{5}", "macro_brc_cntl_e")

  BRC.mpr.debug("Verify persistent data reload...")
  local success = BRC.Data.handle_persist_errors()
  if success then
    BRC.Data.backup() -- Only backup after a clean startup
    local msg = string.format("Successfully initialized BRC v%s!%s", BRC.VERSION, suffix)
    BRC.mpr.lightgreen("\n" .. BRC.txt.wrap(msg, BRC.EMOJI.SUCCESS) .. "\n")
  else
    -- success == nil if errors were resolved, false if tried restore but failed
    if success == false and BRC.mpr.yesno("Deactivate BRC?" .. suffix, BRC.COL.yellow) then
      BRC.active = false
      BRC.mpr.lightred("\nBRC is off.\n")
      return false
    end
    BRC.mpr.magenta(string.format("\nInitialized BRC v%s with warnings!%s\n", BRC.VERSION, suffix))
  end

  -- We're a go!
  BRC.active = true
  BRC.ready()
  return true
end

--- Pull debug info. Print to mpr() and return as string
-- @param skip_mpr (optional bool) Used in char_dump to just return the string
function BRC.dump(verbose, skip_mpr)
  local tokens = {}
  tokens[#tokens + 1] = BRC.Data.serialize()
  if verbose then
    tokens[#tokens + 1] = BRC.txt.serialize_chk_lua_save()
    tokens[#tokens + 1] = BRC.txt.serialize_inventory()
    tokens[#tokens + 1] = BRC.serialize_config()
  end

  local text = table.concat(tokens, "\n")
  if not skip_mpr then BRC.mpr.white(text) end

  return text
end

---- Macros ----
function macro_brc_dump_character()
  if not BRC.active then BRC.util.do_cmd("CMD_CHARACTER_DUMP") end
  char_dump(BRC.mpr.yesno("Add BRC debug info to character dump?", BRC.COL.lightcyan))
end

--- Go up the closest stairs (Cntl-E)
function macro_brc_cntl_e()
  if you.where() == "D:1" and you.have_orb() then
    crawl.sendkeys({ "X", "<", "\r", BRC.KEYS.ESC, "<" }) -- {ESC, <} handles standing on stairs
  else
    crawl.sendkeys({ BRC.util.cntl("g"), "<" })
  end
end

---- Crawl hooks ----
function BRC.autopickup(it, _)
  return safe_call_all_hooks(HOOK_FUNCTIONS.autopickup, it)
end

function BRC.c_answer_prompt(prompt)
  if not BRC.active then return end
  if not prompt then return end -- This fires from crawl, e.g. Shop purchase confirmation
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_answer_prompt, prompt)
end

function BRC.c_assign_invletter(it)
  if not BRC.active then return end
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_assign_invletter, it)
end

function BRC.c_message(text, channel)
  if not BRC.active then return end
  safe_call_all_hooks(HOOK_FUNCTIONS.c_message, text, channel)
end

function BRC.ready()
  if not BRC.active then return end
  crawl.redraw_screen()
  BRC.clear_single_turn_mutes()

  if you.turns() > turn_count then
    turn_count = you.turns()
    safe_call_all_hooks(HOOK_FUNCTIONS.ready)
  end

  -- Always display messages, even if same turn
  BRC.mpr.consume_queue()
end

}
############################### End lua/core/brc.lua ###############################
##########################################################################################
