## BRC Pickup-alert feature - Copy/paste this file above only_core.rc.

################################### Begin lua/features/pickup-alert/pa-armour.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC feature module: pickup-alert-armour
-- @submodule f_pa_armour
-- @author Medar, gammafunk, buehler
-- Armour pickup and alert functions for the pickup-alert feature.
---------------------------------------------------------------------------------------------------

f_pa_armour = {}

---- Local constants ----
local ENCUMB_ARMOUR_DIVISOR = 2 -- Encumbrance penalty is offset by (Armour / ENCUMB_ARMOUR_DIVISOR)
local SAME = "same_ego"
local LOST = "lost_ego"
local GAIN = "gain_ego"
local NEW = "new_ego"
local DIFF = "diff_ego"
local HEAVIER = "Heavier"
local LIGHTER = "Lighter"

---- Local variables ----
local H -- heuristic tuning alias
local E -- emoji config alias
local A -- alert config alias
local M -- more config alias
local ARMOUR_ALERT

---- Initialization ----
function f_pa_armour.init()
  H = f_pickup_alert.Config.Tuning.Armour
  E = f_pickup_alert.Config.Emoji
  A = f_pickup_alert.Config.Alert
  M = f_pickup_alert.Config.Alert.More

  ARMOUR_ALERT = {
    artefact = { msg = "Artefact armour", emoji = E.ARTEFACT },
    [GAIN] = { msg = "Gain ego", emoji = E.EGO },
    [NEW] = { msg = "New ego", emoji = E.EGO },
    [DIFF] = { msg = "Diff ego", emoji = E.EGO },
    [LIGHTER] = {
      [GAIN] = { msg = "Gain ego (Lighter armour)", emoji = E.EGO },
      [NEW] = { msg = "New ego (Lighter armour)", emoji = E.EGO },
      [DIFF] = { msg = "Diff ego (Lighter armour)", emoji = E.EGO },
      [SAME] = { msg = "Lighter armour", emoji = E.LIGHTER },
      [LOST] = { msg = "Lighter armour (Lost ego)", emoji = E.LIGHTER },
    },
    [HEAVIER] = {
      [GAIN] = { msg = "Gain ego (Heavier armour)", emoji = E.EGO },
      [NEW] = { msg = "New ego (Heavier armour)", emoji = E.EGO },
      [DIFF] = { msg = "Diff ego (Heavier armour)", emoji = E.EGO },
      [SAME] = { msg = "Heavier Armour", emoji = E.HEAVIER },
      [LOST] = { msg = "Heavier Armour (Lost ego)", emoji = E.HEAVIER },
    },
  }
end

---- Local functions ----
local function aux_slot_is_impaired(it)
  local st = it.subtype()
  -- Skip boots/gloves/helmet if wearing Lear's hauberk
  local worn = items.equipped_at("armour")
  if worn and worn.name("qual") == "Lear's hauberk" and st ~= "cloak" then return true end

  -- Mutation interference
  if st == "gloves" then
    return BRC.you.mut_lvl("demonic touch") >= 3 and not BRC.you.free_offhand()
        or BRC.you.mut_lvl("claws") > 0 and not items.equipped_at("weapon")
  elseif st == "boots" then
    return BRC.you.mut_lvl("hooves") > 0
        or BRC.you.mut_lvl("talons") > 0
  elseif it.name("base"):contains("helmet") then
    return BRC.you.mut_lvl("horns") > 0
        or BRC.you.mut_lvl("beak") > 0
        or BRC.you.mut_lvl("antennae") > 0
  end

  return false
end

local function get_adjusted_ev_delta(encumb_delta, ev_delta)
  local encumb_skills = you.skill("Spellcasting")
    + you.skill("Ranged Weapons")
    - you.skill("Armour") / ENCUMB_ARMOUR_DIVISOR
  local encumb_impact = encumb_skills / you.xl()
  encumb_impact = math.max(0, math.min(1, encumb_impact)) -- Clamp to 0-1

  -- Subtract weighted encumbrance penalty, to align with ev_delta (heavier is negative)
  return ev_delta - encumb_delta * encumb_impact * H.encumb_penalty_weight
end

local function get_ego_change_type(cur_ego, it_ego)
  if it_ego == cur_ego then
    return SAME
  elseif not it_ego then
    return LOST
  elseif not cur_ego then
    return GAIN
  elseif not util.contains(pa_egos_alerted, it_ego) then
    return NEW
  else
    return DIFF
  end
end

--- Decides if an ego change is good enough to skip the min_gain check.
--- For DIFF egos (neutral change), true for Shields/Aux, configurable for body armour
local function is_good_ego_change(ego_change, is_body_armour)
  if ego_change == DIFF then return not is_body_armour or H.diff_body_ego_is_good end
  return ego_change == GAIN or ego_change == NEW
end

local function send_armour_alert(it, t_alert)
  return f_pickup_alert.do_alert(it, t_alert.msg, t_alert.emoji, M.body_armour)
end

-- Local functions: Pickup
local function pickup_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end -- surely am naked for a reason

  -- No pickup if wearing an artefact
  if cur.artefact then return false end

  -- No pickup if adding encumbrance or losing AC
  local encumb_delta = it.encumbrance - cur.encumbrance
  if encumb_delta > 0 then return false end
  local ac_delta = BRC.eq.get_ac(it) - BRC.eq.get_ac(cur)
  if ac_delta < 0 then return false end

  -- Pickup: Pure upgrades
  local it_ego = BRC.eq.get_ego(it)
  local cur_ego = BRC.eq.get_ego(cur)
  if it_ego == cur_ego then return (ac_delta > 0 or encumb_delta < 0) end
  return not cur_ego and (ac_delta >= 0 or encumb_delta <= 0)
end

local function pickup_shield(it)
  -- Don't replace these
  local cur = items.equipped_at("offhand")
  if not BRC.it.is_shield(cur) then return false end
  if cur.encumbrance ~= it.encumbrance then return false end
  if cur.artefact then return false end

  -- Pickup: artefact
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_plus = it.plus or 0
  local it_ego = BRC.eq.get_ego(it)
  local cur_ego = BRC.eq.get_ego(cur)
  if it_ego == cur_ego then return it_plus > cur.plus end
  return not cur_ego and it_plus >= cur.plus
end

local function pickup_aux_armour(it)
  -- Pickup: Anything if the slot is empty, unless downside from mutation
  if aux_slot_is_impaired(it) then return false end
  local all_equipped, num_slots = BRC.you.equipped_at(it)
  if #all_equipped < num_slots then
    -- If we're carrying one (implying a blocking mutation), don't pickup another
    if num_slots == 1 then
      local ST = it.subtype()
      return not util.exists(items.inventory(), function(inv) return inv.subtype() == ST end)
    end
    return true
  end

  -- Pickup: artefact, unless slot(s) already full of artefact(s)
  for i, cur in ipairs(all_equipped) do
    if not cur.artefact then break end
    if i == num_slots then return false end
  end
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_ac = BRC.eq.get_ac(it)
  local it_ego = BRC.eq.get_ego(it)
  for _, cur in ipairs(all_equipped) do
    local cur_ac = BRC.eq.get_ac(cur)
    local cur_ego = BRC.eq.get_ego(cur)
    if it_ego == cur_ego then
      if it_ac > cur_ac then return true end
    elseif not cur_ego then
      if it_ac >= cur_ac then return true end
    end
  end
  return false
end

-- Local functions: Alerting
local function should_alert_body_armour(weight, gain, loss, ego_change)
  -- Check if armour stat trade-off meets configured ratio thresholds
  local meets_ratio = loss <= 0
    or (gain / loss > H[weight][ego_change] / A.armour_sensitivity)
  if not meets_ratio then return false end

  -- Additional ego-specific restrictions
  if ego_change == SAME or is_good_ego_change(ego_change, true) then
    return loss <= H[weight].max_loss * A.armour_sensitivity
  else
    return gain >= H[weight].min_gain / A.armour_sensitivity
  end
end

-- Alert when finding higher AC than previously seen, unless training spells/ranged and NOT armour
local function alert_highest_ac(it)
  if you.xl() > 12 then return false end
  local total_skill = you.skill("Spellcasting") + you.skill("Ranged Weapons")
  if total_skill > 0 and you.skill("Armour") == 0 then return false end

  if pa_high_score.ac == 0 then
    local worn = items.equipped_at("armour")
    if not worn then return false end
    pa_high_score.ac = BRC.eq.get_ac(worn)
  else
    local itAC = BRC.eq.get_ac(it)
    if itAC > pa_high_score.ac then
      pa_high_score.ac = itAC
      return f_pickup_alert.do_alert(it, "Highest AC", E.STRONGEST, M.high_score_armour)
    end
  end

  return false
end

local function alert_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end

  -- Always alert artefacts once identified
  if it.artefact then return send_armour_alert(it, ARMOUR_ALERT.artefact) end

  -- Get changes to ego, AC, EV, encumbrance
  local it_ego = BRC.eq.get_ego(it)
  local cur_ego = BRC.eq.get_ego(cur)
  local ego_change = get_ego_change_type(cur_ego, it_ego)
  local ac_delta = BRC.eq.get_ac(it) - BRC.eq.get_ac(cur)
  local ev_delta = BRC.eq.get_armour_ev(it) - BRC.eq.get_armour_ev(cur)
  local encumb_delta = it.encumbrance - cur.encumbrance

  -- Alert new egos if same encumbrance, or small change to total (AC+EV)
  if is_good_ego_change(ego_change, true) then
    if encumb_delta == 0 then return send_armour_alert(it, ARMOUR_ALERT[ego_change]) end

    local weight = encumb_delta < 0 and LIGHTER or HEAVIER
    if math.abs(ac_delta + ev_delta) <= H[weight].ignore_small * A.armour_sensitivity then
      BRC.mpr.debug("small change: AC:" .. ac_delta .. ", EV:" .. ev_delta)
      return send_armour_alert(it, ARMOUR_ALERT[weight][ego_change])
    end
  end

  -- Check if lighter/heavier armour meets stat trade-off thresholds
  if encumb_delta < 0 then
    if should_alert_body_armour(LIGHTER, ev_delta, -ac_delta, ego_change) then
      BRC.mpr.debug("Lighter: AC:" .. ac_delta .. ", EV:" .. ev_delta .. ", " .. ego_change)
      return send_armour_alert(it, ARMOUR_ALERT[LIGHTER][ego_change])
    end
  elseif encumb_delta > 0 then
    local adj_ev_delta = get_adjusted_ev_delta(encumb_delta, ev_delta)
    if should_alert_body_armour(HEAVIER, ac_delta, -adj_ev_delta, ego_change) then
      BRC.mpr.debug("Heavier: AC:" .. ac_delta .. ", EV:" .. ev_delta .. ", " .. ego_change)
      return send_armour_alert(it, ARMOUR_ALERT[HEAVIER][ego_change])
    end
  end

  -- Check for record AC values or early-game ego armour
  if alert_highest_ac(it) then return true end
  if it_ego and you.xl() <= H.early_xl then
    return f_pickup_alert.do_alert(it, "Early armour", E.EGO)
  end
end

local function alert_shield(it)
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact shield", E.ARTEFACT, M.shields)
  end

  -- Don't alert shields if not wearing one (one_time_alerts fire for the first of each type)
  local cur = items.equipped_at("offhand")
  if not BRC.it.is_shield(cur) then return false end

  -- Alert: New ego, Gain SH
  local ego_change = get_ego_change_type(BRC.eq.get_ego(cur), BRC.eq.get_ego(it))
  if is_good_ego_change(ego_change, false) then
    local alert_msg = BRC.txt.capitalize(ego_change):gsub("_", " ")
    return f_pickup_alert.do_alert(it, alert_msg, E.EGO, M.shields)
  elseif BRC.eq.get_sh(it) > BRC.eq.get_sh(cur) then
    return f_pickup_alert.do_alert(it, "Higher SH", E.STRONGER, M.shields)
  end
end

local function alert_aux_armour(it, unworn_inv_item)
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact aux armour", E.ARTEFACT, M.aux_armour)
  end

  local all_equipped, num_slots = BRC.you.equipped_at(it)
  if #all_equipped < num_slots then
    if unworn_inv_item then
      all_equipped[#all_equipped + 1] = unworn_inv_item
    else
      -- Catch dangerous brands or items blocked by non-innate mutations
      return f_pickup_alert.do_alert(it, "Aux armour", BRC.EMOJI.EXCLAMATION, M.aux_armour)
    end
  end

  local it_ego = BRC.eq.get_ego(it)
  for _, cur in ipairs(all_equipped) do
    local ego_change = get_ego_change_type(BRC.eq.get_ego(cur), it_ego)
    if is_good_ego_change(ego_change, false) then
      local alert_msg = BRC.txt.capitalize(ego_change):gsub("_", " ")
      return f_pickup_alert.do_alert(it, alert_msg, E.EGO, M.aux_armour)
    elseif BRC.eq.get_ac(it) > BRC.eq.get_ac(cur) then
      return f_pickup_alert.do_alert(it, "Higher AC", E.STRONGER, M.aux_armour)
    end
  end
end

---- Public API ----
function f_pa_armour.pickup_armour(it)
  if BRC.eq.is_risky(it) then return false end

  if BRC.it.is_body_armour(it) then
    return pickup_body_armour(it)
  elseif BRC.it.is_shield(it) then
    return pickup_shield(it)
  else
    return pickup_aux_armour(it)
  end
end

--- Alerts armour items that didn't auto-pickup but are worth considering.
--- This comes after pickup, so there will be no pure upgrades.
-- @param unworn_inv_item (optional) to compare against an unworn aux armour item in inventory.
function f_pa_armour.alert_armour(it, unworn_inv_item)
  if BRC.it.is_body_armour(it) then
    return alert_body_armour(it)
  elseif BRC.it.is_shield(it) then
    return alert_shield(it)
  else
    return alert_aux_armour(it, unworn_inv_item)
  end
end

}
############################### End lua/features/pickup-alert/pa-armour.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-weapons.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC feature module: pickup-alert-weapons
-- @submodule f_pa_weapons
-- Weapon pickup and alert functions for the pickup-alert feature.
-- _weapon_cache table stores info about inventory weapons, to avoid repeat calculations.
---------------------------------------------------------------------------------------------------

f_pa_weapons = {}

---- Persistent variables ----
pa_lowest_hands_alerted = BRC.Data.persist("pa_lowest_hands_alerted", {
  ["Ranged Weapons"] = 3, -- Track lowest hand count alerted for this weapon school
  ["Polearms"] = 3, -- Track lowest hand count alerted for this weapon school
})

---- Local constants ----
local FIRST_WEAPON_XL_CUTOFF = 6 -- Stop first-weapon alerts after this experience level
local POLEARM_RANGED_CUTOFF = 3 -- Stop polearm alerts when ranged skill reaches this level
local UPGRADE_SKILL_FACTOR = 0.5 -- No upgrade alerts if weapon skill is this % of top skill
-- Weapon cache constants
local RANGED_PREFIX = "range_"
local MELEE_PREFIX = "melee_"
local WEAP_CACHE_KEYS = {
  "melee_1", "melee_1b", "melee_2", "melee_2b", "range_1", "range_1b", "range_2", "range_2b"
}

---- Local variables ----
local C -- config alias
local H -- heuristic tuning alias
local E -- emoji config alias
local A -- alert config alias
local M -- more config alias
local top_attack_skill
local _weapon_cache = {} -- Cache info for inventory weapons to avoid repeat calculations

---- Initialization ----
function f_pa_weapons.init()
  C = f_pickup_alert.Config
  H = f_pickup_alert.Config.Tuning.Weap
  E = f_pickup_alert.Config.Emoji
  A = f_pickup_alert.Config.Alert
  M = f_pickup_alert.Config.Alert.More
  top_attack_skill = BRC.you.top_wpn_skill() or "Unarmed Combat"
  _weapon_cache.refresh(true)

  if not A.first_ranged then pa_lowest_hands_alerted["Ranged Weapons"] = 0 end
  if not A.first_polearm then pa_lowest_hands_alerted["Polearms"] = 0 end
end

---- Local functions ----
local function get_score(it, no_brand_bonus)
  if it.dps and it.acc then
    -- Handle cached /  high-score tuples in _weapon_cache
    return it.dps + it.acc * H.Pickup.accuracy_weight
  end
  local dmg_type = no_brand_bonus and BRC.DMG_TYPE.unbranded or BRC.DMG_TYPE.scoring
  local acc_bonus = (it.accuracy + (it.plus or 0)) * H.Pickup.accuracy_weight
  return BRC.eq.get_dps(it, dmg_type) + acc_bonus
end

local function is_upgradable_weapon(it, cur)
  return cur.is_ranged == it.is_ranged
    and BRC.it.is_polearm(cur) == BRC.it.is_polearm(it)
    and (
      you.race() == "Gnoll"
      or BRC.you.skill(it.weap_skill) >= UPGRADE_SKILL_FACTOR * BRC.you.skill(cur.weap_skill)
    )
end

-- is_weapon_upgrade() -> boolean: compares floor weapon to one in inventory
-- `cur` comes from _weapon_cache - it has some pre-computed values
local function is_weapon_upgrade(it, cur, strict)
  if not cur.allow_upgrade then return false end
  if strict then
    -- Pure upgrades only
    if cur.artefact or it.subtype() ~= cur.subtype() then return false end
    if it.artefact then return true end
    local it_plus = it.plus or 0
    local cur_ego = BRC.eq.get_ego(cur)
    if BRC.eq.get_ego(it) == cur_ego then return it_plus > cur.plus end
    return not cur_ego and it_plus >= cur.plus
  end

  -- Check if it's a very likely upgrade
  if it.subtype() == cur.subtype() then
    if it.artefact then return true end
    if cur.artefact and not A.allow_arte_weap_upgrades then return false end

    local it_ego = BRC.eq.get_ego(it)
    local cur_ego = BRC.eq.get_ego(cur)
    if cur_ego and not it_ego then return false end
    if it_ego and not cur_ego then return get_score(it) / cur.score > H.Pickup.add_ego end
    return it_ego == cur_ego and (it.plus or 0) > cur.plus
  elseif it.weap_skill == cur.weap_skill or you.race() == "Gnoll" then
    if BRC.eq.get_hands(it) > cur.hands then return false end
    if cur.is_ranged ~= it.is_ranged then return false end
    if BRC.it.is_polearm(cur) ~= BRC.it.is_polearm(it) then return false end

    if it.artefact then return true end
    if cur.artefact and not A.allow_arte_weap_upgrades then return false end

    local min_ratio = it.is_ranged and H.Pickup.same_type_ranged or H.Pickup.same_type_melee
    return get_score(it) / cur.score > min_ratio
  end

  return false
end

local function make_alert(it, msg, emoji, fm_option)
  return { it = it, msg = msg, emoji = emoji, fm_option = fm_option }
end

local function need_first_weapon()
  return you.xl() < FIRST_WEAPON_XL_CUTOFF
    and _weapon_cache.is_empty()
    and you.skill("Unarmed Combat") == 0
    and BRC.you.mut_lvl("claws") == 0
end

-- Local functions: Weapon cache
function _weapon_cache.get_primary_key(it)
  local tokens = {}
  tokens[1] = it.is_ranged and RANGED_PREFIX or MELEE_PREFIX
  tokens[2] = tostring(it.hands)
  if BRC.eq.get_ego(it) then tokens[3] = "b" end
  return table.concat(tokens)
end

--- Get all categories this weapon fits into (including more-restrictive categories)
function _weapon_cache.get_keys(is_ranged, hands, is_branded)
  local ranged_types = is_ranged and { RANGED_PREFIX, MELEE_PREFIX } or { MELEE_PREFIX }
  local handed_types = hands == 1 and { "1", "2" } or { "2" }
  local branded_types = is_branded and { "b", "" } or { "" }

  -- Generate all combinations
  local keys = {}
  for _, r in ipairs(ranged_types) do
    for _, h in ipairs(handed_types) do
      for _, b in ipairs(branded_types) do
        keys[#keys + 1] = table.concat({ r, h, b })
      end
    end
  end

  return keys
end

function _weapon_cache.add_weapon(it)
  local weap_data = {}
  weap_data.is_weapon = it.is_weapon
  weap_data.basename = it.name("base")
  weap_data._subtype = it.subtype()
  weap_data.subtype = function() -- For consistency with crawl item.subtype()
    return weap_data._subtype
  end
  weap_data.weap_skill = it.weap_skill
  weap_data.skill_lvl = BRC.you.skill(it.weap_skill)
  weap_data.is_ranged = it.is_ranged
  weap_data.hands = BRC.eq.get_hands(it)
  weap_data.artefact = it.artefact
  weap_data._ego = BRC.eq.get_ego(it)
  weap_data.ego = function() -- For consistency with crawl item.ego()
    return weap_data._ego
  end
  weap_data.plus = it.plus or 0
  weap_data.acc = it.accuracy + weap_data.plus
  weap_data.damage = it.damage
  weap_data.dps = BRC.eq.get_dps(it)
  weap_data.score = get_score(it)
  weap_data.unbranded_score = get_score(it, true)

  -- Check for exclusion tags
  local lower_insc = it.inscription:lower()
  weap_data.allow_upgrade = not (lower_insc:contains("!u") or lower_insc:contains("!brc"))

  -- Track unique egos
  if weap_data._ego and not util.contains(_weapon_cache.egos, weap_data._ego) then
    _weapon_cache.egos[#_weapon_cache.egos + 1] = weap_data._ego
  end

  -- Track max damage for applicable weapon categories
  local keys = _weapon_cache.get_keys(weap_data.is_ranged, weap_data.hands, weap_data._ego ~= nil)

  -- Update the max DPS for each category
  for _, key in ipairs(keys) do
    if weap_data.dps > _weapon_cache.max_dps[key].dps then
      _weapon_cache.max_dps[key].dps = weap_data.dps
      _weapon_cache.max_dps[key].acc = weap_data.acc
    end
  end

  _weapon_cache.weapons[#_weapon_cache.weapons + 1] = weap_data
  return weap_data
end

function _weapon_cache.is_empty()
  return _weapon_cache.max_dps["melee_2"].dps == 0 -- The most restrictive category
end

function _weapon_cache.refresh(skip_turn_check)
  local cur_turn = you.turns()
  if _weapon_cache.turn and _weapon_cache.turn == cur_turn and not skip_turn_check then return end
  _weapon_cache.turn = cur_turn
  _weapon_cache.weapons = {}
  _weapon_cache.egos = {}

  -- Can reuse max_dps table
  if _weapon_cache.max_dps then
    for _, key in ipairs(WEAP_CACHE_KEYS) do
      _weapon_cache.max_dps[key].dps = 0
      _weapon_cache.max_dps[key].acc = 0
    end
  else
    _weapon_cache.max_dps = {}
    for _, key in ipairs(WEAP_CACHE_KEYS) do
      _weapon_cache.max_dps[key] = { dps = 0, acc = 0 }
    end
  end

  for _, inv in ipairs(items.inventory()) do
    if inv.is_weapon and not BRC.it.is_magic_staff(inv) then
      _weapon_cache.add_weapon(inv)
      f_pa_data.update_high_scores(inv)
    end
  end
end

-- Local functions: Alerting
local function get_first_of_skill_alert(it)
  local skill = it.weap_skill
  if not pa_lowest_hands_alerted[skill] then return end

  local hands = BRC.eq.get_hands(it)
  if pa_lowest_hands_alerted[skill] > hands then
    -- Some early checks to skip alerts
    if hands == 2 and BRC.you.have_shield() then return end
    if skill == "Polearms" and you.skill("Ranged Weapons") >= POLEARM_RANGED_CUTOFF then return end

    -- Update lowest # hands alerted, and alert
    pa_lowest_hands_alerted[skill] = hands
    local msg = "First " .. string.sub(skill, 1, -2) .. (hands == 1 and " (1-handed)" or "")
    return make_alert(it, msg, E.WEAPON, M.early_weap)
  end
end

local function get_early_weapon_alert(it)
  -- Alert really good usable ranged weapons
  if it.is_ranged and you.xl() <= H.Alert.EarlyRanged.xl then
    local min_plus = H.Alert.EarlyRanged[BRC.eq.get_ego(it) and "branded_min_plus" or "min_plus"]
    if (it.plus or 0) >= min_plus / A.weapon_sensitivity then
      local low_shield_training = you.skill("Shields") <= H.Alert.EarlyRanged.max_shields
      if BRC.eq.get_hands(it) == 1 or not BRC.you.have_shield() or low_shield_training then
        return make_alert(it, "Ranged weapon", E.RANGED, M.early_weap)
      end
    end
  end

  if you.xl() <= H.Alert.Early.xl then
    -- Ignore items if we're clearly going another route
    local skill_setting = H.Alert.Early.skill
    local skill_diff = BRC.you.skill(top_attack_skill) - BRC.you.skill(it.weap_skill)
    if skill_diff > you.xl() * skill_setting.factor + skill_setting.offset then return false end

    local it_plus = it.plus or 0
    if
      BRC.eq.get_ego(it)
      or it_plus >= H.Alert.Early.branded_min_plus / A.weapon_sensitivity
    then
      return make_alert(it, "Early weapon", E.WEAPON, M.early_weap)
    end
  end

  return false
end

local function get_weap_high_score_alert(it)
  if _weapon_cache.is_empty() then return end -- Skip if not using weapons
  local category = f_pa_data.update_high_scores(it)
  if not category then return end
  return make_alert(it, category, E.WEAPON, M.high_score_weap)
end

-- get_upgrade_alert() subroutines
local function can_use_2h_without_losing_shield()
  return BRC.you.free_offhand() or (you.skill("Shields") < H.Alert.AddHand.ignore_sh_lvl)
end

local function check_upgrade_free_offhand(it, ratio)
  local it_ego = BRC.eq.get_ego(it)
  if it_ego and not util.contains(_weapon_cache.egos, it_ego) and ratio > H.Alert.new_ego then
    return make_alert(it, "New ego (2-handed)", E.EGO, M.weap_ego)
  elseif ratio > H.Alert.AddHand.not_using then
    return make_alert(it, "2-handed weapon", E.TWO_HAND, M.upgrade_weap)
  end
  return false
end

local function check_upgrade_lose_shield(it, cur, ratio)
  if (
      BRC.eq.get_ego(it)
      and not BRC.eq.get_ego(cur)
      and ratio > H.Alert.AddHand.add_ego_lose_sh
    )
  then
    return make_alert(it, "2-handed weapon (Gain ego)", E.TWO_HAND, M.weap_ego)
  end

  return false
end

local function check_upgrade_no_hand_loss(it, cur, ratio)
  if BRC.eq.get_ego(it, true) then -- Don't overvalue Speed/Heavy egos (only consider their DPS)
    local it_ego = BRC.eq.get_ego(it)
    if not BRC.eq.get_ego(cur) then
      if ratio > H.Alert.gain_ego then
        return make_alert(it, "Gain ego", E.EGO, M.weap_ego)
      end
    elseif not util.contains(_weapon_cache.egos, it_ego) and ratio > H.Alert.new_ego then
      return make_alert(it, "New ego", E.EGO, M.weap_ego)
    end
  end

  if ratio > H.Alert.pure_dps then
    return make_alert(it, "DPS increase", E.WEAPON, M.upgrade_weap)
  end

  return false
end

local function check_upgrade_same_subtype(it, cur, best_dps, best_score)
  local it_ego = BRC.eq.get_ego(it, true) -- Don't overvalue speed/heavy (only consider their DPS)
  local cur_ego = BRC.eq.get_ego(cur)
  if it_ego and it_ego ~= cur_ego then
    local change = cur_ego and "Diff ego" or "Gain ego"
    return make_alert(it, change, E.EGO, M.weap_ego)
  end

  local s = A.weapon_sensitivity
  if get_score(it) > best_score / s or BRC.eq.get_dps(it) > best_dps / s then
    return make_alert(it, "Weapon upgrade", E.WEAPON, M.upgrade_weap)
  end
end

--- Check if weapon is worth alerting for, compared against one weapon currently in inventory
-- @param cur (weapon) comes from _weapon_cache - it has some pre-computed values
local function get_upgrade_alert(it, cur, best_dps, best_score)
  -- Ensure the non-strict upgrade is checked, if not already done in pickup_weapon()
  if C.Pickup.weapons_pure_upgrades_only and is_weapon_upgrade(it, cur, false) then
    return make_alert(it, "Weapon upgrade", E.WEAPON, M.upgrade_weap)
  end

  if it.artefact then return make_alert(it, "Artefact weapon", E.ARTEFACT) end
  if cur.artefact and not A.allow_arte_weap_upgrades then return false end
  if not is_upgradable_weapon(it, cur) then return end

  if cur.subtype() ~= it.subtype() then
    return check_upgrade_same_subtype(it, cur, best_dps, best_score)
  end

  -- Get ratio of weap_score / best_score. Penalize lower-trained skills
  local damp = H.Alert.low_skill_penalty_damping
  local penalty = (BRC.you.skill(it.weap_skill) + damp) / (BRC.you.skill(top_attack_skill) + damp)
  local ratio = penalty * get_score(it) / best_score * A.weapon_sensitivity

  if BRC.eq.get_hands(it) <= cur.hands then
    return check_upgrade_no_hand_loss(it, cur, ratio)
  elseif can_use_2h_without_losing_shield() then
    return check_upgrade_free_offhand(it, ratio)
  else
    return check_upgrade_lose_shield(it, cur, ratio)
  end
end

local function get_inventory_upgrade_alert(it)
  -- Once, find the top dps & score for inventory weapons of the same category
  local inv_best = _weapon_cache.max_dps[_weapon_cache.get_primary_key(it)]
  local top_dps = inv_best and inv_best.dps or 0
  local top_score = inv_best and get_score(inv_best) or 0

  -- Compare against all inventory weapons, even from other categories
  for _, inv in ipairs(_weapon_cache.weapons) do
    local best_dps = math.max(inv.dps, top_dps)
    local best_score = math.max(inv.score, top_score)
    local a = get_upgrade_alert(it, inv, best_dps, best_score)
    if a then return a end
  end
end

local function get_weapon_alert(it)
  return get_inventory_upgrade_alert(it)
    or get_first_of_skill_alert(it)
    or get_early_weapon_alert(it)
    or get_weap_high_score_alert(it)
end

---- Public API ----
function f_pa_weapons.pickup_weapon(it)
  _weapon_cache.refresh()
  if need_first_weapon() then
    -- Check if we're carrying a weapon that didn't go into _weapon_cache (like a staff)
    return not util.exists(items.inventory(), function(i) return i.is_weapon end)
  end

  if BRC.eq.is_risky(it) then return false end
  for _, inv in ipairs(_weapon_cache.weapons) do
    if is_weapon_upgrade(it, inv, C.Pickup.weapons_pure_upgrades_only) then
      -- Confirm after updating cache, to avoid spurious alerts from XP gain.
      _weapon_cache.refresh(true)
      if is_weapon_upgrade(it, inv, C.Pickup.weapons_pure_upgrades_only) then return true end
    end
  end
end

function f_pa_weapons.alert_weapon(it)
  _weapon_cache.refresh()
  if get_weapon_alert(it) then
    -- Refresh mid-turn, to avoid spurious alerts from XP gain.
    _weapon_cache.refresh(true)
    local a = get_weapon_alert(it)
    if a then return f_pickup_alert.do_alert(a.it, a.msg, a.emoji, a.fm_option) end
  end
  return false
end

---- Crawl hook functions ----
function f_pa_weapons.ready()
  top_attack_skill = BRC.you.top_wpn_skill() or "Unarmed Combat"
end

}
############################### End lua/features/pickup-alert/pa-weapons.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-misc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC feature module: pickup-alert-misc
-- @submodule f_pa_misc
-- Miscellaneous item pickup and alert functions for the pickup-alert feature.
---------------------------------------------------------------------------------------------------

f_pa_misc = {}

---- Local variables ----
local E -- emoji config alias
local A -- alert config alias
local M -- more config alias

---- Initialization ----
function f_pa_misc.init()
  E = f_pickup_alert.Config.Emoji
  A = f_pickup_alert.Config.Alert
  M = f_pickup_alert.Config.Alert.More
end

---- Local functions ----

---- Public API ----
function f_pa_misc.alert_orb(it)
  return f_pickup_alert.do_alert(it, "New orb", E.ORB, M.orbs)
end

function f_pa_misc.alert_OTA(it)
  local ota_item = f_pa_data.find_OTA(it)
  if not ota_item then return end

  local do_alert = true

  if BRC.it.is_shield(it) then
    if you.skill("Shields") < A.OTA_require_skill.shield then return end

    -- Don't alert if already wearing a larger shield
    if ota_item == "buckler" then
      if BRC.you.have_shield() then do_alert = false end
    elseif ota_item == "kite shield" then
      local sh = items.equipped_at("offhand")
      if sh and sh.name("qual") == "tower shield" then do_alert = false end
    end
  elseif BRC.it.is_armour(it) then
    if you.skill("Armour") < A.OTA_require_skill.armour then return end
  elseif it.is_weapon then
    if you.skill(it.weap_skill) < A.OTA_require_skill.weapon then return end
  end

  f_pa_data.remove_OTA(it)
  if not do_alert then return false end
  return f_pickup_alert.do_alert(it, "Found first", E.RARE_ITEM, M.one_time_alerts)
end

function f_pa_misc.alert_staff(it)
  local basename = it.name("base")
  local tag
  local tag_color

  if basename == "staff of air" then
    if you.res_shock() > 0 then return false end
    tag = "rElec"
    tag_color = BRC.COL.lightcyan
  elseif basename == "staff of alchemy" then
    if you.res_poison() > 0 then return false end
    tag = "rPois"
    tag_color = BRC.COL.lightgreen
  elseif basename == "staff of cold" then
    if you.res_cold() > 0 then return false end
    tag = "rC+"
    tag_color = BRC.COL.lightblue
  elseif basename == "staff of fire" then
    if you.res_fire() > 0 then return false end
    tag = "rF+"
    tag_color = BRC.COL.lightred
  elseif basename == "staff of necromancy" then
    if you.res_draining() > 0 then return false end
    tag = "rN+"
    tag_color = BRC.COL.lightmagenta
  else
    return false
  end

  for _, inv in ipairs(items.inventory()) do
    if inv.is_weapon and inv.name("plain"):contains(tag) then
      return false
    end
  end

  tag = BRC.txt[tag_color]("(" .. tag .. ")")
  return f_pickup_alert.do_alert(it, "Staff resistance " .. tag, E.STAFF_RES, M.staff_resists)
end

function f_pa_misc.alert_talisman(it)
  if not it.is_identified then return false end -- Necessary to avoid firing on '\' menu
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact talisman", E.TALISMAN, M.talismans)
  end
  local required_skill = BRC.it.get_talisman_min_level(it) - A.talisman_lvl_diff
  if required_skill > BRC.you.shapeshifting_skill() then return false end
  return f_pickup_alert.do_alert(it, "New talisman", E.TALISMAN, M.talismans)
end

function f_pa_misc.is_unneeded_ring(it)
  if not BRC.it.is_ring(it) or it.artefact or you.race() == "Octopode" then return false end
  local missing_hand = BRC.you.mut_lvl("missing a hand") > 0
  local st = it.subtype()
  local found_first = false
  for _, inv in ipairs(items.inventory()) do
    if BRC.it.is_ring(inv) and inv.subtype() == st then
      if found_first or missing_hand then return true end
      found_first = true
    end
  end
  return false
end

function f_pa_misc.pickup_staff(it)
  if f_pa_data.already_alerted(it) then return false end
  if BRC.you.skill(BRC.it.get_staff_school(it)) == 0 then return false end

  local qualname = it.name("qual")
  local max_slots = BRC.you.num_eq_slots(it)
  local count = 0
  for _, inv in ipairs(items.inventory()) do
    if inv.name("qual") == qualname then
      count = count + 1
      if count >= max_slots then return false end
    end
  end

  return true
end

}
############################### End lua/features/pickup-alert/pa-misc.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC feature module: pickup-alert-data
-- @submodule f_pa_data
-- Persistent data management and alert tracking for the pickup-alert feature.
---------------------------------------------------------------------------------------------------

f_pa_data = {}

---- Persistent variables ----
pa_items_alerted = BRC.Data.persist("pa_items_alerted", {})
pa_recent_alerts = BRC.Data.persist("pa_recent_alerts", {})
pa_OTA_items = BRC.Data.persist("pa_OTA_items", f_pickup_alert.Config.Alert.one_time)
pa_high_score = BRC.Data.persist("pa_high_score", { ac = 0, weapon = 0, plain_dmg = 0 })
pa_egos_alerted = BRC.Data.persist("pa_egos_alerted", {})

---- Local functions ----
local function get_pa_keys(it, use_plain_name)
  if it.class(true) == "bauble" then
    return it.name("qual"):gsub('"', ""), 0
  elseif BRC.it.is_talisman(it) or BRC.it.is_orb(it) then
    return it.name():gsub('"', ""), 0
  elseif BRC.it.is_magic_staff(it) then
    return it.name("base"):gsub('"', ""), 0
  else
    local name = it.name(use_plain_name and "plain" or "base"):gsub('"', "")
    local value = tonumber(name:sub(1, 3))
    if not value then return name, 0 end
    return util.trim(name:sub(4)), value
  end
end

---- Public API ----
function f_pa_data.already_alerted(it)
  local name, value = get_pa_keys(it)
  if pa_items_alerted[name] ~= nil and tonumber(pa_items_alerted[name]) >= value then
    return name
  end
end

function f_pa_data.remember_alert(it)
  if not (it.is_weapon or BRC.it.is_armour(it, true) or BRC.it.is_talisman(it)) then return end
  local name, value = get_pa_keys(it)
  local cur_val = tonumber(pa_items_alerted[name])
  if not cur_val or value > cur_val then pa_items_alerted[name] = value end

  -- Add lesser versions of same item, to avoid alerting an inferior item
  if BRC.eq.get_ego(it) and not BRC.eq.is_risky(it) and not BRC.it.is_talisman(it) then
    -- Add plain unbranded version
    name = it.name("db")
    cur_val = tonumber(pa_items_alerted[name])
    if not cur_val or value > cur_val then pa_items_alerted[name] = value end

    -- For branded artefact, add the plain branded version
    local verbose_ego = it.ego(false)
    if it.artefact and verbose_ego then
      local branded_name
      if BRC.ADJECTIVE_EGOS[verbose_ego] then
        branded_name = BRC.ADJECTIVE_EGOS[verbose_ego] .. " " .. name
      else
        branded_name = name .. " of " .. verbose_ego
      end
      cur_val = tonumber(pa_items_alerted[name])
      if not cur_val or value > cur_val then pa_items_alerted[branded_name] = value end
    end

    -- Armour may hit multiple egos based on artefact properties. Add each plain branded version.
    if it.artefact and BRC.it.is_armour(it) then
      for k, v in pairs(it.artprops) do
        if v > 0 and BRC.ARTPROPS_EGO[k] then
          local branded_name = name .. " of " .. BRC.ARTPROPS_EGO[k]
          cur_val = tonumber(pa_items_alerted[branded_name])
          if not cur_val or value > cur_val then pa_items_alerted[branded_name] = value end
        end
      end
    end
  end
end

function f_pa_data.forget_alert(it)
  local name, _ = get_pa_keys(it)
  pa_items_alerted[name] = nil
end

function f_pa_data.add_recent_alert(it)
  if it.is_weapon or BRC.it.is_armour(it, true) or BRC.it.is_talisman(it) then
    pa_recent_alerts[#pa_recent_alerts + 1] = f_pa_data.get_keyname(it)
  end
end

function f_pa_data.remove_recent_alert(it)
  util.remove(pa_recent_alerts, f_pa_data.get_keyname(it))
end

function f_pa_data.find_OTA(it)
  local qualname = it.name("qual")
  for _, v in ipairs(pa_OTA_items) do
    if v and qualname:find(v) then return v end
  end
end

function f_pa_data.remove_OTA(it)
  repeat
    local item_name = f_pa_data.find_OTA(it)
    if item_name == nil then return end
    util.remove(pa_OTA_items, item_name)
  until item_name == nil
end

--- Return name with plus included and quotes removed; used as key in tables
function f_pa_data.get_keyname(it, use_plain_name)
  local name, value = get_pa_keys(it, use_plain_name)
  if not (BRC.it.is_armour(it) or it.is_weapon) then return name end
  if value >= 0 then value = string.format("+%s", value) end
  return string.format("%s %s", value, name)
end

--- Return string of the high score type if item sets a new high score, else nil
function f_pa_data.update_high_scores(it)
  if not it then return end
  local ret_val = nil

  if BRC.it.is_armour(it) then
    local ac = BRC.eq.get_ac(it)
    if ac > pa_high_score.ac then
      pa_high_score.ac = ac
      if not ret_val then ret_val = "Highest AC" end
    end
  elseif it.is_weapon then
    -- Don't alert for unusable weapons
    if BRC.eq.get_hands(it) == 2 and not BRC.you.free_offhand() then return end

    local dmg = BRC.eq.get_avg_dmg(it, BRC.DMG_TYPE.branded)
    if dmg > pa_high_score.weapon then
      pa_high_score.weapon = dmg
      if not ret_val then ret_val = "Highest damage" end
    end

    dmg = BRC.eq.get_avg_dmg(it, BRC.DMG_TYPE.plain)
    if dmg > pa_high_score.plain_dmg then
      pa_high_score.plain_dmg = dmg
      if not ret_val then ret_val = "Highest plain damage" end
    end
  end

  return ret_val
end

}
############################### End lua/features/pickup-alert/pa-data.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-main.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC feature module: pickup-alert
-- @module f_pickup_alert
-- Comprehensive pickup and alert system for weapons, armour, and miscellaneous items.
-- Several submodules: pa-config, pa-data, pa-armour, pa-weapons, pa-misc.
---------------------------------------------------------------------------------------------------

f_pickup_alert = f_pickup_alert or {}
f_pickup_alert.BRC_FEATURE_NAME = "pickup-alert"

---- Local variables ----
local C -- config alias
local A -- alert config alias
local M -- more config alias
local pause_pa_system
local hold_alerts_for_next_turn

---- Initialization ----
function f_pickup_alert.init()
  C = f_pickup_alert.Config
  A = f_pickup_alert.Config.Alert
  M = f_pickup_alert.Config.Alert.More
  pause_pa_system = false
  hold_alerts_for_next_turn = false

  BRC.mpr.debug("Initialize pickup-alert submodules...")
  if f_pa_data.init then f_pa_data.init() end
  BRC.mpr.debug("  pa-data loaded")

  if f_pa_armour then
    if f_pa_armour.init then f_pa_armour.init() end
    BRC.mpr.debug("  pa-armour loaded")
  end

  if f_pa_weapons then
    if f_pa_weapons.init then f_pa_weapons.init() end
    BRC.mpr.debug("  pa-weapons loaded")
  end

  if f_pa_misc then
    if f_pa_misc.init then f_pa_misc.init() end
    BRC.mpr.debug("  pa-misc loaded")
  end

  -- Don't alert for starting items
  for _, inv in ipairs(items.inventory()) do
    f_pa_data.remember_alert(inv)
    f_pa_data.remove_OTA(inv)
  end
end

---- Local functions ----
local function do_autopickup(it)
  if options.autopick_on == false
    and A.autopickup_disabled
    and not f_pa_data.already_alerted(it)
  then
    f_pickup_alert.do_alert(it, "Autopickup item", C.Emoji.AUTOPICKUP, M.autopickup_disabled)
  end

  return true
end

local function has_configured_force_more(it)
  if it.artefact then
    if M.artefact then return true end
    if M.trained_artefacts then
      -- Accept artefacts with any relevant training, or no training required
      local s = BRC.you.skill_with(it)
      if s == nil or s > 0 then return true end
    end
  end

  return M.armour_ego and BRC.it.is_armour(it) and BRC.eq.get_ego(it)
end

local function track_unique_egos(it)
  local ego = BRC.eq.get_ego(it)
  if
    ego
    and not util.contains(pa_egos_alerted, ego)
    and not (it.artefact and BRC.eq.is_risky(it))
  then
    pa_egos_alerted[#pa_egos_alerted+1] = ego
  end
end

local function get_alert_color_for_item(it)
  if it.is_weapon then return C.AlertColor.weapon end
  if BRC.it.is_orb(it) then return C.AlertColor.orb end
  if BRC.it.is_talisman(it) then return C.AlertColor.talisman end
  if BRC.it.is_body_armour(it) then return C.AlertColor.body_arm end
  if BRC.it.is_armour(it) then return C.AlertColor.aux_arm end
  return C.AlertColor.misc
end

local function should_skip_pickup_check(it)
  return not BRC.active
    or pause_pa_system
    or you.have_orb()
    or (not it.is_identified and (it.branded or it.artefact or BRC.it.is_magic_staff(it)))
end

local function check_and_trigger_alerts(it, unworn_aux_item)
  if f_pa_data.already_alerted(it) then return true end

  -- One-time alerts
  if f_pa_misc and A.one_time and #A.one_time > 0 then
    if f_pa_misc.alert_OTA(it) then return true end
  end

  -- Item-specific alerts
  if BRC.it.is_magic_staff(it) and f_pa_misc and A.staff_resists then
    if f_pa_misc.alert_staff(it) then return true end
  elseif BRC.it.is_orb(it) and f_pa_misc and A.orbs then
    if f_pa_misc.alert_orb(it) then return true end
  elseif BRC.it.is_talisman(it) and f_pa_misc and A.talismans then
    if f_pa_misc.alert_talisman(it) then return true end
  elseif BRC.it.is_armour(it) and f_pa_armour and A.armour_sensitivity > 0 then
    if f_pa_armour.alert_armour(it, unworn_aux_item) then return true end
  elseif it.is_weapon and f_pa_weapons and A.weapon_sensitivity > 0 then
    if f_pa_weapons.alert_weapon(it) then return true end
  end

  return false
end

---- Public API ----
function f_pickup_alert.pause_alerts()
  hold_alerts_for_next_turn = true
end

function f_pickup_alert.do_alert(it, alert_type, emoji, force_more)
  local item_name = f_pa_data.get_keyname(it, true)
  local alert_col = get_alert_color_for_item(it)

  -- Handle special formatting for weapons and body armour
  if it.is_weapon then
    f_pa_data.update_high_scores(it)
    local weapon_info = string.format(" (%s)", BRC.eq.wpn_stats(it))
    item_name = item_name .. BRC.txt[C.AlertColor.weapon.stats](weapon_info)
  elseif BRC.it.is_armour(it) then
    track_unique_egos(it)
    if BRC.it.is_body_armour(it) then
      f_pa_data.update_high_scores(it)
      local ac, ev = BRC.eq.arm_stats(it)
      local armour_info = string.format(" {%s, %s}", ac, ev)
      item_name = item_name .. BRC.txt[C.AlertColor.body_arm.stats](armour_info)
    end
  end

  local tokens = {}
  tokens[1] = emoji and emoji or BRC.txt.cyan("----")
  tokens[#tokens + 1] = BRC.txt[alert_col.desc](string.format(" %s:", alert_type))
  tokens[#tokens + 1] = BRC.txt[alert_col.item](string.format(" %s ", item_name))
  tokens[#tokens + 1] = tokens[1]
  BRC.mpr.que_optmore(force_more or has_configured_force_more(it), table.concat(tokens))

  f_pa_data.add_recent_alert(it)
  f_pa_data.remember_alert(it)

  if not hold_alerts_for_next_turn then you.stop_activity() end

  -- Set hotkeys
  if util.exists(you.floor_items(), function(fl) return fl.name() == it.name() end) then
    if A.hotkey_pickup then BRC.Hotkey.pickup(it.name(), true) end
  else
    if A.hotkey_travel then BRC.Hotkey.waypoint(it.name()) end
  end

  return true
end

---- Crawl hook functions ----
function f_pickup_alert.autopickup(it, _)
  if should_skip_pickup_check(it) then return end

  local unworn_aux_item = nil -- Track carried aux armour for mutation scenarios
  if it.is_useless then
    -- Allow alerts for useless aux armour, iff you're carrying one (implies a temporary mutation)
    if not BRC.it.is_aux_armour(it) then return end
    local st = it.subtype()
    for _, inv in ipairs(items.inventory()) do
      if inv.subtype() == st then
        unworn_aux_item = inv
        break
      end
    end
    if not unworn_aux_item then return end
  else
    if BRC.it.is_armour(it) then
      if C.Pickup.armour and f_pa_armour.pickup_armour(it) then return do_autopickup(it) end
    elseif BRC.it.is_magic_staff(it) then
      if C.Pickup.staves and f_pa_misc.pickup_staff(it) then return do_autopickup(it) end
    elseif it.is_weapon then
      if C.Pickup.weapons and f_pa_weapons.pickup_weapon(it) then return do_autopickup(it) end
    elseif f_pa_misc and f_pa_misc.is_unneeded_ring(it) then
      return false
    end
  end

  -- Item not picked up - check if it should trigger alerts
  if check_and_trigger_alerts(it, unworn_aux_item) then return end
end

function f_pickup_alert.c_assign_invletter(it)
  f_pa_misc.alert_OTA(it)
  f_pa_data.remove_recent_alert(it)
  f_pa_data.remember_alert(it)

  -- Re-enable the alert, iff we are able to use another one
  if BRC.you.num_eq_slots(it) > 1 then f_pa_data.forget_alert(it) end

  -- Ensure we always stop for these autopickup types
  if it.is_weapon or BRC.it.is_armour(it) then
    f_pa_data.update_high_scores(it)
    you.stop_activity()
  end
end

function f_pickup_alert.c_message(text, channel)
  -- Avoid firing alerts when changing armour/weapons
  if channel == "multiturn" then
    if not pause_pa_system and text:contains("ou start ") then pause_pa_system = true end
  elseif channel == "plain" then
    if pause_pa_system and (text:contains("ou stop ") or text:contains("ou finish ")) then
      pause_pa_system = false
    elseif text:contains("one exploring") or text:contains("artly explored") then
      local tokens = { "Recent alerts:" }
      for _, v in ipairs(pa_recent_alerts) do
        tokens[#tokens + 1] = string.format("\n  %s", v)
      end
      if #tokens > 1 then BRC.mpr.que(table.concat(tokens), BRC.COL.magenta) end
      pa_recent_alerts = {}
    end
  end
end

function f_pickup_alert.ready()
  hold_alerts_for_next_turn = false
  if pause_pa_system then return end
  f_pa_weapons.ready()
  f_pa_data.update_high_scores(items.equipped_at("armour"))
end

}
############################### End lua/features/pickup-alert/pa-main.lua ###############################
##########################################################################################
