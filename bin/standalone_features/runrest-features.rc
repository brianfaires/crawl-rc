## Standalone BRC Feature: runrest-features
## Generated from: lua/features/runrest-features.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false
BRC.Config.mpr = BRC.Config.mpr or {}
BRC.Config.mpr.logs_to_stderr = false

f_runrest_features = {}
f_runrest_features.Config = {
  after_shaft = true, -- stop on stairs after being shafted, until returned to original floor
  ignore_altars = true, -- when you don't need a god
  ignore_portal_exits = true, -- don't stop explore on portal exits
  stop_on_hell_stairs = true, -- stop explore on hell stairs
  stop_on_pan_gates = true, -- stop explore on pan gates
  temple_search = true, -- on entering or exploring temple, auto-search
  gauntlet_search = true, -- on entering or exploring gauntlet, auto-search with filters
  necropolis_search = true, -- on exploring necropolis, auto-search with filters
} -- f_runrest_features.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar" }

BRC.PORTAL_FEATURE_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "IceCv", "Necropolis", "Ossuary",
  "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_FEATURE_NAMES (do not remove this comment)


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.mpr = BRC.mpr or {}
BRC.opt = BRC.opt or {}
BRC.txt = BRC.txt or {}
BRC.util = BRC.util or {}
BRC.you = BRC.you or {}

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

function BRC.txt.clean(text)
  if type(text) ~= "string" then return text end
  return text:gsub("\n", ""):gsub("<[^>]*>", "")
end

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.mpr module
BRC.mpr.brc_prefix = BRC.txt.darkgrey("[BRC] ")
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, msg_color)
  -- Avoid referencing BRC, to stay robust during startup
  msg_color = msg_color or "lightgrey"
  local msg = BRC.mpr.brc_prefix .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", msg_color, msg, msg_color))
  crawl.flush_prev_message()
end

function BRC.mpr.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  -- Stop and clean up state before displaying the error
  BRC.opt.clear_single_turn_mutes()
  crawl.flush_input()
  you.stop_activity()

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  if context then message = message .. " (" .. context .. ")" end
  print(message)

  if not skip_more then
    crawl.redraw_screen()
    crawl.more()
  end

  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Error) " .. message)
  end
end

-- BRC.opt module
local _claimed_macro_keys = {}

function BRC.opt.clear_single_turn_mutes()
  util.foreach(_single_turn_mutes, function(m) BRC.opt.message_mute(m, false) end)
  _single_turn_mutes = {}
end

function BRC.opt.explore_stop(pattern, create)
  local op = create and "+=" or "-="
  crawl.setopt(string.format("explore_stop %s %s", op, pattern))
end

function BRC.opt.message_mute(pattern, create)
  local op = create and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

-- BRC.util module
function BRC.util.cntl(c)
  if c >= '0' and c <= '9' or c >= 'a' and c <= 'z' then
    -- Idk why webtiles numeric keycodes are different than local tiles on Mac
    if crawl.is_webtiles() and c >= '0' and c <= '9' then return string.byte(c) - 64 end
    return string.byte(c) - 96
  elseif c >= 'A' and c <= 'Z' then
    return string.byte(c) - 64
  end

  BRC.mpr.error("Unsupported character sent to BRC.util.cntl: %s", c)
  return nil
end

function BRC.util.get_cmd_key(cmd)
  local key = crawl.get_command(cmd)
  if not key or key == "NULL" then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  return key:contains("Ctrl") and BRC.util.cntl(char_key) or char_key
end

-- BRC.you module
function BRC.you.in_hell(exclude_vestibule)
  local branch = you.branch()
  if exclude_vestibule and branch == "Hell" then return false end
  return util.contains(BRC.HELL_BRANCHES, branch)
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: runrest-features
-- @module f_runrest_features
-- Simple features related to auto-explore stops: altars, gauntlets, portals, stairs, etc.
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
rr_autosearched_temple = BRC.Data.persist("rr_autosearched_temple", false)
rr_shaft_location = BRC.Data.persist("rr_shaft_location", nil)

---- Local constants ----
local CONCAT_STRING = " && !!"
local SEARCH_FILTERS = table.concat({
  "gate leading", "a transporter", "gold piece",
  " trap", "translucent door", "translucent gate"
  }, CONCAT_STRING)
local SEARCH_STRING = {
  Gauntlet = "gauntlet" .. CONCAT_STRING .. SEARCH_FILTERS,
  Necropolis = "necropolis" .. CONCAT_STRING .. SEARCH_FILTERS,
} -- SEARCH_STRING (do not remove this comment)

---- Local variables ----
local C -- config alias
local stop_on_altars
local stop_on_portals
local stop_on_stairs
local autosearched_gauntlet
local autosearched_necropolis

---- Initialization ----
function f_runrest_features.init()
  C = f_runrest_features.Config
  stop_on_altars = true
  stop_on_portals = true
  stop_on_stairs = false
  autosearched_gauntlet = false
  autosearched_necropolis = false

  if you.turns() == 0 and you.class() == "Delver" then rr_shaft_location = "D:1" end
end

---- Local functions ----
local function is_explore_done_msg(text)
  local cleaned = BRC.txt.clean(text)
  return cleaned == "Done exploring."
    or cleaned:find("Partly explored, ", 1, true) == 1
    or cleaned:find("Could not explore, unopened runed ", 1, true) == 1
end

local function set_stairs_stop_state()
  local should_be_active = C.stop_on_pan_gates and you.branch() == "Pan"
    or C.stop_on_hell_stairs and BRC.you.in_hell(true)
    or C.after_shaft and rr_shaft_location ~= nil

  if stop_on_stairs and not should_be_active then
    stop_on_stairs = false
    BRC.opt.explore_stop("stairs", false)
  elseif not stop_on_stairs and should_be_active then
    stop_on_stairs = true
    BRC.opt.explore_stop("stairs", true)
  end
end

-- Altar/Religion functions
local function religion_is_handled()
  if you.race() == "Demigod" then return true end
  if you.god() == "No God" then return false end
  if you.good_god() then return you.xl() > 9 end
  return true
end

local function ready_ignore_altars()
  if stop_on_altars and religion_is_handled() then
    stop_on_altars = false
    BRC.opt.explore_stop("altars", false)
  elseif not stop_on_altars and not religion_is_handled() then
    stop_on_altars = true
    BRC.opt.explore_stop("altars", true)
  end
end

-- Temple functions
local function search_altars()
  local cmd_key = BRC.util.get_cmd_key("CMD_SEARCH_STASHES") or BRC.util.cntl("f")
  crawl.sendkeys({ cmd_key, "altar", "\r" })
  crawl.flush_input()
end

local function ready_temple_search()
  if you.branch() == "Temple" and not rr_autosearched_temple then
    search_altars()
    rr_autosearched_temple = true
  end
end

local function c_message_temple(text, _)
  if you.branch() == "Temple" then
    -- Search again after explore
    if is_explore_done_msg(text) then search_altars() end
  end
end

-- Filtered search functions (Gauntlet & Necropolis)
local function search_filtered(branch)
  local cmd_key = BRC.util.get_cmd_key("CMD_SEARCH_STASHES") or BRC.util.cntl("f")
  crawl.sendkeys({ cmd_key, SEARCH_STRING[branch], "\r" })
  crawl.flush_input()
end

--- Autosearch Gauntlet upon entry
local function ready_gauntlet_search()
  local branch = you.branch()
  if branch == "Gauntlet" and not autosearched_gauntlet then
    search_filtered(branch)
    autosearched_gauntlet = true
  end
end

--- Autosearch Necropolis upon entry
local function ready_necropolis_search()
  local branch = you.branch()
  if branch == "Necropolis" and not autosearched_necropolis then
    search_filtered(branch)
    autosearched_necropolis = true
  end
end

local function c_message_filtered_search(text, _)
  -- Search again after explore
  local branch = you.branch()
  if is_explore_done_msg(text) and (
    C.necropolis_search and branch == "Necropolis"
    or C.gauntlet_search and branch == "Gauntlet"
  ) then
    search_filtered(branch)
  end
end

-- Portal exit functions
local function ready_ignore_portals()
  local in_portal = util.contains(BRC.PORTAL_FEATURE_NAMES, you.branch())
  if stop_on_portals and in_portal then
    stop_on_portals = false
    BRC.opt.explore_stop("portals", false)
  elseif not stop_on_portals and not in_portal then
    stop_on_portals = true
    BRC.opt.explore_stop("portals", true)
  end
end

-- After shaft functions
local function c_message_after_shaft(text, channel)
  if channel ~= "plain" or rr_shaft_location then return end
  if text:find("ou .* into a shaft") and not BRC.you.in_hell(true) then
    rr_shaft_location = you.where()
  end
end

local function ready_after_shaft()
  if you.where() == rr_shaft_location then rr_shaft_location = nil end
end

---- Crawl hook functions ----
function f_runrest_features.c_message(...)
  if C.temple_search then c_message_temple(...) end
  if C.gauntlet_search or C.necropolis_search then c_message_filtered_search(...) end
  if C.after_shaft then c_message_after_shaft(...) end
end

function f_runrest_features.ready()
  if C.ignore_altars then ready_ignore_altars() end
  if C.ignore_portal_exits then ready_ignore_portals() end
  if C.temple_search then ready_temple_search() end
  if C.gauntlet_search then ready_gauntlet_search() end
  if C.necropolis_search then ready_necropolis_search() end
  if C.after_shaft then ready_after_shaft() end
  set_stairs_stop_state()
end


-- Crawl hook wrappers
function c_message(...)
  return f_runrest_features.c_message(...)
end

local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_runrest_features.ready(...)
  end
end


-- Initialize feature
if f_runrest_features.init then f_runrest_features.init() end
}
