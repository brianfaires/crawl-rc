## BRC Pickup-alert feature - Copy/paste this file above only_core.rc.

################################### Begin lua/features/pickup-alert/pa-armour.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-armour
Description: Armour pickup logic and alert system for the pickup-alert system
Author: Original Equipment autopickup by Medar, gammafunk, and various others. Extended by buehler.
Dependencies: core/config.lua, core/constants.lua, core/util.lua,
  pa-config.lua, pa-data.lua, pa-main.lua
--]]

f_pa_armour = {}

---- Local config aliases ----
local Heur = f_pickup_alert.Config.Tuning.Armour
local Emoji = f_pickup_alert.Config.Emoji
local Alert = f_pickup_alert.Config.Alert
local More = f_pickup_alert.Config.Alert.More

---- Local constants / configuration ----
local ENCUMB_ARMOUR_DIVISOR = 2 -- Encumbrance penalty is offset by (Armour / ENCUMB_ARMOUR_DIVISOR)
local SAME = "same_ego"
local LOST = "lost_ego"
local GAIN = "gain_ego"
local NEW = "new_ego"
local DIFF = "diff_ego"
local HEAVIER = "Heavier"
local LIGHTER = "Lighter"

local ARMOUR_ALERT = {
  artefact = { msg = "Artefact armour", emoji = Emoji.ARTEFACT },
  [GAIN] = { msg = "Gain ego", emoji = Emoji.EGO },
  [NEW] = { msg = "New ego", emoji = Emoji.EGO },
  [DIFF] = { msg = "Diff ego", emoji = Emoji.EGO },
  [LIGHTER] = {
    [GAIN] = { msg = "Gain ego (Lighter armour)", emoji = Emoji.EGO },
    [NEW] = { msg = "New ego (Lighter armour)", emoji = Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Lighter armour)", emoji = Emoji.EGO },
    [SAME] = { msg = "Lighter armour", emoji = Emoji.LIGHTER },
    [LOST] = { msg = "Lighter armour (Lost ego)", emoji = Emoji.LIGHTER },
  },
  [HEAVIER] = {
    [GAIN] = { msg = "Gain ego (Heavier armour)", emoji = Emoji.EGO },
    [NEW] = { msg = "New ego (Heavier armour)", emoji = Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Heavier armour)", emoji = Emoji.EGO },
    [SAME] = { msg = "Heavier Armour", emoji = Emoji.HEAVIER },
    [LOST] = { msg = "Heavier Armour (Lost ego)", emoji = Emoji.HEAVIER },
  },
} -- ARMOUR_ALERT (do not remove this comment)

---- Local functions ----
local function aux_slot_is_impaired(it)
  local st = it.subtype()
  -- Skip boots/gloves/helmet if wearing Lear's hauberk
  local worn = items.equipped_at("armour")
  if worn and worn.name("qual") == "Lear's hauberk" and st ~= "cloak" then return true end

  -- Mutation interference
  if st == "gloves" then
    return BRC.get.mut("demonic touch") >= 3 and not BRC.you.free_offhand()
        or BRC.get.mut("claws") > 0 and not items.equipped_at("weapon")
  elseif st == "boots" then
    return BRC.get.mut("hooves") > 0
        or BRC.get.mut("talons") > 0
  elseif it.name("base"):contains("helmet") then
    return BRC.get.mut("horns") > 0
        or BRC.get.mut("beak") > 0
        or BRC.get.mut("antennae") > 0
  end

  return false
end

local function get_adjusted_ev_delta(encumb_delta, ev_delta)
  local encumb_skills = you.skill("Spellcasting")
    + you.skill("Ranged Weapons")
    - you.skill("Armour") / ENCUMB_ARMOUR_DIVISOR
  local encumb_impact = encumb_skills / you.xl()
  encumb_impact = math.max(0, math.min(1, encumb_impact)) -- Clamp to 0-1

  -- Subtract weighted encumbrance penalty, to align with ev_delta (heavier is negative)
  return ev_delta - encumb_delta * encumb_impact * Heur.encumb_penalty_weight
end

local function get_ego_change_type(cur_ego, it_ego)
  if it_ego == cur_ego then
    return SAME
  elseif not it_ego then
    return LOST
  elseif not cur_ego then
    return GAIN
  elseif not util.contains(pa_egos_alerted, it_ego) then
    return NEW
  else
    return DIFF
  end
end

--- Decides if an ego change is good enough to skip the min_gain check.
--- For DIFF egos (neutral change), true for Shields/Aux, configurable for body armour
local function is_good_ego_change(ego_change, is_body_armour)
  if ego_change == DIFF then return not is_body_armour or Heur.diff_body_ego_is_good end
  return ego_change == GAIN or ego_change == NEW
end

local function send_armour_alert(it, t_alert)
  return f_pickup_alert.do_alert(it, t_alert.msg, t_alert.emoji, More.body_armour)
end

-- Local functions: Pickup
local function pickup_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end -- surely am naked for a reason

  -- No pickup if wearing an artefact
  if cur.artefact then return false end

  -- No pickup if adding encumbrance or losing AC
  local encumb_delta = it.encumbrance - cur.encumbrance
  if encumb_delta > 0 then return false end
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  if ac_delta < 0 then return false end

  -- Pickup: Pure upgrades
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if it_ego == cur_ego then return (ac_delta > 0 or encumb_delta < 0) end
  return not cur_ego and (ac_delta >= 0 or encumb_delta <= 0)
end

local function pickup_shield(it)
  -- Don't replace these
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end
  if cur.encumbrance ~= it.encumbrance then return false end
  if cur.artefact then return false end

  -- Pickup: artefact
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_plus = it.plus or 0
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if it_ego == cur_ego then return it_plus > cur.plus end
  return not cur_ego and it_plus >= cur.plus
end

local function pickup_aux_armour(it)
  -- Pickup: Anything if the slot is empty, unless downside from mutation
  if aux_slot_is_impaired(it) then return false end
  local all_equipped, num_slots = BRC.get.equipped_at(it)
  if #all_equipped < num_slots then
    -- If we're carrying one (implying a blocking mutation), don't pickup another
    if num_slots == 1 then
      local ST = it.subtype()
      return not util.exists(items.inventory(), function(inv) return inv.subtype() == ST end)
    end
    return true
  end

  -- Pickup: artefact, unless slot(s) already full of artefact(s)
  for i, cur in ipairs(all_equipped) do
    if not cur.artefact then break end
    if i == num_slots then return false end
  end
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_ac = BRC.get.armour_ac(it)
  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local cur_ac = BRC.get.armour_ac(cur)
    local cur_ego = BRC.get.ego(cur)
    if it_ego == cur_ego then
      if it_ac > cur_ac then return true end
    elseif not cur_ego then
      if it_ac >= cur_ac then return true end
    end
  end
  return false
end

-- Local functions: Alerting
local function should_alert_body_armour(weight, gain, loss, ego_change)
  -- Check if armour stat trade-off meets configured ratio thresholds
  local meets_ratio = loss <= 0
    or (gain / loss > Heur[weight][ego_change] / Alert.armour_sensitivity)
  if not meets_ratio then return false end

  -- Additional ego-specific restrictions
  if ego_change == SAME or is_good_ego_change(ego_change, true) then
    return loss <= Heur[weight].max_loss * Alert.armour_sensitivity
  else
    return gain >= Heur[weight].min_gain / Alert.armour_sensitivity
  end
end

-- Alert when finding higher AC than previously seen, unless training spells/ranged and NOT armour
local function alert_highest_ac(it)
  if you.xl() > 12 then return false end
  local total_skill = you.skill("Spellcasting") + you.skill("Ranged Weapons")
  if total_skill > 0 and you.skill("Armour") == 0 then return false end

  if pa_high_score.ac == 0 then
    local worn = items.equipped_at("armour")
    if not worn then return false end
    pa_high_score.ac = BRC.get.armour_ac(worn)
  else
    local itAC = BRC.get.armour_ac(it)
    if itAC > pa_high_score.ac then
      pa_high_score.ac = itAC
      return f_pickup_alert.do_alert(it, "Highest AC", Emoji.STRONGEST, More.high_score_armour)
    end
  end

  return false
end

local function alert_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end

  -- Always alert artefacts once identified
  if it.artefact then return send_armour_alert(it, ARMOUR_ALERT.artefact) end

  -- Get changes to ego, AC, EV, encumbrance
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  local ego_change = get_ego_change_type(cur_ego, it_ego)
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  local ev_delta = BRC.get.armour_ev(it) - BRC.get.armour_ev(cur)
  local encumb_delta = it.encumbrance - cur.encumbrance

  -- Alert new egos if same encumbrance, or small change to total (AC+EV)
  if is_good_ego_change(ego_change, true) then
    if encumb_delta == 0 then return send_armour_alert(it, ARMOUR_ALERT[ego_change]) end

    local weight = encumb_delta < 0 and LIGHTER or HEAVIER
    if math.abs(ac_delta + ev_delta) <= Heur[weight].ignore_small * Alert.armour_sensitivity then
      BRC.log.debug("small change: AC:" .. ac_delta .. ", EV:" .. ev_delta)
      return send_armour_alert(it, ARMOUR_ALERT[weight][ego_change])
    end
  end

  -- Check if lighter/heavier armour meets stat trade-off thresholds
  if encumb_delta < 0 then
    if should_alert_body_armour(LIGHTER, ev_delta, -ac_delta, ego_change) then
      BRC.log.debug("Lighter: AC:" .. ac_delta .. ", EV:" .. ev_delta .. ", " .. ego_change)
      return send_armour_alert(it, ARMOUR_ALERT[LIGHTER][ego_change])
    end
  elseif encumb_delta > 0 then
    local adj_ev_delta = get_adjusted_ev_delta(encumb_delta, ev_delta)
    if should_alert_body_armour(HEAVIER, ac_delta, -adj_ev_delta, ego_change) then
      BRC.log.debug("Heavier: AC:" .. ac_delta .. ", EV:" .. ev_delta .. ", " .. ego_change)
      return send_armour_alert(it, ARMOUR_ALERT[HEAVIER][ego_change])
    end
  end

  -- Check for record AC values or early-game ego armour
  if alert_highest_ac(it) then return true end
  if it_ego and you.xl() <= Heur.early_xl then
    return f_pickup_alert.do_alert(it, "Early armour", Emoji.EGO)
  end
end

local function alert_shield(it)
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact shield", Emoji.ARTEFACT, More.shields)
  end

  -- Don't alert shields if not wearing one (one_time_alerts fire for the first of each type)
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end

  -- Alert: New ego, Gain SH
  local ego_change = get_ego_change_type(BRC.get.ego(cur), BRC.get.ego(it))
  if is_good_ego_change(ego_change, false) then
    local alert_msg = BRC.text.capitalize(ego_change):gsub("_", " ")
    return f_pickup_alert.do_alert(it, alert_msg, Emoji.EGO, More.shields)
  elseif BRC.get.shield_sh(it) > BRC.get.shield_sh(cur) then
    return f_pickup_alert.do_alert(it, "Higher SH", Emoji.STRONGER, More.shields)
  end
end

local function alert_aux_armour(it, unworn_inv_item)
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact aux armour", Emoji.ARTEFACT, More.aux_armour)
  end

  local all_equipped, num_slots = BRC.get.equipped_at(it)
  if #all_equipped < num_slots then
    if unworn_inv_item then
      all_equipped[#all_equipped + 1] = unworn_inv_item
    else
      -- Catch dangerous brands or items blocked by non-innate mutations
      return f_pickup_alert.do_alert(it, "Aux armour", BRC.EMOJI.EXCLAMATION, More.aux_armour)
    end
  end

  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local ego_change = get_ego_change_type(BRC.get.ego(cur), it_ego)
    if is_good_ego_change(ego_change, false) then
      local alert_msg = BRC.text.capitalize(ego_change):gsub("_", " ")
      return f_pickup_alert.do_alert(it, alert_msg, Emoji.EGO, More.aux_armour)
    elseif BRC.get.armour_ac(it) > BRC.get.armour_ac(cur) then
      return f_pickup_alert.do_alert(it, "Higher AC", Emoji.STRONGER, More.aux_armour)
    end
  end
end

---- Public API ----
function f_pa_armour.pickup_armour(it)
  if BRC.is.risky_item(it) then return false end

  if BRC.is.body_armour(it) then
    return pickup_body_armour(it)
  elseif BRC.is.shield(it) then
    return pickup_shield(it)
  else
    return pickup_aux_armour(it)
  end
end

--- Alerts armour items that didn't auto-pickup but are worth considering.
--- This comes after pickup, so there will be no pure upgrades.
-- @param unworn_inv_item (optional) to compare against an unworn aux armour item in inventory.
function f_pa_armour.alert_armour(it, unworn_inv_item)
  if BRC.is.body_armour(it) then
    return alert_body_armour(it)
  elseif BRC.is.shield(it) then
    return alert_shield(it)
  else
    return alert_aux_armour(it, unworn_inv_item)
  end
end

}
############################### End lua/features/pickup-alert/pa-armour.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-weapons.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-weapons
Description: Weapon pickup logic, caching, and alert system for the pickup-alert system
Author: buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua,
  pa-config.lua, pa-data.lua, pa-main.lua
--]]

f_pa_weapons = {}

---- Persistent variables ----
pa_lowest_hands_alerted = BRC.Data.persist("pa_lowest_hands_alerted", {
  ["Ranged Weapons"] = 3, -- Track lowest hand count alerted for this weapon school
  ["Polearms"] = 3, -- Track lowest hand count alerted for this weapon school
})

---- Local config alias ----
local Config = f_pickup_alert.Config
local Heur = f_pickup_alert.Config.Tuning.Weap
local Emoji = f_pickup_alert.Config.Emoji

---- Local constants ----
local FIRST_WEAPON_XL_CUTOFF = 6 -- Stop first-weapon alerts after this experience level
local POLEARM_RANGED_CUTOFF = 3 -- Stop polearm alerts when ranged skill reaches this level
local UPGRADE_SKILL_FACTOR = 0.5 -- No upgrade alerts if weapon skill is this % of top skill
-- Weapon cache constants
local RANGED_PREFIX = "range_"
local MELEE_PREFIX = "melee_"
local WEAP_CACHE_KEYS = {
  "melee_1", "melee_1b", "melee_2", "melee_2b", "range_1", "range_1b", "range_2", "range_2b"
}

---- Local variables ----
local top_attack_skill
local _weapon_cache = {} -- Cache info for inventory weapons to avoid repeat calculations

---- Local functions ----
local function get_score(it, no_brand_bonus)
  if it.dps and it.acc then
    -- Handle cached /  high-score tuples in _weapon_cache
    return it.dps + it.acc * Heur.Pickup.accuracy_weight
  end
  local dmg_type = no_brand_bonus and BRC.DMG_TYPE.unbranded or BRC.DMG_TYPE.scoring
  local acc_bonus = (it.accuracy + (it.plus or 0)) * Heur.Pickup.accuracy_weight
  return BRC.get.weap_dps(it, dmg_type) + acc_bonus
end

local function is_valid_upgrade(it, cur)
  return cur.is_ranged == it.is_ranged
    and BRC.is.polearm(cur) == BRC.is.polearm(it)
    and (
      you.race() == "Gnoll"
      or BRC.get.skill(it.weap_skill) >= UPGRADE_SKILL_FACTOR * BRC.get.skill(cur.weap_skill)
    )
end

-- is_weapon_upgrade() -> boolean: compares floor weapon to one in inventory
-- `cur` comes from _weapon_cache - it has some pre-computed values
local function is_weapon_upgrade(it, cur, strict)
  if not cur.allow_upgrade then return false end
  if strict then
    -- Pure upgrades only
    if cur.artefact or it.subtype() ~= cur.subtype() then return false end
    if it.artefact then return true end
    local it_plus = it.plus or 0
    local cur_ego = BRC.get.ego(cur)
    if BRC.get.ego(it) == cur_ego then return it_plus > cur.plus end
    return not cur_ego and it_plus >= cur.plus
  end

  -- Check if it's a very likely upgrade
  if it.subtype() == cur.subtype() then
    if it.artefact then return true end
    if cur.artefact then return false end

    local it_ego = BRC.get.ego(it)
    local cur_ego = BRC.get.ego(cur)
    if cur_ego and not it_ego then return false end
    if it_ego and not cur_ego then return get_score(it) / cur.score > Heur.Pickup.add_ego end
    return it_ego == cur_ego and (it.plus or 0) > cur.plus
  elseif it.weap_skill == cur.weap_skill or you.race() == "Gnoll" then
    if BRC.get.hands(it) > cur.hands then return false end
    if cur.is_ranged ~= it.is_ranged then return false end
    if BRC.is.polearm(cur) ~= BRC.is.polearm(it) then return false end

    if it.artefact then return true end
    if cur.artefact then return false end

    local min_ratio = it.is_ranged and Heur.Pickup.same_type_ranged or Heur.Pickup.same_type_melee
    return get_score(it) / cur.score > min_ratio
  end

  return false
end

local function make_alert(it, msg, emoji, fm_option)
  return { it = it, msg = msg, emoji = emoji, fm_option = fm_option }
end

local function need_first_weapon()
  return you.xl() < FIRST_WEAPON_XL_CUTOFF
    and _weapon_cache.is_empty()
    and you.skill("Unarmed Combat") == 0
    and BRC.get.mut("claws") == 0
end

-- Local functions: Weapon cache
function _weapon_cache.get_primary_key(it)
  local tokens = {}
  tokens[1] = it.is_ranged and RANGED_PREFIX or MELEE_PREFIX
  tokens[2] = tostring(it.hands)
  if BRC.get.ego(it) then tokens[3] = "b" end
  return table.concat(tokens)
end

--- Get all categories this weapon fits into (including more-restrictive categories)
function _weapon_cache.get_keys(is_ranged, hands, is_branded)
  local ranged_types = is_ranged and { RANGED_PREFIX, MELEE_PREFIX } or { MELEE_PREFIX }
  local handed_types = hands == 1 and { "1", "2" } or { "2" }
  local branded_types = is_branded and { "b", "" } or { "" }

  -- Generate all combinations
  local keys = {}
  for _, r in ipairs(ranged_types) do
    for _, h in ipairs(handed_types) do
      for _, b in ipairs(branded_types) do
        keys[#keys + 1] = table.concat({ r, h, b })
      end
    end
  end

  return keys
end

function _weapon_cache.add_weapon(it)
  local weap_data = {}
  weap_data.is_weapon = it.is_weapon
  weap_data.basename = it.name("base")
  weap_data._subtype = it.subtype()
  weap_data.subtype = function() -- For consistency with crawl item.subtype()
    return weap_data._subtype
  end
  weap_data.weap_skill = it.weap_skill
  weap_data.skill_lvl = BRC.get.skill(it.weap_skill)
  weap_data.is_ranged = it.is_ranged
  weap_data.hands = BRC.get.hands(it)
  weap_data.artefact = it.artefact
  weap_data._ego = BRC.get.ego(it)
  weap_data.ego = function() -- For consistency with crawl item.ego()
    return weap_data._ego
  end
  weap_data.plus = it.plus or 0
  weap_data.acc = it.accuracy + weap_data.plus
  weap_data.damage = it.damage
  weap_data.dps = BRC.get.weap_dps(it)
  weap_data.score = get_score(it)
  weap_data.unbranded_score = get_score(it, true)

  -- Check for exclusion tags
  local lower_insc = it.inscription:lower()
  weap_data.allow_upgrade = not (lower_insc:contains("!u") or lower_insc:contains("!brc"))

  -- Track unique egos
  if weap_data._ego and not util.contains(_weapon_cache.egos, weap_data._ego) then
    _weapon_cache.egos[#_weapon_cache.egos + 1] = weap_data._ego
  end

  -- Track max damage for applicable weapon categories
  local keys = _weapon_cache.get_keys(weap_data.is_ranged, weap_data.hands, weap_data._ego ~= nil)

  -- Update the max DPS for each category
  for _, key in ipairs(keys) do
    if weap_data.dps > _weapon_cache.max_dps[key].dps then
      _weapon_cache.max_dps[key].dps = weap_data.dps
      _weapon_cache.max_dps[key].acc = weap_data.acc
    end
  end

  _weapon_cache.weapons[#_weapon_cache.weapons + 1] = weap_data
  return weap_data
end

function _weapon_cache.is_empty()
  return _weapon_cache.max_dps["melee_2"].dps == 0 -- The most restrictive category
end

function _weapon_cache.refresh()
  local cur_turn = you.turn()
  if _weapon_cache.turn and _weapon_cache.turn == cur_turn then return end
  _weapon_cache.turn = cur_turn
  _weapon_cache.weapons = {}
  _weapon_cache.egos = {}

  -- Can reuse max_dps table
  if _weapon_cache.max_dps then
    for _, key in ipairs(WEAP_CACHE_KEYS) do
      _weapon_cache.max_dps[key].dps = 0
      _weapon_cache.max_dps[key].acc = 0
    end
  else
    _weapon_cache.max_dps = {}
    for _, key in ipairs(WEAP_CACHE_KEYS) do
      _weapon_cache.max_dps[key] = { dps = 0, acc = 0 }
    end
  end

  for _, inv in ipairs(items.inventory()) do
    if inv.is_weapon and not BRC.is.magic_staff(inv) then
      _weapon_cache.add_weapon(inv)
      f_pa_data.update_high_scores(inv)
    end
  end
end

-- Local functions: Alerting
local function get_first_of_skill_alert(it, silent)
  local skill = it.weap_skill
  if not pa_lowest_hands_alerted[skill] then return end

  local hands = BRC.get.hands(it)
  if pa_lowest_hands_alerted[skill] > hands then
    -- Some early checks to skip alerts
    if hands == 2 and BRC.you.have_shield() then return end
    if skill == "Polearms" and you.skill("Ranged Weapons") >= POLEARM_RANGED_CUTOFF then return end

    -- Update lowest # hands alerted, and alert
    pa_lowest_hands_alerted[skill] = hands
    if silent then return end
    local msg = "First " .. string.sub(skill, 1, -2) .. (hands == 1 and " (1-handed)" or "")
    return make_alert(it, msg, Emoji.WEAPON, Config.Alert.More.early_weap)
  end
end

local function get_early_weapon_alert(it)
  -- Alert really good usable ranged weapons
  if it.is_ranged and you.xl() <= Heur.Alert.EarlyRanged.xl then
    local min_plus = Heur.Alert.EarlyRanged[BRC.get.ego(it) and "branded_min_plus" or "min_plus"]
    if (it.plus or 0) >= min_plus / Config.Alert.weapon_sensitivity then
      local low_shield_training = you.skill("Shields") <= Heur.Alert.EarlyRanged.max_shields
      if BRC.get.hands(it) == 1 or not BRC.you.have_shield() or low_shield_training then
        return make_alert(it, "Ranged weapon", Emoji.RANGED, Config.Alert.More.early_weap)
      end
    end
  end

  if you.xl() <= Heur.Alert.Early.xl then
    -- Ignore items if we're clearly going another route
    local skill_setting = Heur.Alert.Early.skill
    local skill_diff = BRC.get.skill(top_attack_skill) - BRC.get.skill(it.weap_skill)
    if skill_diff > you.xl() * skill_setting.factor + skill_setting.offset then return false end

    local it_plus = it.plus or 0
    if
      BRC.get.ego(it)
      or it_plus >= Heur.Alert.Early.branded_min_plus / Config.Alert.weapon_sensitivity
    then
      return make_alert(it, "Early weapon", Emoji.WEAPON, Config.Alert.More.early_weap)
    end
  end

  return false
end

local function get_weap_high_score_alert(it)
  if _weapon_cache.is_empty() then return end -- Skip if not using weapons
  local category = f_pa_data.update_high_scores(it)
  if not category then return end
  return make_alert(it, category, Emoji.WEAPON, Config.Alert.More.high_score_weap)
end

local function get_upgrade_alert_same_type(it, cur, best_dps, best_score)
  -- Alert: new egos, highest DPS or highest weap_score
  local it_ego = BRC.get.ego(it, true) -- Don't overvalue speed/heavy (only consider their DPS)
  local cur_ego = BRC.get.ego(cur)
  if not cur.artefact and it_ego and it_ego ~= cur_ego then
    local change = cur_ego and "Diff ego" or "Gain ego"
    return make_alert(it, change, Emoji.EGO, Config.Alert.More.weap_ego)
  else
    local s = Config.Alert.weapon_sensitivity
    if get_score(it) > best_score / s or BRC.get.weap_dps(it) > best_dps / s then
      return make_alert(it, "Weapon upgrade", Emoji.WEAPON, Config.Alert.More.upgrade_weap)
    end
  end
end

--- Check if weapon is worth alerting for, compared against one weapon currently in inventory
-- @param cur (weapon) comes from _weapon_cache - it has some pre-computed values
local function get_upgrade_alert(it, cur, best_dps, best_score)
  -- Ensure the non-strict upgrade is checked, if not already done in pickup_weapon()
  if Config.Pickup.weapons_pure_upgrades_only and is_weapon_upgrade(it, cur, false) then
    return make_alert(it, "Weapon upgrade", Emoji.WEAPON, Config.Alert.More.upgrade_weap)
  end

  if it.artefact then return make_alert(it, "Artefact weapon", Emoji.ARTEFACT) end
  if cur.subtype() == it.subtype() then
    return get_upgrade_alert_same_type(it, cur, best_dps, best_score)
  end
  if not is_valid_upgrade(it, cur) then return end

  -- Get ratio of weap_score / best_score. Penalize lower-trained skills
  local damp = Heur.Alert.low_skill_penalty_damping
  local penalty = (BRC.get.skill(it.weap_skill) + damp) / (BRC.get.skill(top_attack_skill) + damp)
  local ratio = penalty * get_score(it) / best_score * Config.Alert.weapon_sensitivity

  if BRC.get.hands(it) <= cur.hands then
    if cur.artefact then return false end
    if BRC.get.ego(it, true) then -- Don't overvalue Speed/Heavy egos (only consider their DPS)
      local it_ego = BRC.get.ego(it)
      if not BRC.get.ego(cur) then
        if ratio > Heur.Alert.gain_ego then
          return make_alert(it, "Gain ego", Emoji.EGO, Config.Alert.More.weap_ego)
        end
      elseif not util.contains(_weapon_cache.egos, it_ego) and ratio > Heur.Alert.new_ego then
        return make_alert(it, "New ego", Emoji.EGO, Config.Alert.More.weap_ego)
      end
    end
    if ratio > Heur.Alert.pure_dps then
      return make_alert(it, "DPS increase", Emoji.WEAPON, Config.Alert.More.upgrade_weap)
    end
  elseif BRC.you.free_offhand() or (you.skill("Shields") < Heur.Alert.AddHand.ignore_sh_lvl) then
    local it_ego = BRC.get.ego(it)
    if it_ego and not util.contains(_weapon_cache.egos, it_ego) and ratio > Heur.Alert.new_ego then
      return make_alert(it, "New ego (2-handed)", Emoji.EGO, Config.Alert.More.weap_ego)
    elseif ratio > Heur.Alert.AddHand.not_using then
      return make_alert(it, "2-handed weapon", Emoji.TWO_HAND, Config.Alert.More.upgrade_weap)
    end
  elseif
    BRC.get.ego(it)
    and not BRC.get.ego(cur)
    and ratio > Heur.Alert.AddHand.add_ego_lose_sh
  then
    return make_alert(it, "2-handed weapon (Gain ego)", Emoji.TWO_HAND, Config.Alert.More.weap_ego)
  end
end

local function get_inventory_upgrade_alert(it)
  -- Once, find the top dps & score for inventory weapons of the same category
  local inv_best = _weapon_cache.max_dps[_weapon_cache.get_primary_key(it)]
  local top_dps = inv_best and inv_best.dps or 0
  local top_score = inv_best and get_score(inv_best) or 0

  -- Compare against all inventory weapons, even from other categories
  for _, inv in ipairs(_weapon_cache.weapons) do
    local best_dps = math.max(inv.dps, top_dps)
    local best_score = math.max(inv.score, top_score)
    local a = get_upgrade_alert(it, inv, best_dps, best_score)
    if a then return a end
  end
end

local function get_weapon_alert(it)
  return get_inventory_upgrade_alert(it)
    or get_first_of_skill_alert(it)
    or get_early_weapon_alert(it)
    or get_weap_high_score_alert(it)
end

---- Public API ----
function f_pa_weapons.serialize_weapon_cache()
  _weapon_cache.refresh()
  local tokens = { BRC.text.cyan("\n---INVENTORY WEAPONS---") }
  for _, weap in ipairs(_weapon_cache.weapons) do
    tokens[#tokens + 1] = string.format("\n%s\n", weap.basename)
    for k, v in pairs(weap) do
      if k ~= "basename" then tokens[#tokens + 1] = string.format("  %s: %s\n", k, tostring(v)) end
    end
  end
  return table.concat(tokens)
end

function f_pa_weapons.pickup_weapon(it)
  _weapon_cache.refresh()
  if need_first_weapon() then
    -- Check if we're carrying a weapon that didn't go into _weapon_cache (like a staff)
    return not util.exists(items.inventory(), function(i) return i.is_weapon end)
  end

  if BRC.is.risky_item(it) then return false end
  for _, inv in ipairs(_weapon_cache.weapons) do
    if is_weapon_upgrade(it, inv, Config.Pickup.weapons_pure_upgrades_only) then
      -- Confirm after updating cache, to avoid spurious alerts from XP gain.
      f_pa_weapons.ready()
      if is_weapon_upgrade(it, inv, Config.Pickup.weapons_pure_upgrades_only) then return true end
    end
  end
end

function f_pa_weapons.alert_weapon(it)
  _weapon_cache.refresh()
  if get_weapon_alert(it) then
    -- Confirm after updating cache, to avoid spurious alerts from XP gain.
    f_pa_weapons.ready()
    local a = get_weapon_alert(it)
    if a then return f_pickup_alert.do_alert(a.it, a.msg, a.emoji, a.fm_option) end
  end
  return false
end

---- Hook functions ----
function f_pa_weapons.init()
  top_attack_skill = BRC.get.preferred_weapon_type() or "Unarmed Combat"
  _weapon_cache.refresh()
end

function f_pa_weapons.ready()
  top_attack_skill = BRC.get.preferred_weapon_type() or "Unarmed Combat"
end

}
############################### End lua/features/pickup-alert/pa-weapons.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-misc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-misc
Description: Miscellaneous item pickup logic and alert system for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
  pa-config.lua, pa-data.lua, pa-main.lua
--]]

f_pa_misc = {}

---- Local config alias ----
local Emoji = f_pickup_alert.Config.Emoji
local Alert = f_pickup_alert.Config.Alert

---- Public API ----
function f_pa_misc.alert_orb(it)
  return f_pickup_alert.do_alert(it, "New orb", Emoji.ORB, Alert.More.orbs)
end

function f_pa_misc.alert_OTA(it)
  local ota_item = f_pa_data.find(pa_OTA_items, it)
  if not ota_item then return end

  local do_alert = true

  if BRC.is.shield(it) then
    if you.skill("Shields") < Alert.OTA_require_skill.shield then return end

    -- Don't alert if already wearing a larger shield
    if ota_item == "buckler" then
      if BRC.you.have_shield() then do_alert = false end
    elseif ota_item == "kite shield" then
      local sh = items.equipped_at("offhand")
      if sh and sh.name("qual") == "tower shield" then do_alert = false end
    end
  elseif BRC.is.armour(it) then
    if you.skill("Armour") < Alert.OTA_require_skill.armour then return end
  elseif it.is_weapon then
    if you.skill(it.weap_skill) < Alert.OTA_require_skill.weapon then return end
  end

  f_pa_data.remove(pa_OTA_items, it)
  if not do_alert then return false end
  return f_pickup_alert.do_alert(it, "Found first", Emoji.RARE_ITEM, Alert.More.one_time_alerts)
end

function f_pa_misc.alert_staff(it)
  local needRes = false
  local basename = it.name("base")

  if basename == "staff of fire" then
    needRes = you.res_fire() == 0
  elseif basename == "staff of cold" then
    needRes = you.res_cold() == 0
  elseif basename == "staff of air" then
    needRes = you.res_shock() == 0
  elseif basename == "staff of poison" then
    needRes = you.res_poison() == 0
  elseif basename == "staff of death" then
    needRes = you.res_draining() == 0
  end

  if not needRes then return false end
  return f_pickup_alert.do_alert(it, "Staff resistance", Emoji.STAFF_RES, Alert.More.staff_resists)
end

function f_pa_misc.alert_talisman(it)
  if not it.is_identified then return false end -- Necessary to avoid firing on '\' menu
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact talisman", Emoji.TALISMAN, Alert.More.talismans)
  end
  local required_skill = BRC.get.talisman_min_level(it) - Alert.talisman_lvl_diff
  if required_skill > BRC.you.shapeshifting_skill() then return false end
  return f_pickup_alert.do_alert(it, "New talisman", Emoji.TALISMAN, Alert.More.talismans)
end

function f_pa_misc.is_unneeded_ring(it)
  if not BRC.is.ring(it) or it.artefact or you.race() == "Octopode" then return false end
  local missing_hand = BRC.get.mut("missing a hand") > 0
  local st = it.subtype()
  local found_first = false
  for _, inv in ipairs(items.inventory()) do
    if BRC.is.ring(inv) and inv.subtype() == st then
      if found_first or missing_hand then return true end
      found_first = true
    end
  end
  return false
end

function f_pa_misc.pickup_staff(it)
  return BRC.get.skill(BRC.get.staff_school(it)) > 0
end

}
############################### End lua/features/pickup-alert/pa-misc.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-data
Description: Data management and persistent storage for the pickup-alert system
Author: buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua, pa-config.lua
--]]

f_pa_data = {}

---- Persistent variables ----
pa_items_alerted = BRC.Data.persist("pa_items_alerted", {})
pa_recent_alerts = BRC.Data.persist("pa_recent_alerts", {})
pa_OTA_items = BRC.Data.persist("pa_OTA_items", f_pickup_alert.Config.Alert.one_time)
pa_high_score = BRC.Data.persist("pa_high_score", { ac = 0, weapon = 0, plain_dmg = 0 })
pa_egos_alerted = BRC.Data.persist("pa_egos_alerted", {})

---- Local functions ----
local function get_pa_keys(it, use_plain_name)
  if it.class(true) == "bauble" then
    return it.name("qual"):gsub('"', ""), 0
  elseif BRC.is.talisman(it) or BRC.is.orb(it) then
    return it.name():gsub('"', ""), 0
  elseif BRC.is.magic_staff(it) then
    return it.name("base"):gsub('"', ""), 0
  else
    local name = it.name(use_plain_name and "plain" or "base"):gsub('"', "")
    local value = tonumber(name:sub(1, 3))
    if not value then return name, 0 end
    return util.trim(name:sub(4)), value
  end
end

---- Public API ----
-- Return name of first entry found in item name, or nil if not found
function f_pa_data.find(table_ref, it)
  if table_ref == pa_OTA_items then
    local qualname = it.name("qual")
    for _, v in ipairs(pa_OTA_items) do
      if v and qualname:find(v) then return v end
    end
  else
    local name, value = get_pa_keys(it)
    if table_ref[name] ~= nil and tonumber(table_ref[name]) >= value then return name end
  end
end

function f_pa_data.insert(table_ref, it)
  local is_armour = BRC.is.armour(it, true)
  if not (it.is_weapon or is_armour or BRC.is.talisman(it)) then return end

  if table_ref == pa_recent_alerts then
    pa_recent_alerts[#pa_recent_alerts + 1] = f_pa_data.get_keyname(it)
  else
    local name, value = get_pa_keys(it)
    local cur_val = tonumber(table_ref[name])
    if not cur_val or value > cur_val then table_ref[name] = value end

    -- For armour with good brand, also add the unbranded version to the table
    if is_armour and it.branded and not (it.artefact or BRC.is.risky_item(it)) then
      name = it.name("qual")
      cur_val = tonumber(table_ref[name])
      if not cur_val or value > cur_val then table_ref[name] = value end
    end
  end
end

function f_pa_data.remove(table_ref, it)
  if table_ref == pa_OTA_items then
    repeat
      local item_name = f_pa_data.find(pa_OTA_items, it)
      if item_name == nil then return end
      util.remove(pa_OTA_items, item_name)
    until item_name == nil
  elseif table_ref == pa_recent_alerts then
    util.remove(pa_recent_alerts, f_pa_data.get_keyname(it))
  else
    local name, _ = get_pa_keys(it)
    table_ref[name] = nil
  end
end

-- Get name with plus included and quotes removed; stored in pa_recent_alerts table
function f_pa_data.get_keyname(it, use_plain_name)
  local name, value = get_pa_keys(it, use_plain_name)
  if not (BRC.is.armour(it) or it.is_weapon) then return name end
  if value >= 0 then value = string.format("+%s", value) end
  return string.format("%s %s", value, name)
end

-- Returns a string of the high score type if item sets a new high score, else nil
function f_pa_data.update_high_scores(it)
  if not it then return end
  local ret_val = nil

  if BRC.is.armour(it) then
    local ac = BRC.get.armour_ac(it)
    if ac > pa_high_score.ac then
      pa_high_score.ac = ac
      if not ret_val then ret_val = "Highest AC" end
    end
  elseif it.is_weapon then
    -- Don't alert for unusable weapons
    if BRC.get.hands(it) == 2 and not BRC.you.free_offhand() then return end

    local dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.branded)
    if dmg > pa_high_score.weapon then
      pa_high_score.weapon = dmg
      if not ret_val then ret_val = "Highest damage" end
    end

    dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.plain)
    if dmg > pa_high_score.plain_dmg then
      pa_high_score.plain_dmg = dmg
      if not ret_val then ret_val = "Highest plain damage" end
    end
  end

  return ret_val
end

---- Hook functions ----
function f_pa_data.init()
  -- Update alerts & tables for starting items
  for _, inv in ipairs(items.inventory()) do
    f_pa_data.remove(pa_OTA_items, inv)
  end
end

}
############################### End lua/features/pickup-alert/pa-data.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-main.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert
Description: Comprehensive pickup and alert system for weapons, armour, and miscellaneous items
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua,
  pa-armour.lua, pa-config.lua, pa-data.lua, pa-misc.lua, pa-weapons.lua
--]]

f_pickup_alert = f_pickup_alert or {}
f_pickup_alert.BRC_FEATURE_NAME = "pickup-alert"

---- Local config alias ----
local Config = f_pickup_alert.Config

---- Local variables ----
local pause_pa_system
local hold_alerts_for_next_turn

---- Local functions ----
local function has_configured_force_more(it)
  if it.artefact then
    if Config.Alert.More.artefact then return true end
    if Config.Alert.More.trained_artefacts then
      -- Accept artefacts with any relevant training, or no training required
      local s = BRC.get.skill_with(it)
      if s == nil or s > 0 then return true end
    end
  end

  return Config.Alert.More.armour_ego and BRC.is.armour(it) and BRC.get.ego(it)
end

local function track_unique_egos(it)
  local ego = BRC.get.ego(it)
  if
    ego
    and not util.contains(pa_egos_alerted, ego)
    and not (it.artefact and BRC.is.risky_item(it))
  then
    pa_egos_alerted[#pa_egos_alerted+1] = ego
  end
end

---- Public API ----
function f_pickup_alert.pause_alerts()
  hold_alerts_for_next_turn = true
end

function f_pickup_alert.do_alert(it, alert_type, emoji, force_more)
  local item_name = f_pa_data.get_keyname(it, true)
  local alert_col

  if it.is_weapon then
    f_pa_data.update_high_scores(it)
    alert_col = Config.AlertColor.weapon
    local weapon_info = string.format(" (%s)", BRC.get.weapon_stats(it))
    item_name = item_name .. BRC.text.color(Config.AlertColor.weapon.stats, weapon_info)
  elseif BRC.is.orb(it) then
    alert_col = Config.AlertColor.orb
  elseif BRC.is.talisman(it) then
    alert_col = Config.AlertColor.talisman
  elseif BRC.is.armour(it) then
    if BRC.is.body_armour(it) then
      f_pa_data.update_high_scores(it)
      alert_col = Config.AlertColor.body_arm
      local ac, ev = BRC.get.armour_stats(it)
      local armour_info = string.format(" {%s, %s}", ac, ev)
      item_name = item_name .. BRC.text.color(Config.AlertColor.body_arm.stats, armour_info)
    else
      alert_col = Config.AlertColor.aux_arm
    end

    track_unique_egos(it)
  else
    alert_col = Config.AlertColor.misc
  end

  local tokens = {}
  tokens[1] = emoji and emoji or BRC.text.cyan("----")
  tokens[#tokens + 1] = BRC.text.color(alert_col.desc, string.format(" %s:", alert_type))
  tokens[#tokens + 1] = BRC.text.color(alert_col.item, string.format(" %s ", item_name))
  tokens[#tokens + 1] = tokens[1]
  BRC.mpr.que_optmore(force_more or has_configured_force_more(it), table.concat(tokens))

  f_pa_data.insert(pa_recent_alerts, it)
  f_pa_data.insert(pa_items_alerted, it)

  if not hold_alerts_for_next_turn then you.stop_activity() end

  if util.exists(you.floor_items(), function(fl) return fl.name() == it.name() end) then
    BRC.set_pickup_hotkey(it.name(), true)
  elseif you.feel_safe() then
    BRC.set_waypoint_hotkey(it.name())
  end

  return true
end

---- Hook functions ----
function f_pickup_alert.init()
  pause_pa_system = false
  hold_alerts_for_next_turn = false

  BRC.log.debug("Initialize pickup-alert submodules...")
  f_pa_data.init()
  BRC.log.debug("  pa-data loaded")

  if f_pa_armour then
    if f_pa_armour.init then f_pa_armour.init() end
    BRC.log.debug("  pa-armour loaded")
  end

  if f_pa_weapons then
    if f_pa_weapons.init then f_pa_weapons.init() end
    BRC.log.debug("  pa-weapons loaded")
  end

  if f_pa_misc then
    if f_pa_misc.init then f_pa_misc.init() end
    BRC.log.debug("  pa-misc loaded")
  end
end

function f_pickup_alert.autopickup(it, _)
  if
    not BRC.active
    or pause_pa_system
    or you.have_orb()
    or not it.is_identified and (it.branded or it.artefact or BRC.is.magic_staff(it))
  then
    return
  end

  local unworn_aux_item = nil -- Track carried aux armour for mutation scenarios
  if it.is_useless then
    -- Allow alerts for useless aux armour, iff you're carrying one (implies a temporary mutation)
    if not BRC.is.aux_armour(it) then return end
    local st = it.subtype()
    for _, inv in ipairs(items.inventory()) do
      if inv.subtype() == st then
        unworn_aux_item = inv
        break
      end
    end
    if not unworn_aux_item then return end
  else
    -- Pickup main
    if f_pa_armour and Config.Pickup.armour and BRC.is.armour(it) then
      if f_pa_armour.pickup_armour(it) then return true end
    elseif f_pa_misc and Config.Pickup.staves and BRC.is.magic_staff(it) then
      if f_pa_misc.pickup_staff(it) then return true end
    elseif f_pa_weapons and Config.Pickup.weapons and it.is_weapon then
      if f_pa_weapons.pickup_weapon(it) then return true end
    elseif f_pa_misc and f_pa_misc.is_unneeded_ring(it) then
      return false
    end
  end

  -- Item not picked up - check if it should trigger alerts
  if f_pa_data.find(pa_items_alerted, it) then return end

  if f_pa_misc and Config.Alert.one_time and #Config.Alert.one_time > 0 then
    if f_pa_misc.alert_OTA(it) then return end
  end

  if f_pa_misc and Config.Alert.staff_resists and BRC.is.magic_staff(it) then
    if f_pa_misc.alert_staff(it) then return end
  elseif f_pa_misc and Config.Alert.orbs and BRC.is.orb(it) then
    if f_pa_misc.alert_orb(it) then return end
  elseif f_pa_misc and Config.Alert.talismans and BRC.is.talisman(it) then
    if f_pa_misc.alert_talisman(it) then return end
  elseif f_pa_armour and Config.Alert.armour_sensitivity > 0 and BRC.is.armour(it) then
    if f_pa_armour.alert_armour(it, unworn_aux_item) then return end
  elseif f_pa_weapons and Config.Alert.weapon_sensitivity > 0 and it.is_weapon then
    if f_pa_weapons.alert_weapon(it) then return end
  end
end

function f_pickup_alert.c_assign_invletter(it)
  f_pa_misc.alert_OTA(it)
  f_pa_data.remove(pa_recent_alerts, it)

  -- Re-enable the alert, iff we are able to use another one
  if BRC.get.num_equip_slots(it) > 1 then f_pa_data.remove(pa_items_alerted, it) end

  -- Ensure we always stop for these autopickup types
  if it.is_weapon or BRC.is.armour(it) then
    f_pa_data.update_high_scores(it)
    you.stop_activity()
  end
end

function f_pickup_alert.c_message(text, channel)
  -- Avoid firing alerts when changing armour/weapons
  if channel == "multiturn" then
    if not pause_pa_system and text:contains("ou start ") then pause_pa_system = true end
  elseif channel == "plain" then
    if pause_pa_system and (text:contains("ou stop ") or text:contains("ou finish ")) then
      pause_pa_system = false
    elseif text:contains("one exploring") or text:contains("artly explored") then
      local tokens = { "Recent alerts:" }
      for _, v in ipairs(pa_recent_alerts) do
        tokens[#tokens + 1] = string.format("\n  %s", v)
      end
      if #tokens > 1 then BRC.mpr.que(table.concat(tokens), BRC.COL.magenta) end
      pa_recent_alerts = {}
    end
  end
end

function f_pickup_alert.ready()
  hold_alerts_for_next_turn = false
  if pause_pa_system then return end
  f_pa_weapons.ready()
  f_pa_data.update_high_scores(items.equipped_at("armour"))
end

}
############################### End lua/features/pickup-alert/pa-main.lua ###############################
##########################################################################################
