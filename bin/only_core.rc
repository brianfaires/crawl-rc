## BRC Core files - Copy/paste any features above this line.

################################### Begin lua/core/config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC core module
-- @module BRC.Configs
-- Manages user-defined configs and feature config overrides.
--
-- TL;DR: Each feature has its own config, with default values for every field.
--   To change those values, define the same fields in a user-defined config.
--
-- When a user-defined config is loaded, it inherits values from BRC.Configs.Default.
-- If a user-defined config defines a field, that value is used.
--   If not defined in the config, the value in BRC.Configs.Default is used.
--   If not defined in either, the default value in the feature config is used.
-- @warning BRC.Configs.Default defines all fields not in a feature config. Do not remove them.
---------------------------------------------------------------------------------------------------

BRC.Configs = {}

---- Persistent variables ----
brc_full_persistant_config = BRC.Data.persist("brc_full_persistant_config", nil)
brc_config_name = BRC.Data.persist("brc_config_name", nil)

---- BRC Default Config - Every user-defined config inherits these
-- Define config fields that aren't feature-specific, and set their default values

BRC.Configs.Default = util.copy_table(BRC.Config) -- Include values from BRC.Config in _header.lua
BRC.Configs.Default.BRC_CONFIG_NAME = "Default"

-- Does "Armour of <MagicSkill>" have an ego when skill is 0?
BRC.Configs.Default.unskilled_egos_usable = false

BRC.Configs.Default.mpr = {
  show_debug_messages = false,
  debug_to_stderr = false,
} -- BRC.Configs.Default.mpr (do not remove this comment)

BRC.Configs.Default.dump = {
    max_lines_per_table = 200, -- Avoid huge tables (alert_monsters.Config.Alerts) in debug dumps
    omit_pointers = true, -- Don't dump functions and userdata (they only show a hex address)
} -- BRC.Configs.Default.dump (do not remove this comment)

--- How weapon damage is calculated for inscriptions+pickup/alert: (factor * DMG + offset)
BRC.Configs.Default.BrandBonus = {
  chaos = { factor = 1.15, offset = 2.0 }, -- Approximate weighted average
  distort = { factor = 1.0, offset = 6.0 },
  drain = { factor = 1.25, offset = 2.0 },
  elec = { factor = 1.0, offset = 4.5 },   -- 3.5 on avg; fudged up for AC pen
  flame = { factor = 1.25, offset = 0 },
  freeze = { factor = 1.25, offset = 0 },
  heavy = { factor = 1.8, offset = 0 },    -- Speed is accounted for elsewhere
  pain = { factor = 1.0, offset = you.skill("Necromancy") / 2 },
  spect = { factor = 1.7, offset = 0 },    -- Fudged down for increased incoming damage
  venom = { factor = 1.0, offset = 5.0 },  -- 5 dmg per poisoning

  subtle = { -- Values to use for weapon "scores" (not damage)
    antimagic = { factor = 1.1, offset = 0 },
    holy = { factor = 1.15, offset = 0 },
    penet = { factor = 1.3, offset = 0 },
    protect = { factor = 1.15, offset = 0 },
    reap = { factor = 1.3, offset = 0 },
    vamp = { factor = 1.2, offset = 0 },
  },
} -- BRC.Configs.Default.BrandBonus (do not remove this comment)

---- Local functions ----
local function is_config_module(p)
  return p
    and type(p) == "table"
    and p.BRC_CONFIG_NAME
    and type(p.BRC_CONFIG_NAME) == "string"
    and #p.BRC_CONFIG_NAME > 0
end

local function find_config_modules()
  for _, c in pairs(_G) do
    if is_config_module(c) then BRC.Configs[c.BRC_CONFIG_NAME] = c end
  end
end

--- @param input_name string "ask" or "previous" or a config name
-- @return string The valid name of a config
local function get_valid_config_name(input_name)
  if #BRC.Configs == 1 then return util.keys(BRC.Configs)[1] end

  if type(input_name) ~= "string" then
    BRC.mpr.warning("Non-string config name: " .. tostring(input_name))
  else
    local config_name = input_name:lower()
    if config_name == "ask" then
      -- If game has started, restore from the previously saved config name
      if you.turns() > 0 and brc_config_name then
        return get_valid_config_name(brc_config_name)
      end
    elseif config_name == "previous" then
      -- Restore from the config name in c_persist (cross-game persistence), or display warning
      if c_persist.BRC and c_persist.BRC.current_config then
        return get_valid_config_name(c_persist.BRC.current_config)
      else
        BRC.mpr.warning("No previous config found.")
      end
    else
      -- Find by name in BRC.Configs, or display warning
      for k, _ in pairs(BRC.Configs) do
        if config_name == k:lower() then return k end
      end
      BRC.mpr.warning("Could not load config: " .. tostring(input_name))
    end
  end

  return BRC.mpr.select("Select a config", util.keys(BRC.Configs))
end

local function safe_call_string(str, module_name)
  local chunk, err = loadstring(str)
  if not chunk then
    BRC.mpr.error("Error loading " .. module_name .. ".Config.init string: ", err)
  else
    local success, result = pcall(chunk)
    if not success then
      BRC.mpr.error("Error executing " .. module_name .. ".Config.init string: ", result)
    end
  end
end

local function execute_config_init(config, module_name)
  if type(config) ~= "table" then return end
  if type(config.init) == "function" then
    config.init()
  elseif type(config.init) == "string" then
    safe_call_string(config.init, module_name)
  end
end

--- Override values in dest, with values from source. Take care not to clear existing tables.
-- Does not override "init"
local function override_table(dest, source)
  if type(source) ~= "table" then return end

  for key, value in pairs(source) do
    if BRC.util.is_map(value) then
      if not dest[key] then dest[key] = {} end
      override_table(dest[key], value)
    elseif key ~= "init" then
      dest[key] = value
    end
  end
end

--- Load a config, either from a table or from a name.
-- @param config table of config values, or string name of a config
local function load_specific_config(config)
  BRC.Config = util.copy_table(BRC.Configs.Default)
  if type(config) == "table" then
    override_table(BRC.Config, config)
  else
    local name = get_valid_config_name(config)
    override_table(BRC.Config, BRC.Configs[name])
    execute_config_init(BRC.Config, "BRC")
    execute_config_init(BRC.Configs[name], "BRC.Configs." ..name)
  end

  -- Store persistent config info
  brc_config_name = BRC.Config.BRC_CONFIG_NAME
  if BRC.Config.store_config and BRC.Config.store_config:lower() == "full" then
    brc_full_persistant_config = BRC.Config
  end

  -- Init all features and apply any overrides from the loaded config
  for _ , value in pairs(BRC.get_registered_features()) do
    BRC.process_feature_config(value)
  end

  BRC.mpr.white("[BRC] Using config: " .. BRC.txt.lightcyan(BRC.Config.BRC_CONFIG_NAME))
end

---- Public API ----
--- Main config loading entry point
-- @param config table of config values, or string name of a config
function BRC.init_config(config)
  find_config_modules()

  if config then
    load_specific_config(config)
  else
    local store_mode = BRC.Config.store_config and BRC.Config.store_config:lower() or nil
    if store_mode == "full" then
      load_specific_config(brc_full_persistant_config or brc_config_name or BRC.Config.use_config)
    elseif store_mode == "name" then
      load_specific_config(brc_config_name or BRC.Config.use_config)
    else
      load_specific_config(BRC.Config.use_config)
    end
  end
end

--- Process a feature config: Ensure default values, init(), then override with BRC.Config values
function BRC.process_feature_config(feature)
  if type(feature.ConfigDefaults) == "table" then
    feature.Config = util.copy_table(feature.ConfigDefaults)
  else
    feature.Config = feature.Config or {}
    execute_config_init(feature.Config, feature.BRC_FEATURE_NAME)
    feature.ConfigDefaults = util.copy_table(feature.Config)
  end

  override_table(feature.Config, BRC.Config[feature.BRC_FEATURE_NAME])
end

--- Stringify BRC.Config and each feature config, with headers
-- @return table of strings, one for each config section (1 big string will overflow crawl.mpr())
function BRC.serialize_config()
  local tokens = {}
  tokens[#tokens + 1] = BRC.txt.lightcyan("\n---BRC Config---\n") .. BRC.txt.tostr(BRC.Config, true)

  local all_features = BRC.get_registered_features()
  local keys = util.keys(all_features)
  util.sort(keys)

  for i = 1, #keys do
    local name = keys[i]
    local feature = all_features[name]
    if feature.Config then
      local header = BRC.txt.cyan("\n\n---Feature Config: " .. name .. "---\n")
      tokens[#tokens + 1] = header .. BRC.txt.tostr(feature.Config, true)
    end
  end

  return tokens
end

---- Initialize BRC.Config for debugging during startup + data.persist() calls ----
override_table(BRC.Config, BRC.Configs.Default)

}
############################### End lua/core/config.lua ###############################
##########################################################################################

################################### Begin lua/core/constants.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC core module
-- @module BRC
-- Constants and definitions used throughout BRC.
---------------------------------------------------------------------------------------------------

---- Cosmetic settings
BRC.EMOJI = {
  CAUTION = BRC.Config.emojis and "⚠️" or "<yellow>!</yellow>",
  EXCLAMATION = BRC.Config.emojis and "❗" or "<magenta>!</magenta>",
  EXCLAMATION_2 = BRC.Config.emojis and "‼️" or "<lightmagenta>!!</lightmagenta>",
  SUCCESS = BRC.Config.emojis and "✅" or nil,
} -- BRC.EMOJI (do not remove this comment)

---- Items ----
BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine",
  "horn of Geryon", "lightning rod", "phantom mirror", "phial of floods", "sack of spiders",
  "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

-- This is checked against the full text of the pickup message, so use patterns to match
BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)

-- Could be removed after https://github.com/crawl/crawl/issues/4606 is addressed
BRC.SPELLBOOKS = {
  "parchment of", "book of", "Necronomicon", "Grand Grimoire", "tome of obsoleteness",
  "Everburning Encyclopedia", "Ozocubu's Autobiography", "Maxwell's Memoranda",
  "Young Poisoner's Handbook", "Fen Folio", "Inescapable Atlas", "There-And-Back Book",
  "Great Wizards, Vol. II", "Great Wizards, Vol. VII", "Trismegistus Codex",
  "the Unrestrained Analects", "Compendium of Siegecraft", "Codex of Conductivity",
  "Handbook of Applied Construction", "Treatise on Traps", "My Sojourn through Swampland",
  "Akashic Record",
  -- Include prefixes for randart books
  "Almanac", "Anthology", "Atlas", "Book", "Catalogue", "Codex", "Compendium",
  "Compilation", "Cyclopedia", "Directory", "Elucidation", "Encyclopedia", "Folio",
  "Grimoire", "Handbook", "Incunable", "Incunabulum", "Octavo", "Omnibus", "Papyrus",
  "Parchment", "Precepts", "Quarto", "Secrets", "Spellbook", "Tome", "Vellum", "Volume",
} -- BRC.SPELLBOOKS (do not remove this comment)

---- Races ----
BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant" }
BRC.NONLIVING_RACES = { "Djinni", "Gargoyle" }
BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant" }
BRC.LITTLE_RACES = { "Spriggan" }
BRC.SMALL_RACES = { "Kobold" }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll" }

---- Skills ----
BRC.MAGIC_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", conjuration = "Conjurations",
  death = "Necromancy", earth = "Earth Magic", fire = "Fire Magic",   necromancy = "Necromancy",
} -- BRC.MAGIC_SCHOOLS (do not remove this comment)

BRC.TRAINING_SKILLS = {
  "Air Magic", "Alchemy", "Armour", "Axes", "Conjurations", "Dodging", "Earth Magic",
  "Evocations", "Fighting", "Fire Magic", "Forgecraft", "Hexes", "Ice Magic",
  "Invocations", "Long Blades", "Maces & Flails", "Necromancy", "Polearms",
  "Ranged Weapons", "Shapeshifting", "Shields", "Short Blades", "Spellcasting", "Staves",
  "Stealth", "Summonings", "Translocations", "Unarmed Combat", "Throwing",
} -- BRC.TRAINING_SKILLS (do not remove this comment)

BRC.WEAP_SCHOOLS = {
  "axes", "maces & flails", "polearms", "long blades", "short blades",
  "staves", "unarmed combat", "ranged weapons",
} -- BRC.WEAP_SCHOOLS (do not remove this comment)

---- Branches ----
BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar" }
BRC.PORTAL_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "Ice Cave", "Necropolis",
  "Ossuary", "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_NAMES (do not remove this comment)

---- Egos ----
BRC.RISKY_EGOS = { "antimagic", "chaos", "distort", "harm", "heavy", "Infuse", "Ponderous" }
BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect" }
BRC.ADJECTIVE_EGOS = { -- Egos whose English modifier comes before item name
  antimagic = "antimagic", heavy = "heavy", spectralising = "spectral", vampirism = "vampiric"
} -- BRC.ADJECTIVE_EGOS (do not remove this comment)

---- Artefact properties ----
BRC.ARTPROPS_BAD = {
  "Bane", "-Cast", "-Move", "-Tele",
  "*Corrode", "*Noise", "*Rage", "*Silence", "*Slow", "*Tele",
} -- BRC.ARTPROPS_BAD (do not remove this comment)

BRC.ARTPROPS_EGO = { -- Corresponding ego
  rF = "fire resistance", rC = "cold resistance", rPois = "poison resistance",
  rN = "positive energy", rCorr = "corrosion resistance",
  Archmagi = "the Archmagi", Rampage = "rampaging", Will = "willpower",
  Air = "air", Earth = "earth", Fire = "fire", Ice = "ice", Necro = "death", Summ = "command",
} -- BRC.ARTPROPS_EGO (do not remove this comment)

---- Other ----
BRC.KEYS = { ENTER = 13, ESC = 27, ["Cntl-S"] = 20, ["Cntl-E"] = 5 }

BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg for non-elemental brands
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2 }

}
############################### End lua/core/constants.lua ###############################
##########################################################################################

################################### Begin lua/core/data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC core feature: data-manager
-- @module BRC.Data
-- Provides functions and maintenance for persistent variables that survive game restarts.
-- Handles backup/restore functionality and error handling.
---------------------------------------------------------------------------------------------------

BRC.Data = {}
BRC.Data.BRC_FEATURE_NAME = "data-manager" -- Included as a feature for Config override

---- Local constants ----
local RESTORE_TABLE = "_brc_persist_restore_table"
local MAX_RESTORE_RETRIES = 5  -- Maximum number of retry prompts for data restoration

---- Local variables ----
-- Init tables in declaration, so persist() can be called before init()
local _failures = {}
local _persist_names = {}
local _default_values = {}
local pushed_restore_table_creation = false -- Set this on file load, not on init()
local cur_location

---- Initialization ----
function BRC.Data.init()
  cur_location = you.where()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
end

---- Local functions ----
local function is_usable_backup()
  if
    type(c_persist.BRC) ~= "table"
    or type(c_persist.BRC.Backup) ~= "table"
    or c_persist.BRC.Backup.backup_name ~= you.name()
    or c_persist.BRC.Backup.backup_race ~= you.race()
    or c_persist.BRC.Backup.backup_class ~= you.class()
  then
    return false
  end

  local turn_diff = you.turns() - c_persist.BRC.Backup.backup_turn
  if turn_diff == 0 then return true end
  for _ = 1, MAX_RESTORE_RETRIES do
    if BRC.mpr.yesno("Use backup from " .. turn_diff .. " turns ago?") then return true end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return false end
  end
  return true
end

local function try_restore(failed_vars)
  if not is_usable_backup() then
    BRC.mpr.error("Unable to restore from backup. Persistent data reset to defaults.", true)
    BRC.mpr.info("For detailed startup info, set BRC.Config.mpr.show_debug_messages=True.")
    return false
  end

  for _, name in ipairs(failed_vars) do
    _default_values[name] = nil -- Avoid re-init warnings
    _G[name] = BRC.Data.persist(name, c_persist.BRC.Backup[name])
  end
  BRC.mpr.green("[BRC] Restored data from backup.")
  return true
end

---- Public API ----

--- Creates a persistent global variable or table, that retains its value through restarts.
-- @usage `var = BRC.Data.persist("var", value)`
-- @warning After restarting, the variable/table will not exist until this is called.
-- @return any The current value (whether default or persisted)
function BRC.Data.persist(name, default_value)
  local t = type(default_value)
  if not util.contains({ "table", "string", "number", "boolean", "nil" }, t) then
    BRC.mpr.error(string.format("Cannot persist %s. Default value is of type %s", name, t))
    return default_value
  end

  -- Keep default value for re-init
  if _default_values[name] then
    BRC.mpr.warning("Multiple calls to BRC.Data.persist(" .. name .. ", ...)")
  end
  if type(default_value) == "table" then
    -- Preserve the user's original table (may be in a config, etc)
    default_value = util.copy_table(default_value)
    _default_values[name] = util.copy_table(default_value)
  else
    _default_values[name] = default_value
  end

  -- Try to restore from persistent restore table
  if you.turns() == 0 then
    _G[name] = default_value
  elseif _G[RESTORE_TABLE] and _G[RESTORE_TABLE][name] ~= nil then
    _G[name] = _G[RESTORE_TABLE][name]
    _G[RESTORE_TABLE][name] = nil
  elseif default_value ~= nil and not util.contains(_failures, name) then -- avoid inf loop
    _G[name] = default_value
    _failures[#_failures + 1] = name
    BRC.mpr.debug(BRC.txt.red(name .. " failed to restore from chk_lua_save."))
  end

  -- Create persistent restore table on next startup
  if not pushed_restore_table_creation then
    table.insert(chk_lua_save, function()
      return RESTORE_TABLE .. " = {}\n"
    end)
    pushed_restore_table_creation = true
  end

  -- Set up persist on next startup
  if not util.contains(_persist_names, name) then
    _persist_names[#_persist_names + 1] = name
    table.insert(chk_lua_save, function()
      if _G[name] == nil then return "" end
      return RESTORE_TABLE .. "." .. name .. " = " .. BRC.txt.tostr(_G[name]) .. "\n"
    end)
  end

  return _G[name]
end

function BRC.Data.serialize()
  local tokens = { BRC.txt.lightmagenta("\n---PERSISTENT VARIABLES---\n") }
  local sorted_keys = BRC.util.get_sorted_keys(_persist_names)
  for _, key in ipairs(sorted_keys) do
    tokens[#tokens + 1] = string.format("%s = %s\n", key, BRC.txt.tostr(_G[key], true))
  end
  return table.concat(tokens)
end

function BRC.Data.reset()
  if _persist_names then
    for _, name in ipairs(_persist_names) do
      if type(_default_values[name]) == "table" then
        _G[name] = util.copy_table(_default_values[name])
      else
        _G[name] = _default_values[name]
      end
    end
  end

  BRC.mpr.warning("Reset all persistent data to default values.")
end

--- @return boolean|nil true if no persist errors, false if failed restore, nil if handled errors
function BRC.Data.handle_persist_errors()
  if #_failures == 0 then return true end
  local msg = "%s persistent variables did not restore: (%s)"
  BRC.mpr.error(msg:format(#_failures, table.concat(_failures, ", ")), true)

  for _ = 1, MAX_RESTORE_RETRIES do
    if BRC.mpr.yesno("Try restoring from backup?") then break end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return nil end
  end

  -- Whether restore works or not, we should reset _failures
  local failed_vars = _failures
  _failures = {}
  if try_restore(failed_vars) then return nil end
  return false
end

-- Backup and Restore from c_persist.BRC.Backup
function BRC.Data.backup()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
  c_persist.BRC.Backup = {}
  c_persist.BRC.Backup.backup_name = you.name()
  c_persist.BRC.Backup.backup_race = you.race()
  c_persist.BRC.Backup.backup_class = you.class()
  c_persist.BRC.Backup.backup_turn = you.turns()
  for _, name in ipairs(_persist_names) do
    c_persist.BRC.Backup[name] = _G[name]
  end
end

---- Crawl hook functions ----
function BRC.Data.ready()
  if you.where() ~= cur_location and not you.have_orb() then
    cur_location = you.where()
    BRC.Data.backup()
  end
end

}
############################### End lua/core/data.lua ###############################
##########################################################################################

################################### Begin lua/core/brc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
---------------------------------------------------------------------------------------------------
-- BRC core module
-- @module BRC
-- @author buehler
-- Serves as the central coordinator for all feature modules.
-- Automatically loads any global module/table that defines `BRC_FEATURE_NAME`
-- and manages the feature's lifecycle and hook dispatching.
---------------------------------------------------------------------------------------------------

---- Local constants ----
BRC.VERSION = "1.2.0"
BRC.MIN_CRAWL_VERSION = "0.34"

local HOOK_FUNCTIONS = {
  autopickup = "autopickup",
  c_answer_prompt = "c_answer_prompt",
  c_assign_invletter = "c_assign_invletter",
  c_message = "c_message",
  ch_start_running = "ch_start_running",
  init = "init",
  ready = "ready",
} -- HOOK_FUNCTIONS (do not remove this comment)

---- Local variables ----
local _features
local _hooks
local turn_count = -1 -- Do not reset this in init()

---- Local functions ----
local function char_dump(add_debug_info)
  if add_debug_info then
    crawl.take_note(BRC.dump(true, true))
    BRC.mpr.info("Debug info added to character dump.")
  else
    BRC.mpr.info("No debug info added.")
  end

  BRC.util.do_cmd("CMD_CHARACTER_DUMP")
end

local function feature_is_disabled(f)
  local main = BRC.Config[f.BRC_FEATURE_NAME]
  if main and main.disabled == false then return false end
  return (f.Config and f.Config.disabled) or (main and main.disabled)
end

local function handle_feature_error(feature_name, hook_name, result)
  BRC.mpr.error(string.format("Failure in %s.%s", feature_name, hook_name), result, true)
  if BRC.mpr.yesno(string.format("Deactivate %s?", feature_name), BRC.COL.yellow) then
    BRC.unregister(feature_name)
  else
    BRC.mpr.okay()
  end
end

local function handle_core_error(hook_name, result, ...)
  local params = { hook_name }
  for i = 1, select("#", ...) do
    local param = select(i, ...)
    if param and type(param.name) == "function" then
      params[#params + 1] = "[" .. param.name() .. "]"
    else
      params[#params + 1] = BRC.txt.tostr(param, true)
    end
  end

  local msg = "BRC failure in safe_call_all_hooks(" .. table.concat(params, ", ") .. ")"
  BRC.mpr.error(msg, result, true)
  if BRC.mpr.yesno("Deactivate BRC." .. hook_name .. "?", BRC.COL.yellow) then
    _hooks[hook_name] = nil
    BRC.mpr.brown("Unregistered hook: " .. tostring(hook_name))
  else
    BRC.mpr.okay("Returning nil to " .. hook_name .. ".")
  end
end

-- Hook management
local function call_all_hooks(hook_name, ...)
  local last_return_value = nil
  local returning_feature = nil

  for i = #_hooks[hook_name], 1, -1 do
    local hook_info = _hooks[hook_name][i]
    if not feature_is_disabled(_features[hook_info.feature_name]) then
      if hook_name == HOOK_FUNCTIONS.init then
        BRC.mpr.debug(string.format("Initialize %s...", BRC.txt.lightcyan(hook_info.feature_name)))
      end
      local success, result = pcall(hook_info.func, ...)
      if not success then
        handle_feature_error(hook_info.feature_name, hook_name, result)
      elseif result ~= nil and last_return_value ~= result then
        -- Only track non-nil return values. This actually matters for autopickup
        if hook_name == HOOK_FUNCTIONS.autopickup then
          -- Unique case. One false will block autopickup.
          if result == false or last_return_value == nil then
            last_return_value = result
            returning_feature = hook_info.feature_name
          end
        else
          if last_return_value ~= nil then
            BRC.mpr.warning(
              string.format(
                "Return value mismatch in %s:\n  (first) %s -> %s\n  (final) %s -> %s",
                hook_name,
                returning_feature,
                BRC.txt.tostr(last_return_value, true),
                hook_info.feature_name,
                BRC.txt.tostr(result, true)
              )
            )
          end
          last_return_value = result
          returning_feature = hook_info.feature_name
        end
      end
    end
  end
  return last_return_value
end

--- Errors in this function won't show up in crawl, so it's kept simple and safe.
local function safe_call_all_hooks(hook_name, ...)
  if not (_hooks and _hooks[hook_name] and #_hooks[hook_name] > 0) then return end

  local success, result = pcall(call_all_hooks, hook_name, ...)
  if success then return result end

  success, result = pcall(handle_core_error, hook_name, result, ...)
  if success then return end

  -- This is a serious error. Failed in the hook, and when we tried to report it.
  BRC.mpr.error("Failed to handle BRC core error!", result, true)
  if BRC.mpr.yesno("Dump char and deactivate BRC?", BRC.COL.yellow) then
    BRC.active = false
    BRC.mpr.brown("BRC deactivated.", "Error in hook: " .. tostring(hook_name))
    pcall(char_dump, true)
  else
    BRC.mpr.okay()
  end
end

-- Register all features in the global namespace
local function register_all_features()
  -- Find all feature modules
  local feature_names = {}
  for name, value in pairs(_G) do
    if BRC.is_feature_module(value) then feature_names[#feature_names + 1] = name end
  end

  -- Sort alphabetically (for reproducable behavior)
  util.sort(feature_names)

  -- Register features
  local loaded_count = 0
  for _, name in ipairs(feature_names) do
    local success = BRC.register(_G[name])
    if success then
      loaded_count = loaded_count + 1
    elseif success == false then
      BRC.mpr.error("Failed to register feature: " .. name .. ". Aborting bulk registration.")
      return loaded_count
    end
  end

  return loaded_count
end


---- Public API ----
function BRC.get_registered_features()
  return _features
end

function BRC.is_feature_module(f)
  return f
    and type(f) == "table"
    and f.BRC_FEATURE_NAME
    and type(f.BRC_FEATURE_NAME) == "string"
    and #f.BRC_FEATURE_NAME > 0
end

-- BRC.register(): Return true if success, false if error, nil if feature is disabled
function BRC.register(f)
  if not BRC.is_feature_module(f) then
    BRC.mpr.error("Tried to register a non-feature module! Module contents:\n" .. BRC.txt.tostr(f))
    return false
  elseif _features[f.BRC_FEATURE_NAME] then
    BRC.mpr.warning(BRC.txt.lightcyan(f.BRC_FEATURE_NAME) .. " already registered! Repeating...")
    BRC.unregister(f.BRC_FEATURE_NAME)
  end

  if feature_is_disabled(f) then
    BRC.mpr.debug(BRC.txt.lightcyan(f.BRC_FEATURE_NAME) .. " is disabled. Skipped registration.")
    return nil
  else
    if not BRC.Config[f.BRC_FEATURE_NAME] then BRC.Config[f.BRC_FEATURE_NAME] = {} end
    if not f.Config then f.Config = {} end
    f.Config.disabled = false
  end

  BRC.mpr.debug(string.format("Registering %s...", BRC.txt.lightcyan(f.BRC_FEATURE_NAME)))
  _features[f.BRC_FEATURE_NAME] = f

  -- Register hooks
  for _, hook_name in pairs(HOOK_FUNCTIONS) do
    if f[hook_name] then
      if not _hooks[hook_name] then _hooks[hook_name] = {} end
      table.insert(_hooks[hook_name], {
        feature_name = f.BRC_FEATURE_NAME,
        hook_name = hook_name,
        func = f[hook_name],
      })
    end
  end

  BRC.process_feature_config(f)

  return true
end

function BRC.unregister(name)
  if not _features[name] then
    BRC.mpr.error(BRC.txt.yellow(name) .. " is not registered. Cannot unregister.")
    return false
  end

  _features[name] = nil
  local removed = {}
  for hook_name, hooks in pairs(_hooks) do
    for i = #hooks, 1, -1 do
      if hooks[i].feature_name == name then
        table.remove(hooks, i)
        removed[#removed + 1] = hook_name
      end
    end
  end

  BRC.mpr.info(string.format("Unregistered %s.", name))
  BRC.mpr.debug(string.format("Unregistered %s hooks: (%s)", name, table.concat(removed, ", ")))
  return true
end

-- @param config table of config values, or string name of a config
function BRC.reset(config)
  BRC.active = false
  BRC.Data.reset()
  BRC.init(config)
end

-- @param config table of config values, or string name of a config
function BRC.init(config)
  BRC.active = false
  _features = {}
  _hooks = {}

  if not BRC.util.version_is_valid(BRC.MIN_CRAWL_VERSION) then
    BRC.mpr.error(string.format(
      "BRC v%s requires crawl v%s or higher. You are running %s.",
      BRC.VERSION,
      BRC.txt.yellow(BRC.MIN_CRAWL_VERSION),
      BRC.txt.yellow(crawl.version("major"))
    ))
    if not BRC.mpr.yesno("Continue loading BRC anyway?", BRC.COL.yellow) then
      BRC.mpr.brown("BRC deactivated.")
      return false
    end
  end

  BRC.init_config(config)
  BRC.mpr.debug("Config loaded.")

  BRC.mpr.debug("Register core features...")
  BRC.register(BRC.Data)
  BRC.register(BRC.Hotkey)

  BRC.mpr.debug("Register features...")
  register_all_features()

  BRC.mpr.debug("Initialize features...")
  safe_call_all_hooks(HOOK_FUNCTIONS.init)
  local suffix = BRC.txt.blue(string.format(" (%s features)", #util.keys(_features)))

  BRC.mpr.debug("Add non-feature hooks...")
  add_autopickup_func(BRC.autopickup)
  BRC.opt.macro(BRC.util.get_cmd_key("CMD_CHARACTER_DUMP") or "#", "macro_brc_dump_character")

  BRC.mpr.debug("Verify persistent data reload...")
  local success = BRC.Data.handle_persist_errors()
  if success then
    BRC.Data.backup() -- Only backup after a clean startup
    local msg = string.format("Successfully initialized BRC v%s!%s", BRC.VERSION, suffix)
    BRC.mpr.lightgreen("\n" .. BRC.txt.wrap(msg, BRC.EMOJI.SUCCESS) .. "\n")
  else
    -- success == nil if errors were resolved, false if tried restore but failed
    if success == false and BRC.mpr.yesno("Deactivate BRC?" .. suffix, BRC.COL.yellow) then
      BRC.active = false
      BRC.mpr.lightred("\nBRC is off.\n")
      return false
    end
    BRC.mpr.magenta(string.format("\nInitialized BRC v%s with warnings!%s\n", BRC.VERSION, suffix))
  end

  -- Avoid weird effects from autopickup before first turn
  BRC.active = you.turns() > 0
  return true
end

--- Pull debug info. Print to mpr() and return as string
-- @param skip_mpr (optional bool) Used in char_dump to just return the string
function BRC.dump(verbose, skip_mpr)
  local tokens = {}
  tokens[#tokens + 1] = BRC.Data.serialize()
  if verbose then
    tokens[#tokens + 1] = BRC.txt.serialize_chk_lua_save()
    tokens[#tokens + 1] = BRC.txt.serialize_inventory()
    util.append(tokens, BRC.serialize_config())
  end

  if not skip_mpr then
    for _, token in ipairs(tokens) do
      BRC.mpr.white(token)
    end
  end

  return table.concat(tokens, "\n")
end

---- Macros ----
function macro_brc_dump_character()
  if not BRC.active then BRC.util.do_cmd("CMD_CHARACTER_DUMP") end
  char_dump(BRC.mpr.yesno("Add BRC debug info to character dump?", BRC.COL.lightcyan))
end

---- Crawl hooks ----
function BRC.autopickup(it, _)
  return safe_call_all_hooks(HOOK_FUNCTIONS.autopickup, it)
end

function BRC.c_answer_prompt(prompt)
  if not BRC.active then return end
  if not prompt then return end -- This fires from crawl, e.g. Shop purchase confirmation
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_answer_prompt, prompt)
end

function BRC.c_assign_invletter(it)
  if not BRC.active then return end
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_assign_invletter, it)
end

function BRC.c_message(text, channel)
  if not BRC.active then return end
  safe_call_all_hooks(HOOK_FUNCTIONS.c_message, text, channel)
end

function BRC.ch_start_running(kind)
  if not BRC.active then return end
  safe_call_all_hooks(HOOK_FUNCTIONS.ch_start_running, kind)
end

function BRC.ready()
  if you.turns() == 0 then BRC.active = true end
  if not BRC.active then return end
  crawl.redraw_screen()
  BRC.clear_single_turn_mutes()

  if you.turns() > turn_count then
    turn_count = you.turns()
    safe_call_all_hooks(HOOK_FUNCTIONS.ready)
  end

  -- Always display messages, even if same turn
  BRC.mpr.consume_queue()
end

}
############################### End lua/core/brc.lua ###############################
##########################################################################################
