## Standalone BRC Feature: inscribe-stats
## Generated from: lua/features/inscribe-stats.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false

f_inscribe_stats = {}
f_inscribe_stats.Config = {
  inscribe_weapons = true, -- Inscribe weapon stats on pickup
  inscribe_armour = true, -- Inscribe armour stats on pickup
  dmg_type = BRC.DMG_TYPE.unbranded, -- unbranded, plain, branded, scoring
  skip_dps = false, -- Skip DPS in weapon inscriptions
  prefix_staff_dmg = true, -- Special prefix for magical staves
} -- f_inscribe_stats.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg for non-elemental brands
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll" }

BRC.LITTLE_RACES = { "Spriggan" }

BRC.MAGIC_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", chemistry = "Alchemy", cold = "Ice Magic",
  conjuration = "Conjurations", death = "Necromancy", earth = "Earth Magic", fire = "Fire Magic",
  necromancy = "Necromancy",
} -- BRC.MAGIC_SCHOOLS (do not remove this comment)

BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect" }

BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant" }

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2 }

BRC.SMALL_RACES = { "Kobold" }

BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant" }


-- BRC module tables (Don't overwrite existing globals)
BRC.eq = BRC.eq or {}
BRC.it = BRC.it or {}
BRC.you = BRC.you or {}

-- BRC.eq module
local function format_dmg(dmg)
  if dmg < 10 then return string.format("%.2f", dmg) end
  if dmg < 100 then return string.format("%.1f", dmg) end
  return string.format("%.0f ", dmg)
end

local function format_stat(abbr, val, is_worn)
  local stat_str = string.format("%.1f", val)
  if val < 0 then
    return string.format("%s%s", abbr, stat_str)
  elseif is_worn then
    return string.format("%s:%s", abbr, stat_str)
  else
    return string.format("%s+%s", abbr, stat_str)
  end
end

local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_delta_ac_ev(it)
  local it_ac = BRC.eq.get_ac(it)
  local it_ev = BRC.eq.get_armour_ev(it)
  local cur = items.equipped_at(it.equip_type)
  if not cur or it.equipped or BRC.you.num_eq_slots(it) > 1 then
    return it_ac, it_ev
  else
    return it_ac - BRC.eq.get_ac(cur), it_ev - BRC.eq.get_armour_ev(cur)
  end
end

local function get_dmg_with_brand_bonus(ego, base_dmg, it_plus, dmg_type)
  if not ego then return base_dmg + it_plus end

  -- Check if brand should apply based on damage type
  local should_apply = (
    dmg_type == BRC.DMG_TYPE.unbranded and ego == "heavy"
    or dmg_type == BRC.DMG_TYPE.plain and util.contains(BRC.NON_ELEMENTAL_DMG_EGOS, ego)
    or dmg_type >= BRC.DMG_TYPE.branded and BRC.Config.BrandBonus[ego]
    or dmg_type == BRC.DMG_TYPE.scoring and BRC.Config.BrandBonus.subtle[ego]
  )

  if should_apply then
    local bonus = BRC.Config.BrandBonus[ego] or BRC.Config.BrandBonus.subtle[ego]
    return bonus.factor * base_dmg + it_plus + bonus.offset
  else
    return base_dmg + it_plus
  end
end

local function get_shield_penalty(sh)
  return 2 * sh.encumbrance * sh.encumbrance
    * (27 - you.skill("Shields")) / 27
    / (25 + 5 * you.strength())
end

local function get_delta_sh_ev(it)
  local it_sh = BRC.eq.get_sh(it)
  local it_ev = -get_shield_penalty(it)
  local cur = items.equipped_at(it.equip_type)
  if not cur or it.equipped then
    return it_sh, it_ev
  else
    return it_sh - BRC.eq.get_sh(cur), it_ev + get_shield_penalty(cur)
  end
end

local function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaict
  for i = 0, 20 do
    local inv = items.equipped_at(i)
    if inv then
      if BRC.it.is_ring(inv) then
        if inv.artefact then
          local name = inv.name()
          local idx = name:find("Slay", 1, true)
          if idx then
            local slay = tonumber(name:sub(idx + 5, idx + 5))
            if slay == 1 then
              local next_digit = tonumber(name:sub(idx + 6, idx + 6))
              if next_digit then slay = 10 + next_digit end
            end

            if name:sub(idx + 4, idx + 4) == "+" then
              sum = sum + slay
            else
              sum = sum - slay
            end
          end
        elseif BRC.eq.get_ego(inv) == "Slay" then
          sum = sum + inv.plus
        end
      elseif inv.artefact and (BRC.it.is_armour(inv, true) or BRC.it.is_amulet(inv)) then
        local slay = inv.artprops["Slay"]
        if slay then sum = sum + slay end
      end
    end
  end

  if you.race() == "Demonspawn" then
    sum = sum + 3 * BRC.you.mut_lvl("augmentation")
    sum = sum + BRC.you.mut_lvl("sharp scales")
  end

  return sum
end

local function get_stats_with_item(it, stats)
  local new_stats = util.copy_table(stats)
  local cur = items.equipped_at(it.equip_type)
  if not cur or it.equipped then return new_stats end

  if cur.artefact and BRC.you.num_eq_slots(it) == 1 then
    for k, _ in pairs(new_stats) do
      new_stats[k] = new_stats[k] - (cur.artprops[k] or 0)
    end
  end

  if it.artefact then
    for k, _ in pairs(new_stats) do
      new_stats[k] = new_stats[k] + (it.artprops[k] or 0)
    end
  end

  return new_stats
end

local function get_unadjusted_armour_pen(encumb)
  local pen = encumb - 2 * BRC.you.mut_lvl("sturdy frame")
  if pen > 0 then return pen end
  return 0
end

local function get_adjusted_armour_pen(encumb, str)
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_adjusted_dodge_bonus(encumb, str, dex)
  local size_factor = -2 * BRC.you.size_penalty()
  local dodge_bonus = 8 * (10 + you.skill("Dodging") * dex) / (20 - size_factor) / 10
  local armour_dodge_penalty = get_unadjusted_armour_pen(encumb) - 3
  if armour_dodge_penalty <= 0 then return dodge_bonus end

  if armour_dodge_penalty >= str then return dodge_bonus * str / (armour_dodge_penalty * 2) end
  return dodge_bonus - dodge_bonus * armour_dodge_penalty / (str * 2)
end

local function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Doesn't check brand or delay >=3, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):contains("woodcutter's axe") then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:contains("crossbow") or basename:contains("arbalest")
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

function BRC.eq.arm_stats(it)
  if not BRC.it.is_armour(it) then return "", "" end

  if BRC.it.is_shield(it) then
    local sh_delta, ev_delta = get_delta_sh_ev(it)
    local sh_str = format_stat("SH", sh_delta, it.equipped)
    local ev_str = format_stat("EV", ev_delta, it.equipped)
    return sh_str, ev_str
  else
    local ac_delta, ev_delta = get_delta_ac_ev(it)
    local ac_str = format_stat("AC", ac_delta, it.equipped)
    if not BRC.it.is_body_armour(it) then return ac_str end
    local ev_str = format_stat("EV", ev_delta, it.equipped)
    return ac_str, ev_str
  end
end

function BRC.eq.get_ac(it)
  local it_plus = it.plus or 0

  if it.artefact then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end

  local ac = it.ac * (1 + you.skill("Armour") / 22) + it_plus
  if not BRC.it.is_body_armour(it) then return ac end

  if BRC.you.mut_lvl("deformed body") + BRC.you.mut_lvl("pseudopods") > 0 then ac = ac * 0.6 end

  return ac
end

function BRC.eq.get_armour_ev(it)
  local cur = { Str = you.strength(), Dex = you.dexterity(), EV = 0 }
  local worn = get_stats_with_item(it, cur)

  if worn.Str <= 0 then worn.Str = 1 end
  local bonus = get_adjusted_dodge_bonus(it.encumbrance, worn.Str, worn.Dex)

  if cur.Str <= 0 then cur.Str = 1 end
  local naked_bonus = get_adjusted_dodge_bonus(0, cur.Str, cur.Dex)

  return bonus - naked_bonus + worn.EV - get_adjusted_armour_pen(it.encumbrance, worn.Str)
end

function BRC.eq.get_avg_dmg(it, dmg_type)
  dmg_type = dmg_type or BRC.DMG_TYPE.scoring

  local it_plus = (it.plus or 0) + get_slay_bonuses()
  local stats = { Str = you.strength(), Dex = you.dexterity(), Slay = it_plus }
  stats = get_stats_with_item(it, stats)

  local stat = (it.is_ranged or it.weap_skill:contains("Blades")) and stats.Dex or stats.Str
  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + BRC.you.skill(it.weap_skill) / 50) * (1 + you.skill("Fighting") / 60)
  local base_dmg = it.damage * stat_mod * skill_mod

  if BRC.it.is_magic_staff(it) then
    return base_dmg + stats.Slay + BRC.eq.get_staff_bonus_dmg(it, dmg_type)
  else
    return get_dmg_with_brand_bonus(BRC.eq.get_ego(it), base_dmg, stats.Slay, dmg_type)
  end
end

function BRC.eq.get_ego(it, no_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    ego = ego:lower()
    if BRC.eq.is_useless_ego(ego) or (no_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.it.is_body_armour(it) then
    local name = it.name("qual")
    local good_scales = name:contains("dragon scales") and not name:contains("steam")
    if name:contains("troll leather") or good_scales then return name end
  end

  return it.artefact and it.name() or nil
end

function BRC.eq.get_sh(it)
  local stats = get_stats_with_item(it, { Dex = you.dexterity() })
  local it_plus = it.plus or 0
  local sh_skill = you.skill("Shields")

  local base_sh = it.ac * 2
  local shield = base_sh * (50 + sh_skill * 5 / 2)
  shield = shield + 200 * it_plus
  shield = shield + 38 * (sh_skill + 3 + stats.Dex * (base_sh + 13) / 26)
  return shield / 200
end

function BRC.eq.get_staff_bonus_dmg(it, dmg_type)
  local result = nil
  if dmg_type == BRC.DMG_TYPE.unbranded then result = 0 end
  if dmg_type == BRC.DMG_TYPE.plain then
    local basename = it.name("base")
    if basename ~= "staff of earth" and basename ~= "staff of conjuration" then result = 0 end
  end

  local spell_skill = BRC.you.skill(BRC.it.get_staff_school(it))
  local evo_skill = you.skill("Evocations")

  local chance = (2 * evo_skill + spell_skill) / 30
  if chance > 1 then chance = 1 end
  -- 0.75 is an acceptable approximation; most commonly 63/80
  -- Varies by staff type in sometimes complex ways
  local dmg = 3 / 4 * (evo_skill / 2 + spell_skill)
  result = result or dmg * chance
  return result, dmg, chance
end

function BRC.eq.get_weap_delay(it)
  local delay = it.delay - BRC.you.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.eq.get_ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.it.is_shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

function BRC.eq.is_useless_ego(ego)
  if BRC.MAGIC_SCHOOLS[ego] then
    return BRC.Config.unskilled_egos_usable or you.skill(BRC.MAGIC_SCHOOLS[ego]) > 0
  end

  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
    or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
    or ego == "pain" and you.skill("Necromancy") == 0
end

function BRC.eq.wpn_stats(it, dmg_type, skip_dps)
  if not it.is_weapon then return end
  if not dmg_type then
    -- Default to pulling from inscribe-stats config, if it exists. Else use plain.
    if f_inscribe_stats and f_inscribe_stats.Config then
      if type(f_inscribe_stats.Config.dmg_type) == "string" then
        dmg_type = BRC.DMG_TYPE[f_inscribe_stats.Config.dmg_type]
      else
        dmg_type = f_inscribe_stats.Config.dmg_type
      end
    else
      dmg_type = BRC.DMG_TYPE.plain
    end
  end

  local dmg = format_dmg(BRC.eq.get_avg_dmg(it, dmg_type))
  local delay = BRC.eq.get_weap_delay(it)
  local delay_str = string.format("%.1f", delay)
  if delay < 1 then
    delay_str = string.format("%.2f", delay)
    delay_str = delay_str:sub(2, #delay_str)
  end

  local dps = format_dmg(dmg / delay)
  local acc = it.accuracy + (it.plus or 0)
  if acc >= 0 then acc = "+" .. acc end

  --TODO: This would be nice if it worked in all UIs
  --return string.format("DPS=<w>%s</w> (%s/%s) Ac<w>%s</w>", dps, dmg, delay_str, acc)
  if skip_dps then return string.format("Dmg=%s/%s A%s", dmg, delay_str, acc) end
  return string.format("DPS=%s (%s/%s) A%s", dps, dmg, delay_str, acc)
end

-- BRC.it module
function BRC.it.get_staff_school(it)
  for k, v in pairs(BRC.MAGIC_SCHOOLS) do
    if it.subtype() == k then return v end
  end
end

function BRC.it.is_amulet(it)
  return it and it.name("base") == "amulet"
end

function BRC.it.is_armour(it, include_orbs)
  return it and it.class(true) == "armour" and (include_orbs or not BRC.it.is_orb(it))
end

function BRC.it.is_aux_armour(it)
  return BRC.it.is_armour(it) and not (BRC.it.is_body_armour(it) or BRC.it.is_shield(it))
end

function BRC.it.is_body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.it.is_magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

function BRC.it.is_orb(it)
  return it and it.subtype() == "offhand" and not it.is_shield()
end

function BRC.it.is_ring(it)
  return it and it.name("base") == "ring"
end

function BRC.it.is_scarf(it)
  return BRC.it.is_armour(it) and it.subtype() == "cloak" and it.name():contains("scarf")
end

function BRC.it.is_shield(it)
  return it and it.is_shield()
end

-- BRC.you module
function BRC.you.mut_lvl(mutation, innate_only)
  return you.get_base_mutation_level(mutation, true, not innate_only, not innate_only)
end

function BRC.you.num_eq_slots(it)
  local player_race = you.race()
  if it.is_weapon then return player_race == "Coglin" and 2 or 1 end
  if BRC.it.is_aux_armour(it) then
    if player_race == "Formicid" then return it.subtype() == "gloves" and 2 or 1 end
    return player_race == "Poltergeist" and 6 or 1
  end

  return 1
end

function BRC.you.size_penalty()
  if util.contains(BRC.LITTLE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LITTLE
  elseif util.contains(BRC.SMALL_RACES, you.race()) then
    return BRC.SIZE_PENALTY.SMALL
  elseif util.contains(BRC.LARGE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LARGE
  else
    return BRC.SIZE_PENALTY.NORMAL
  end
end

function BRC.you.skill(skill)
  if skill and not skill:contains(",") then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local max = 0
  for _, s in ipairs(skills) do
    if you.skill(s) > max then max = you.skill(s) end
  end

  return max
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: inscribe-stats
-- @module f_inscribe_stats
-- Inscribes and updates weapon DPS/dmg/delay, and armour AC/EV/SH, for items in inventory.
-- For Coglin weapons, evaluates as if swapping out the primary weapon (for artefact stat changes)
---------------------------------------------------------------------------------------------------



---- Local constants ----
local NUM_PATTERN = "[%+%-:]%d+%.%d*" -- Matches numbers w/ decimal

---- Local variables ----
local C -- config alias

---- Initialization ----
function f_inscribe_stats.init()
  C = f_inscribe_stats.Config
end

---- Local functions ----
local function inscribe_armour_stats(it)
  local abbr = BRC.it.is_shield(it) and "SH" or "AC"
  local ac_or_sh, ev = BRC.eq.arm_stats(it)
  local sign_change = false

  local new_insc
  if it.inscription:find(abbr .. NUM_PATTERN) then
    new_insc = it.inscription:gsub(abbr .. NUM_PATTERN, ac_or_sh)
    if not it.inscription:contains(ac_or_sh:sub(1, 3)) then sign_change = true end

    if ev and ev ~= "" then
      new_insc = new_insc:gsub("EV" .. NUM_PATTERN, ev)
      if not it.inscription:contains(ev:sub(1, 3)) then sign_change = true end
    end
  else
    new_insc = ac_or_sh
    if ev and ev ~= "" then new_insc = string.format("%s, %s", new_insc, ev) end
    if it.inscription and it.inscription ~= "" then
      new_insc = string.format("%s; %s", new_insc, it.inscription)
    end
  end

  it.inscribe(new_insc, false)

  -- If f_color_inscribe is enabled, update the color
  if
    sign_change
    and f_color_inscribe
    and f_color_inscribe.Config
    and not f_color_inscribe.Config.disabled
    and f_color_inscribe.colorize
  then
    f_color_inscribe.colorize(it)
  end
end

local function inscribe_weapon_stats(it)
  local orig_inscr = it.inscription
  local dmg_type = C.dmg_type
  if type(dmg_type) == "string" then
    dmg_type = BRC.DMG_TYPE[dmg_type]
  end

  local dps_inscr = BRC.eq.wpn_stats(it, dmg_type, C.skip_dps)
  if C.prefix_staff_dmg and BRC.it.is_magic_staff(it) then
    local _, dmg, chance = BRC.eq.get_staff_bonus_dmg(it, dmg_type)
    local bonus_str
    if dmg == 0 or chance == 0 then
      bonus_str = "(+0)"
    elseif chance >= 1 then
      bonus_str = string.format("(+%.1f)", dmg)
    else
      bonus_str = string.format("(+%.1f,%d%%%%)", dmg, math.floor(chance * 100))
    end
    dps_inscr = dps_inscr:gsub("/", bonus_str .. "/")
  end

  local prefix, suffix = "", ""
  local idx = orig_inscr:find(dps_inscr:sub(1, 4), 1, true)
  if idx then
    if idx > 1 then prefix = orig_inscr:sub(1, idx - 1) .. "; " end
    if idx + #dps_inscr - 1 < #orig_inscr then
      suffix = orig_inscr:sub(idx + #dps_inscr, #orig_inscr)
    end
  elseif #orig_inscr > 0 then
    suffix = "; " .. orig_inscr
  end

  it.inscribe(table.concat({ prefix, dps_inscr, suffix }), false)
end

---- Crawl hook functions ----
function f_inscribe_stats.do_stat_inscription(it)
  if C.inscribe_weapons and it.is_weapon then
    inscribe_weapon_stats(it)
  elseif C.inscribe_armour
    and BRC.it.is_armour(it)
    and not BRC.it.is_scarf(it)
  then
    inscribe_armour_stats(it)
  end
end

function f_inscribe_stats.ready()
  for _, inv in ipairs(items.inventory()) do
    f_inscribe_stats.do_stat_inscription(inv)
  end
end


-- Crawl hook wrappers
local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_inscribe_stats.ready(...)
  end
end


-- Initialize feature
if f_inscribe_stats.init then f_inscribe_stats.init() end
}
