## Standalone BRC Feature: bread-swinger
## Generated from: lua/features/bread-swinger.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false
BRC.Config.mpr = BRC.Config.mpr or {}
BRC.Config.mpr.show_debug_messages = false
BRC.Config.mpr.logs_to_stderr = false

f_bread_swinger = {}
f_bread_swinger.Config = {
  disabled = false, -- Disable by default
  allow_plant_damage = false, -- Allow damaging plants to rest
  walk_delay = 50, -- ms delay between walk commands. Makes visuals less jarring. 0 to disable
  alert_slow_weap_min = 1.5, -- Alert when finding the slowest weapon yet, starting at this delay
  set_manual_slot_key = string.byte("5") - 64, -- Manually set which weapon slot to swing
  max_heal_perc = 90, -- Stop resting at this percentage of max HP/MP
  emoji = "üçû",

  init = function()
    if not BRC.Config.emojis then
      f_bread_swinger.Config.emoji = "<cyan>---- </cyan>"
    end
  end,
} -- f_bread_swinger.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.BAD_DURATIONS = {
    "berserk", "blind", "confused", "corroded", "diminished spells",
    "marked", "magic-sapped", "short of breath", "sign of ruin", "slowed",
    "sluggish", "tree-form", "vertiginous", "vulnerable", "weakened",
} -- BRC.BAD_DURATIONS (do not remove this comment)

BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.KEYS = { ENTER = 13, ESC = 27, ["Cntl-S"] = 20, ["Cntl-E"] = 5, ["Cntl-5"] = 53 }

BRC.MAGIC_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", chemistry = "Alchemy", cold = "Ice Magic",
  conjuration = "Conjurations", death = "Necromancy", earth = "Earth Magic", fire = "Fire Magic",
  necromancy = "Necromancy",
} -- BRC.MAGIC_SCHOOLS (do not remove this comment)

BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant" }

BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant" }


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.eq = BRC.eq or {}
BRC.it = BRC.it or {}
BRC.mpr = BRC.mpr or {}
BRC.opt = BRC.opt or {}
BRC.txt = BRC.txt or {}
BRC.util = BRC.util or {}
BRC.you = BRC.you or {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.eq module
local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_shield_penalty(sh)
  return 2 * sh.encumbrance * sh.encumbrance
    * (27 - you.skill("Shields")) / 27
    / (25 + 5 * you.strength())
end

local function get_unadjusted_armour_pen(encumb)
  local pen = encumb - 2 * BRC.you.mut_lvl("sturdy frame")
  if pen > 0 then return pen end
  return 0
end

local function get_adjusted_armour_pen(encumb, str)
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Doesn't check brand or delay >=3, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):contains("woodcutter's axe") then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:contains("crossbow") or basename:contains("arbalest")
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

function BRC.eq.get_ego(it, no_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    ego = ego:lower()
    if BRC.eq.is_useless_ego(ego) or (no_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.it.is_body_armour(it) then
    local name = it.name("qual")
    local good_scales = name:contains("dragon scales") and not name:contains("steam")
    if name:contains("troll leather") or good_scales then return name end
  end

  return it.artefact and it.name() or nil
end

function BRC.eq.get_hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  local st = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end

function BRC.eq.get_weap_delay(it)
  local delay = it.delay - BRC.you.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.eq.get_ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.it.is_shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

function BRC.eq.is_useless_ego(ego)
  if BRC.MAGIC_SCHOOLS[ego] then
    return BRC.Config.unskilled_egos_usable or you.skill(BRC.MAGIC_SCHOOLS[ego]) > 0
  end

  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
    or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
    or ego == "pain" and you.skill("Necromancy") == 0
end

-- BRC.it module
function BRC.it.is_body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.it.is_shield(it)
  return it and it.is_shield()
end

-- BRC.mpr module
BRC.mpr.brc_prefix = BRC.txt.darkgrey("[BRC] ")
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, msg_color)
  -- Avoid referencing BRC, to stay robust during startup
  msg_color = msg_color or "lightgrey"
  local msg = BRC.mpr.brc_prefix .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", msg_color, msg, msg_color))
  crawl.flush_prev_message()
end

function BRC.mpr.debug(message, context)
  if BRC.Config.mpr.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Debug) " .. message)
  end
end

function BRC.mpr.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  you.stop_activity()

  if not skip_more then
    crawl.redraw_screen()
    crawl.more()
  end

  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Error) " .. message)
  end
end

function BRC.mpr.info(message, context)
  log_message(message, context, BRC.COL.darkgrey)
end

function BRC.mpr.okay(suffix)
  BRC.mpr.darkgrey("Okay, then." .. (suffix and " " .. suffix or ""))
end

function BRC.mpr.que(msg, color, channel)
  BRC.mpr.que_optmore(false, msg, color, channel)
end

function BRC.mpr.que_optmore(show_more, msg, msg_color, channel)
  for _, q in ipairs(_mpr_queue) do
    if q.m == msg and q.ch == channel and q.more == show_more then return end
  end
  msg_color = msg_color or BRC.COL.lightgrey
  if not msg or #msg == 0 then
    msg = ""
  else
    msg = BRC.txt[msg_color](msg)
  end
  _mpr_queue[#_mpr_queue + 1] = { m = msg, ch = channel, more = show_more }
end

function BRC.mpr.warning(message, context)
  log_message(message, context, BRC.COL.yellow)
  you.stop_activity()
  if BRC.Config.mpr.logs_to_stderr then
    crawl.stderr(BRC.mpr.brc_prefix .. "(Warning) " .. message)
  end
end

function BRC.mpr.yesno(msg, color, capital_only)
  msg = string.format("%s (%s)", msg, capital_only and "Y/N" or "y/n")

  for i = 1, 10 do
    BRC.mpr[color or BRC.COL.lightgrey](msg, "prompt")
    local res = crawl.getch()
    if res and res >= 0 and res <= 255 then
      local c = string.char(res)
      if c == "Y" or c == "y" and not capital_only then return true end
      if c == "N" or c == "n" and not capital_only then return false end
    end
    if i == 1 and capital_only then msg = "[CAPS ONLY] " .. msg end
  end

  BRC.mpr.lightmagenta("Feels like a no.")
  return false
end

-- BRC.opt module
local _claimed_macro_keys = {}

function BRC.opt.macro(key, function_name, overwrite_existing)
  -- Format msg for debugging and keycode for crawl.setopt()
  local key_str = nil
  if type(key) == "number" then
    -- Try to convert to key name for better debug msg
    for k, v in pairs(BRC.KEYS) do
      if v == key then
        key_str = "<<< " .. k .. " >>"
        break
      end
    end
    -- Format keycode string for crawl.setopt()
    key = "\\{" .. key .. "}"
    if key_str == nil then key_str = "<<< \\" .. key .. " >>" end
  end

  -- The << >> formatting protects against crawl thinking '<' is a tag
  if key_str == nil then key_str = "<<< '" .. key .. "' >>" end

  if type(_G[function_name]) == "function" then
    if _claimed_macro_keys[key] and not overwrite_existing then
      BRC.mpr.debug("Macro key %s is already assigned to %s", key_str, _claimed_macro_keys[key])
      return
    end
    crawl.setopt(string.format("macros += M %s ===%s", key, function_name))
    _claimed_macro_keys[key] = function_name
    BRC.mpr.debug(
      string.format(
        "Assigned macro %s to key: %s",
        BRC.txt.magenta(function_name .. "()"),
        BRC.txt.lightred(key_str)
      )
    )
  else
    function_name = _claimed_macro_keys[key]
    if not function_name then
      crawl.mpr("no function name found for key: " .. key)
      return
    end
    crawl.setopt(string.format("macros += M %s %s", key, key))
    _claimed_macro_keys[key] = nil
    BRC.mpr.debug(
      string.format(
        "Cleared macro %s from key: %s",
        BRC.txt.magenta(function_name .. "()"),
        BRC.txt.lightred(key_str)
      )
    )
  end
end

function BRC.opt.message_mute(pattern, create)
  local op = create and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.opt.single_turn_mute(pattern)
  BRC.opt.message_mute(pattern, true)
  _single_turn_mutes[#_single_turn_mutes + 1] = pattern
end

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end


-- BRC.util module
function BRC.util.cntl(c)
  if c >= '0' and c <= '9' or c >= 'a' and c <= 'z' then
    return string.byte(c) - 96
  elseif c >= 'A' and c <= 'Z' then
    return string.byte(c) - 64
  end

  BRC.mpr.error("Unsupported character sent to BRC.util.cntl: %s", c)
  return nil
end

function BRC.util.do_cmd(cmd)
  local key = BRC.util.get_cmd_key(cmd)
  if key then
    crawl.sendkeys({ key })
    crawl.flush_input()
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.get_cmd_key(cmd)
  local key = crawl.get_command(cmd)
  if not key or key == "NULL" then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  return key:contains("Ctrl") and BRC.util.cntl(char_key) or char_key
end

-- BRC.you module
function BRC.you.free_offhand()
  if BRC.you.mut_lvl("missing a hand") > 0 then return true end
  return not items.equipped_at("offhand")
end

function BRC.you.mut_lvl(mutation, innate_only)
  return you.get_base_mutation_level(mutation, true, not innate_only, not innate_only)
end

function BRC.you.skill(skill)
  if skill and not skill:contains(",") then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local max = 0
  for _, s in ipairs(skills) do
    if you.skill(s) > max then max = you.skill(s) end
  end

  return max
end

function BRC.you.unarmed_attack_delay()
  return 1 - you.skill("Unarmed Combat") / 54
end

-- mpr queue support: _mpr_queue and BRC.mpr.consume_queue()
_mpr_queue = {}
function BRC.mpr.consume_queue()
  local do_more = util.exists(_mpr_queue, function(q) return q.more end)
  -- stop_activity() can generate more autopickups, and thus more queue'd messages
  if do_more then
    you.stop_activity()
  end

  for _, msg in ipairs(_mpr_queue) do
    if msg.m and #msg.m > 0 then
      crawl.mpr(tostring(msg.m), msg.ch)
      crawl.flush_prev_message()
    end
  end
  _mpr_queue = {}

  if do_more then
    crawl.redraw_screen()
    crawl.more()
  end
end

-- single turn mutes support: _single_turn_mutes and BRC.opt.clear_single_turn_mutes()
_single_turn_mutes = {}
function BRC.opt.clear_single_turn_mutes()
  util.foreach(_single_turn_mutes, function(m) BRC.opt.message_mute(m, false) end)
  _single_turn_mutes = {}
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: bread-swinger
-- @module f_bread_swinger
-- @author gammafunk, buehler
-- Efficient resting during turncount runs, by wielding slow weapons, or walking back and forth.
-- Based on: https://github.com/gammafunk/dcss-rc/blob/master/speedrun_rest.lua
--
-- Press '5' to rest a variable number of turns. Will swap to slowest weapon in inventory.
-- Press 'cntl-5' to manually set the weapon slot to swing.
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
bs_manual_swing_slot = BRC.Data.persist("bs_manual_swing_slot", nil)
bs_highest_delay = BRC.Data.persist("bs_highest_delay", 0)
bs_highest_delay_1h = BRC.Data.persist("bs_highest_delay_1h", 0)

---- Local constants ----
local CUR_WEAP_BIAS = 0.05 -- Borderline config; don't swap weaps unless delay diff > this
local DIR_TO_VI = {
  [-1] = { [-1] = "y", [0] = "h", [1] = "b" },
  [0] = { [-1] = "k", [1] = "j" },
  [1] = { [-1] = "u", [0] = "l", [1] = "n" },
} -- DIR_TO_VI (do not remove this comment)
local SH_PROMPT = "Unequip shield to rest with "
local FULLY_RECOVERED_MSG = "Fully recovered"

---- Local variables ----
local C -- config alias
local swing_slot
local turns_remaining
local turns_to_rest
local prev_num_turns_to_rest
local rest_type
local wielding
local dir
local removed_shield
local do_overheal

---- Local functions ----
local function has_bad_duration()
  local status = you.status()
  return util.exists(BRC.BAD_DURATIONS, function(x) return status:contains(x) end)
end

local function reset_rest(msg)
  if msg then
    if turns_remaining > 0 and turns_remaining ~= turns_to_rest then
      local diff = turns_to_rest - turns_remaining
      msg = string.format("%s (Rested %s/%s turns)", msg, diff, turns_to_rest)
    end

    if msg:contains(FULLY_RECOVERED_MSG) then
      BRC.mpr.lightgreen(msg)
    else
      BRC.mpr.warning(msg)
    end
  end

  if removed_shield then
    BRC.mpr.que(BRC.txt.lightmagenta("Remember to re-equip your shield after resting!"))
  end

  swing_slot = nil
  turns_remaining = 0
  turns_to_rest = 0
  rest_type = nil
  wielding = false
  dir = { x = nil, y = nil }
  removed_shield = false
  do_overheal = false
end

local function get_num_turns()
  local msg = BRC.txt.white("Enter turns to rest")
  if prev_num_turns_to_rest > 0 then
    msg = msg .. " ([Enter] for " .. BRC.txt.white(prev_num_turns_to_rest) .. " turns)"
  end
  BRC.mpr.lightgrey(msg .. ": ")
  local input = crawl.c_input_line()
  if input == "" then return prev_num_turns_to_rest end

  local turns = tonumber(input)
  if not turns or turns <= 0 then
    return nil
  end
  prev_num_turns_to_rest = turns
  return turns
end

local function do_alert(msg, it)
  local tokens = {}
  tokens[1] = f_bread_swinger.Config.emoji .. " "
  tokens[#tokens + 1] = msg .. ": "
  tokens[#tokens + 1] = BRC.txt.cyan(it.name() .. " (")
  tokens[#tokens + 1] = BRC.txt.lightmagenta(string.format("%.2f", BRC.eq.get_weap_delay(it)))
  tokens[#tokens + 1] = BRC.txt.cyan(") ")
  tokens[#tokens + 1] = f_bread_swinger.Config.emoji
  BRC.mpr.que(table.concat(tokens))
  you.stop_activity()
end

-- Weapon functions
local function weapon_can_swap()
  local weapon = items.equipped_at("Weapon")
  if not weapon then return true end

  if weapon.ego() == "distortion" and you.god() ~= "Lugonu" then return false end

  if weapon.artefact then
    local artp = weapon.artprops
    return not (artp["*Contam"] or artp["*Drain"])
  end

  return true
end

local function get_slowest_slot()
  local slowest_item = nil
  local largest_delay = 0
  local slowest_item_1h = nil
  local largest_delay_1h = 0

  -- Initialize to wielded weapon + BIAS; so we don't swap for an (approximate) equivalent.
  local it = items.equipped_at("Weapon")
  if it and it.class() == "Hand Weapons" then
    local weap_delay = BRC.eq.get_weap_delay(it) + CUR_WEAP_BIAS
    largest_delay = weap_delay
    slowest_item = it
    if BRC.eq.get_hands(it) == 1 then
      largest_delay_1h = weap_delay
      slowest_item_1h = it
    end
  end

  -- Scan inventory for slowest weapon
  for _, item in ipairs(items.inventory()) do
    if item.class() == "Hand Weapons" then
      local weap_delay = BRC.eq.get_weap_delay(item)
      if weap_delay > largest_delay then
        largest_delay = weap_delay
        slowest_item = item
      end
      if BRC.eq.get_hands(item) == 1 and weap_delay > largest_delay_1h then
        largest_delay_1h = weap_delay
        slowest_item_1h = item
      end
    end
  end
  if not slowest_item then return nil end

  -- Often is more efficient to unequip shield and rest with a slower 2-handed weapon.
  if not BRC.you.free_offhand() and BRC.eq.get_hands(slowest_item) > 1 then
    local msg = BRC.txt.white(SH_PROMPT .. BRC.txt.lightcyan(slowest_item.name("db")) .. "?")
    if BRC.mpr.yesno(msg) then
      items.equipped_at("offhand").remove()
      removed_shield = true
    elseif slowest_item_1h then
      slowest_item = slowest_item_1h
    else
      return nil
    end
  end

  return items.index_to_letter(slowest_item.slot)
end

local function swing_item_wielded()
  local weapon = items.equipped_at("Weapon")
  if not weapon and not swing_slot then return true end
  if not weapon or not swing_slot then return false end
  return weapon.slot == items.letter_to_index(swing_slot)
end

local function wield_swing_item()
  if not swing_slot then return end
  wielding = true
  BRC.opt.single_turn_mute("You unwield ")
  BRC.opt.single_turn_mute(swing_slot .. " - ")
  crawl.sendkeys({ "w", "*", swing_slot })
  crawl.flush_input()
end

-- Feature checks
local function is_water(x, y)
  local feat = view.feature_at(x, y)
  return feat and feat:contains("water") and not you.status("flying")
end

local function is_monster(x, y)
  local mon = monster.get_monster_at(x, y)
  return mon and not (C.allow_plant_damage and mon.is_stationary())
end

-- Setting direction to move or swing
local function is_good_dir_walk(x, y)
  if x == 0 and y == 0 then return false end
  return is_water(x, y) == is_water(0, 0)
    and view.is_safe_square(x, y)
    and not travel.feature_solid(view.feature_at(x, y))
    and not monster.get_monster_at(x, y)
end

local function is_good_dir_swing(x, y)
  if x == 0 and y == 0 then return false end
  if not view.in_known_map_bounds(x, y) then return false end

  local weapon = items.equipped_at("Weapon")
  if weapon then
    if weapon.is_ranged then
      -- Confirm no monsters in straight line
      for i = 1, you.los() do
        local cur_x = i * x
        local cur_y = i * y
        if is_monster(cur_x, cur_y) then return false end
        if travel.feature_solid(view.feature_at(cur_x, cur_y)) then break end
      end
    end

    if weapon.weap_skill:contains("Axes") then
      -- Confirm no monsters in adjacent squares
      for cur_x = -1, 1 do
        for cur_y = -1, 1 do
          if is_monster(cur_x, cur_y) then return false end
        end
      end
    end
  end

  return not (travel.feature_solid(view.feature_at(x, y)) or is_monster(x, y))
end

local function get_good_direction()
  local func_is_good_dir = rest_type == "walk" and is_good_dir_walk or is_good_dir_swing
  for x = -1, 1 do
    for y = -1, 1 do
      if func_is_good_dir(x, y) then return x, y end
    end
  end
  return nil
end

local function set_good_direction()
  if rest_type == "walk" and dir.x ~= nil then
    -- Try to move back and forth by saving next dir
    if is_good_dir_walk(dir.x, dir.y) then return true end
    dir.x = nil
  end
  if dir.x == nil or not is_good_dir_swing(dir.x, dir.y) then
    dir.x, dir.y = get_good_direction()
    if not dir.x then
      reset_rest("No good direction found!")
      return false
    end
  end

  return true
end

-- Resting
local function set_rest_type()
  local inv = swing_slot and items.inslot(items.letter_to_index(swing_slot))
  local weap_delay = inv and BRC.eq.get_weap_delay(inv) or BRC.you.unarmed_attack_delay()
  if (not swing_item_wielded() and not weapon_can_swap())
    or you.movement_cost and you.movement_cost() > 10 * weap_delay
  then
    rest_type = "walk"
  elseif weap_delay > 1 then
    rest_type = "item"
  else
    rest_type = "wait"
  end
end

local function verify_safe_rest()
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  mhp = mhp * C.max_heal_perc / 100
  mmp = mmp * C.max_heal_perc / 100
  if hp >= mhp and mp >= mmp and not has_bad_duration() and not do_overheal then
    if turns_remaining == turns_to_rest then
      if BRC.mpr.yesno("You're healthy enough! Rest anyway?", BRC.COL.yellow) then
        do_overheal = true
        return true
      else
        BRC.mpr.okay()
        reset_rest()
        return false
      end
    end

    reset_rest(FULLY_RECOVERED_MSG)
    return false
  end

  if not you.feel_safe() then
    reset_rest("Hostile monster in view!")
    return false
  elseif rest_type == "walk" then
    if you.status("barbs") then
      reset_rest("You must remove the barbs first.")
      return false
    end
  end
  return true
end

local function do_resting()
  if not set_good_direction() then return end
  if f_announce_hp_mp then f_announce_hp_mp.single_turn_mute() end

  if rest_type == "wait" then
    BRC.util.do_cmd("CMD_SAFE_WAIT")
  elseif rest_type == "item" then
    BRC.opt.single_turn_mute("You swing at nothing.")
    BRC.opt.single_turn_mute("You shoot ")
    BRC.opt.single_turn_mute("unstable footing causes you to fumble your attack")
    crawl.sendkeys({ BRC.util.cntl(DIR_TO_VI[dir.x][dir.y]) })
    crawl.flush_input()
  else
    -- Save the return direction as our next direction
    local cur_x = dir.x
    local cur_y = dir.y
    dir.x = -dir.x
    dir.y = -dir.y
    crawl.sendkeys({ DIR_TO_VI[cur_x][cur_y] })
    crawl.flush_input()

    if C.walk_delay > 0 then crawl.delay(C.walk_delay) end
  end

  turns_remaining = turns_remaining - 1
  if turns_remaining <= 0 then
    BRC.mpr.green("Resting complete. (" .. turns_to_rest .. " turns)")
    reset_rest()
  end
end

--- Checks if weapon has slowest swing speed. Returns 2 if slowest, and 1 for slowest 1-handed.
local function is_slowest_weapon(it)
  if not it or it.is_useless or not it.is_weapon then return nil end
  local delay = BRC.eq.get_weap_delay(it)
  if delay < C.alert_slow_weap_min then return nil end

  if delay > bs_highest_delay then
    bs_highest_delay = delay
    if BRC.eq.get_hands(it) == 1 then bs_highest_delay_1h = delay end
    return 2
  elseif delay > bs_highest_delay_1h and BRC.eq.get_hands(it) == 1 then
    bs_highest_delay_1h = delay
    return 1
  end
end

---- Public API ----
function macro_brc_bread_swing(turns)
  if BRC.active == false or f_bread_swinger.Config.disabled then
    return BRC.util.do_cmd("CMD_REST")
  end

  if not verify_safe_rest() then return end

  turns_to_rest = turns or get_num_turns()
  if not turns_to_rest or turns_to_rest <= 0 then
    return
  end
  turns_remaining = turns_to_rest

  -- Set swing slot
  swing_slot = bs_manual_swing_slot or get_slowest_slot()
  if swing_slot then
    local weap = items.inslot(items.letter_to_index(swing_slot))
    if not weap or not weap.is_weapon then
      BRC.mpr.warning("Swing slot " .. BRC.txt.lightmagenta(swing_slot) .. " is not a weapon!")
      return
    end
  end

  -- Determine rest type
  set_rest_type()
  if rest_type == "walk" and turns_to_rest % 2 == 1 then
    turns_to_rest = turns_to_rest - 1
    turns_remaining = turns_remaining - 1
  end

  f_bread_swinger.ready()
end

function macro_brc_set_swing_slot()
  BRC.mpr.info(BRC.txt.white("Enter the inventory slot") .. " for the swing item: ")
  local letter = crawl.getch()
  if not letter or letter < string.byte('A') or letter > string.byte('z') then
    bs_manual_swing_slot = nil
    BRC.mpr.info(BRC.txt.magenta("Swing slot cleared.") .. " (Must be a letter a-z or A-Z).")
    return
  end
  bs_manual_swing_slot = string.char(letter)
  BRC.mpr.info(BRC.txt.lightgrey("Set swing slot to " .. BRC.txt.cyan(bs_manual_swing_slot) .. "."))
end

---- Initialization ----
function f_bread_swinger.init()
  C = f_bread_swinger.Config
  prev_num_turns_to_rest = 0
  reset_rest()
  BRC.opt.macro(BRC.util.get_cmd_key("CMD_REST") or "5", "macro_brc_bread_swing", true)
  BRC.opt.macro(C.set_manual_slot_key, "macro_brc_set_swing_slot", true)

  for _, it in ipairs(items.inventory()) do
    is_slowest_weapon(it)
  end
end

---- Crawl hook functions ----
function f_bread_swinger.c_message(text, channel)
  -- Don't stop for expiring effects or removing shield
  if turns_remaining <= 0
    or channel == "recovery"
    or channel == "duration"
    or text:find("Your magical contamination .* fade")
    or removed_shield and text:find("You .* removing your") or text:contains(SH_PROMPT)
  then return end

  reset_rest()
end

function f_bread_swinger.ready()
  if not turns_remaining or turns_remaining <= 0 then
    reset_rest()
    return
  end
  if not verify_safe_rest() then return end

  if wielding and not swing_item_wielded() then
    -- An error happened with the 'w' command
    reset_rest("Unable to wield swing item on slot " .. swing_slot .. "!")
    return
  end

  if rest_type == "item" and not swing_item_wielded() then
    wield_swing_item()
  else
    do_resting()
  end
end

function f_bread_swinger.autopickup(it)
  local num_hands = is_slowest_weapon(it)
  if num_hands == 2 then
    do_alert("Found slowest weapon", it)
  elseif num_hands == 1 then
    do_alert("Found slowest 1-handed weapon", it)
  end
end


-- Crawl hook wrappers
add_autopickup_func(f_bread_swinger.autopickup)

function c_message(...)
  return f_bread_swinger.c_message(...)
end

local brc_last_turn = -1
function ready(...)
  BRC.opt.clear_single_turn_mutes()
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_bread_swinger.ready(...)
  end
  BRC.mpr.consume_queue()
end


-- Initialize feature
if f_bread_swinger.init then f_bread_swinger.init() end
}
