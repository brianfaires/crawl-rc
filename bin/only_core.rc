## BRC Core files - Copy/paste any features above this line.

################################### Begin lua/core/config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Configuration - Various configs, overriding default values in feature configs.
Author: buehler
Dependencies: (none)
Usage:
  - Update BRC.config_to_use to load the corresponding config.
  - Update each config or create new ones.
  - Values that aren't defined will first fall back to Configs.Default, then to the defaults defined in feature configs.
  - Define `init = function(self) ... end` in a config to run code after it loads. (use self to access the config table)
--]]

-- Initialize BRC namespace and Public modules
BRC = BRC or {}
BRC.Configs = {}
BRC.config_to_use = "Speed"

-- Default: Values to always apply, unless
BRC.Configs.Default = {
  emojis = false, -- Use emojis in alerts and announcements
  show_debug_messages = false,
  offer_debug_notes_on_char_dump = true,
} -- BRC.Configs.Default (do not remove this comment)
BRC.Config = BRC.Configs.Default

-- Testing: Cherry-pick settings to test specific features
BRC.Configs.Testing = {
  show_debug_messages = true,
  ["pickup-alert"] = {
    Alert = {
      armour_sensitivity = 0.1,
      weapon_sensitivity = 0.1,
    },
  },
} -- BRC.Configs.Testing (do not remove this comment)

-- Custom: Personalized config
BRC.Configs.Custom = {
  ["misc-alerts"] = {
    alert_low_hp_threshold = 0.35, -- % max HP to alert; 0 to disable
  },
  ["announce-hp-mp"] = {
    dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
    dmg_fm_threshold = 0.30,    -- Force more for losing this % of max HP
    always_on_bottom = false,   -- Rewrite HP/MP meters after each turn with messages
  },
  ["inscribe-stats"] = {
    inscribe_weapons = true, -- Inscribe weapon stats on pickup and adjust each turn
    inscribe_armour = true,  -- Inscribe armour stats on pickup and adjust each turn
  },
  ["remind-id"] = {
    stop_on_scrolls_count = 2, -- Stop when largest un-ID'd scroll stack increases and is >= this
    stop_on_pots_count = 3,    -- Stop when largest un-ID'd potion stack increases and is >= this
  },
  ["runrest-features"] = {
    ignore_portal_exits = true, -- don't stop explore on portal exits
    temple_search = true,       -- on enter or explore, auto-search altars
    gauntlet_search = true,     -- on enter or explore, auto-search gauntlet with filters
  },
  ["startup"] = {
    show_skills_on_startup = false, -- Open skills menu on startup
    auto_set_skill_targets = {
      { "Stealth", 2.0 },  -- First, focus stealth to 2.0
      { "Fighting", 2.0 }, -- If already have stealth, focus fighting to 2.0
    },
  },
  ["pickup-alert"] = {
    Pickup = {
      armour = true,
      staves = true,
      weapons = true,
      weapons_pure_upgrades_only = true, -- Only pick up better versions of same exact weapon
    },

    Alert = {
      armour_sensitivity = 0.1, -- Adjust all armour alerts; range [0.5-2.0]; 0 = disable all armour alerts
      weapon_sensitivity = 0.1, -- Adjust all weapon alerts; range [0.5-2.0]; 0 = disable all weapon alerts
      orbs = true,
      staff_resists = true, -- When a staff gives a missing resistance
      talismans = true,

      one_time = { -- Alert the first time each itemis found
        "wand of digging", "buckler", "kite shield", "tower shield", "crystal plate armour",
        "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales",
        "quick blade", "demon blade", "eudemon blade", "double sword", "triple sword",
        "broad axe", "executioner's axe",
        "demon whip", "eveningstar", "giant spiked club", "morningstar", "sacred scourge",
        "lajatang", "bardiche", "demon trident", "partisan", "trishula", "hand cannon", "triple crossbow",
      },
      OTA_require_skill = { weapon = 2, armour = 2.5, shield = 0 }, -- One-time alert only when skill level >= this

      More = { -- Which alerts generate a force_more_message (some categories overlap)
        early_weap = false,       -- Good weapons found early
        upgrade_weap = false,     -- Better DPS / weapon_score
        weap_ego = false,         -- New or diff egos
        body_armour = false,
        shields = true,
        aux_armour = false,
        armour_ego = true,        -- New or diff egos
        high_score_weap = false,  -- Highest damage found
        high_score_armour = true, -- Highest AC found
        one_time_alerts = true,
        artefact = false,         -- Any artefact
        trained_artefacts = true, -- Artefacts where you have corresponding skill > 0
        orbs = false,
        talismans = you.class() == "Shapeshifter", -- True for shapeshifter, false for everyone else
        staff_resists = false,
      },
    },
  },

  ---- BRC.Config.BrandBonus: Tune the impact of brands on DPS calculations
  -- This applies to weapon inscriptions, and item comparisons in the pickup-alert system.
  -- Uses "terse" ego names, e.g. "spect" instead of "spectralizing"
  BrandBonus = {
    chaos = { factor = 1.15, offset = 2.0 }, -- Approximate weighted average
    distort = { factor = 1.0, offset = 6.0 },
    drain = { factor = 1.25, offset = 2.0 },
    elec = { factor = 1.0, offset = 4.5 },   -- 3.5 on avg; fudged up for AC pen
    flame = { factor = 1.25, offset = 0 },
    freeze = { factor = 1.25, offset = 0 },
    heavy = { factor = 1.8, offset = 0 },    -- Speed is accounted for elsewhere
    pain = { factor = 1.0, offset = you.skill("Necromancy") / 2 },
    spect = { factor = 1.7, offset = 0 },    -- Fudged down for increased incoming damage
    venom = { factor = 1.0, offset = 5.0 },  -- 5 dmg per poisoning

    subtle = { -- Values estimated for weapon comparisons
      antimagic = { factor = 1.1, offset = 0 },
      holy = { factor = 1.15, offset = 0 },
      penet = { factor = 1.3, offset = 0 },
      protect = { factor = 1.15, offset = 0 },
      reap = { factor = 1.3, offset = 0 },
      vamp = { factor = 1.2, offset = 0 },
    },
  },
} -- BRC.Configs.Custom (do not remove this comment)

BRC.Configs.Speed = {
  ["alert-monsters"] = {
    fm_on_uniques = false,
    Alerts = {},
  },
  ["announce-hp-mp"] = {
    dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
    dmg_fm_threshold = 1,    -- Force more for losing this % of max HP
    always_on_bottom = true,   -- Rewrite HP/MP meters after each turn with messages
  },
  ["remind-id"] = {
    stop_on_scrolls_count = 99, -- Stop when largest un-ID'd scroll stack increases and is >= this
    stop_on_pots_count = 99,    -- Stop when largest un-ID'd potion stack increases and is >= this
  },
  ["pickup-alert"] = {
    Pickup = {
      armour = true,
      staves = true,
      weapons = true,
      weapons_pure_upgrades_only = false, -- Only pick up better versions of same exact weapon
    },

    Alert = {
      armour_sensitivity = 1.1, -- Adjust all armour alerts; range [0.5-2.0]; 0 = disable all armour alerts
      weapon_sensitivity = 1.2, -- Adjust all weapon alerts; range [0.5-2.0]; 0 = disable all weapon alerts
      orbs = false,
      staff_resists = false, -- When a staff gives a missing resistance
      talismans = false,

      one_time = { -- Alert the first time each itemis found
        "kite shield", "tower shield", "crystal plate armour",
        "gold dragon scales", "pearl dragon scales", "storm dragon scales",
        "broad axe", "demon whip", "eveningstar", "morningstar",
      },
      OTA_require_skill = { weapon = 6, armour = 0, shield = 0 }, -- One-time alert only when skill level >= this

      More = { }, -- All nil / false
    },
    Tuning = {
      Armour = {
        encumb_penalty_weight = 0, -- Penalizes heavier armour when training spellcasting/ranged. 0 to disable
        early_xl = 0, -- Alert all usable runed body armour if XL <= `early_xl`
      },
    },
  },
  ["startup"] = {
    show_skills_on_startup = false, -- Open skills menu on startup
    auto_set_skill_targets = {
      { (you.skill("Axes") > you.skill("Maces & Flails")) and "Axes" or "Maces & Flails", 6.0 },
    },
  },

  init = function(self)
    self.startup.auto_set_skill_targets = { { BRC.get.preferred_weapon_type(), 8.0 } }
  end
} -- BRC.Configs.Speed (do not remove this comment)

BRC.Configs.Turncount = {

} -- BRC.Configs.Turncount (do not remove this comment)

BRC.Configs.Streak = {

} -- BRC.Configs.Streak (do not remove this comment)

}
############################### End lua/core/config.lua ###############################
##########################################################################################

################################### Begin lua/core/constants.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Constants - All constant definitions
Author: buehler
Dependencies: (none)
--]]

-- Initialize BRC namespace
BRC = BRC or {}

---- Cosmetic settings
BRC.EMOJI = {
  CAUTION = BRC.Config.emojis and "⚠️" or "<yellow>!</yellow>",
  EXCLAMATION = BRC.Config.emojis and "❗" or "<magenta>!</magenta>",
  EXCLAMATION_2 = BRC.Config.emojis and "‼️" or "<lightmagenta>!!</lightmagenta>",
  SUCCESS = BRC.Config.emojis and "✅" or nil,
} -- BRC.EMOJI (do not remove this comment)

---- Items ----
BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine", "horn of Geryon",
  "lightning rod", "phantom mirror", "phial of floods", "sack of spiders", "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

-- This is checked against the full text of the pickup message, so use patterns to match
BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)

-- Could be removed after https://github.com/crawl/crawl/issues/4606 is addressed
BRC.SPELLBOOKS = {
  "parchment of", "book of", "Necronomicon", "Grand Grimoire", "tome of obsoleteness",
  "Everburning Encyclopedia", "Ozocubu's Autobiography", "Maxwell's Memoranda",
  "Young Poisoner's Handbook", "Fen Folio", "Inescapable Atlas", "There-And-Back Book",
  "Great Wizards, Vol. II", "Great Wizards, Vol. VII", "Trismegistus Codex",
  "the Unrestrained Analects", "Compendium of Siegecraft", "Codex of Conductivity",
  "Handbook of Applied Construction", "Treatise on Traps", "My Sojourn through Swampland",
  "Akashic Record",
  -- Include prefixes for randart books
  "Almanac", "Anthology", "Atlas", "Book", "Catalogue", "Codex", "Compendium",
  "Compilation", "Cyclopedia", "Directory", "Elucidation", "Encyclopedia", "Folio",
  "Grimoire", "Handbook", "Incunable", "Incunabulum", "Octavo", "Omnibus", "Papyrus",
  "Parchment", "Precepts", "Quarto", "Secrets", "Spellbook", "Tome", "Vellum", "Volume",
} -- BRC.SPELLBOOKS (do not remove this comment)

---- Races ----
BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant", }
BRC.NONLIVING_RACES = { "Djinni", "Gargoyle", }
BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant", }
BRC.LITTLE_RACES = { "Spriggan", }
BRC.SMALL_RACES = { "Kobold", }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll", }

---- Skills ----
BRC.STAFF_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", necromancy = "Necromancy",
  earth = "Earth Magic", fire = "Fire Magic", conjuration = "Conjurations",
} -- BRC.STAFF_SCHOOLS (do not remove this comment)

BRC.TRAINING_SKILLS = {
  "Air Magic", "Alchemy", "Armour", "Axes", "Conjurations", "Dodging", "Earth Magic", "Evocations", "Fighting",
  "Fire Magic", "Forgecraft", "Hexes", "Ice Magic", "Invocations", "Long Blades", "Maces & Flails", "Necromancy",
  "Polearms", "Ranged Weapons", "Shapeshifting", "Shields", "Short Blades", "Spellcasting", "Staves", "Stealth",
  "Summonings", "Translocations", "Unarmed Combat", "Throwing",
} -- BRC.TRAINING_SKILLS (do not remove this comment)

BRC.WEAP_SCHOOLS = {
  "axes", "maces & flails", "polearms", "long blades", "short blades", "staves", "unarmed combat", "ranged weapons",
} -- BRC.WEAP_SCHOOLS (do not remove this comment)

---- Branches ----
BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar", }
BRC.PORTAL_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "Ice Cave", "Necropolis",
  "Ossuary", "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_NAMES (do not remove this comment)

---- Egos + artefact properties ----
BRC.BAD_ART_PROPS = { "Bane", "*Corrode", "*Noise", "*Rage", "*Silence", "*Slow", "*Tele", "-Cast", "-Move", "-Tele", }
BRC.RISKY_EGOS = { "antimagic", "chaos", "distort", "harm", "heavy", "Infuse", "Ponderous", }
BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect", }

---- Other ----
-- BRC.COLOR:Would prefer to use integer values, but they don't work in all menus
BRC.COLOR = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COLOR (do not remove this comment)

BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg with no associated damage type
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.KEYS = { LF = string.char(10), CR = string.char(13), }

BRC.MUTATIONS = {
  antennae = "antennae", augmentation = "augmentation", beak = "beak", claws = "claws", deformed = "deformed body",
  demonic_touch = "demonic touch", hooves = "hooves", horns = "horns", missing_hand = "missing a hand",
  pseudopods = "pseudopods", sharp_scales = "sharp scales", sturdy_frame = "sturdy frame", talons = "talons",
} -- BRC.MUTATIONS (do not remove this comment)

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2, }

}
############################### End lua/core/constants.lua ###############################
##########################################################################################

################################### Begin lua/core/util.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Utility Functions - All utility functions organized into logical tables
Author: buehler
Dependencies: core/config.lua, core/constants.lua
--]]

-- Initialize BRC namespace
BRC = BRC or {}

-- Local variables
local _mpr_queue = {}

-- Local constants
local SPECIAL_CHARS = table.concat({ "(", "[", "%", "^", "$", "(", ")", "%", ".", "[", "]", "*", "+", "-", "?", ")" })

-- Local functions
local function log_message(message, context, color)
  color = color or BRC.COLOR.lightgrey
  local msg = string.format("[BRC] %s", tostring(message))
  if context then msg = string.format("%s (%s)", msg, context) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

local function serialize_chk_lua_save()
  local tokens = { "\n---CHK_LUA_SAVE---" }
  for _, func in ipairs(chk_lua_save) do
    tokens[#tokens + 1] = util.trim(func())
  end

  return table.concat(tokens, "\n")
end

local function serialize_inventory()
  local tokens = { "\n---INVENTORY---\n" }
  for inv in iter.invent_iterator:new(items.inventory()) do
    tokens[#tokens + 1] = string.format("%s: (%s) Qual: %s", inv.slot, inv.quantity, inv.name("qual"))
    local base = inv.name("base") or "N/A"
    local cls = inv.class(true) or "N/A"
    local st = inv.subtype() or "N/A"
    tokens[#tokens + 1] = string.format("  Base: %s Class: %s, Subtype: %s\n", base, cls, st)
  end

  return table.concat(tokens)
end

local function serialize_config()
  local tokens = { "\n---BRC Config---\n" .. BRC.util.tostring(BRC.Config) }
  for name, feature in pairs(BRC.get_registered_features()) do
    if feature.Config then
      tokens[#tokens + 1] = "\n\n---Feature Config: " .. name .. "---\n" .. BRC.util.tostring(feature.Config)
    end
  end

  return table.concat(tokens)
end

-----------------------------------
---- BRC.log - Logging methods ----
BRC.log = {}

function BRC.log.error(message, context)
  log_message("(Error) " .. message, context, BRC.COLOR.lightred)
  you.stop_activity()
  crawl.redraw_screen()
  crawl.more()
  crawl.redraw_screen()
end

function BRC.log.warning(message, context)
  log_message(message, context, BRC.COLOR.yellow)
  you.stop_activity()
end

function BRC.log.info(message, context)
  log_message(message, context, BRC.COLOR.white)
end

function BRC.log.debug(message, context)
  if not BRC.Config.show_debug_messages then return end
  log_message(message, context, BRC.COLOR.lightblue)
end

---------------------------------------------------
---- BRC.text - Text color + parsing functions ----
BRC.text = {}

-- Remove tags from text, and optionally escape special characters
function BRC.text.clean(text, escape_chars)
  text = text:gsub("\n", "")
  if escape_chars then text = text:gsub(SPECIAL_CHARS, "%%%1") end
  return text:gsub("<[^>]*>", "")
end

-- Wrap text in a color tag, Usage: BRC.text.blue("Hello"), or BRC.text["1"]("Hello")
for k, v in pairs(BRC.COLOR) do
  BRC.text[k] = function(text)
    return string.format("<%s>%s</%s>", v, tostring(text), v)
  end
  BRC.text[v] = BRC.text[k]
end

function BRC.text.color(color, text)
  return color and BRC.text[color](text) or tostring(text)
end

function BRC.text.contains(self, text)
  return self:find(text, 1, true) ~= nil
end

-- Connect string:contains() to BRC.text.contains()
getmetatable("").__index.contains = BRC.text.contains

function BRC.text.get_pickup_info(text)
  local cleaned = BRC.text.clean(text, false)
  if cleaned:sub(2, 4) ~= " - " then return nil end
  return { slot = items.letter_to_index(cleaned:sub(1, 1)), item = cleaned:sub(5, #cleaned) }
end

---------------------------------------------
---- BRC.mpr - Wrappers around crawl.mpr ----
BRC.mpr = {}

-- Output message in color. Usage: BRC.mpr.white("Hello"), or BRC.mpr["15"]("Hello")
for k, v in pairs(BRC.COLOR) do
  BRC.mpr[k] = function(text, channel)
    crawl.mpr(BRC.text.color(v, text), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.color(text, color, channel)
  if color then
    BRC.mpr[color](text, channel)
  else
    crawl.mpr(tostring(text), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.okay(suffix)
  BRC.mpr.darkgrey("Okay, then." .. (suffix and " " .. suffix or ""))
end

-- Message plus stop travel/activity
function BRC.mpr.stop(text, color, channel)
  BRC.mpr.color(text, color, channel)
  you.stop_activity()
end

-- Message as a force_more_message
function BRC.mpr.more(text, color, channel)
  BRC.mpr.color(text, color, channel)
  you.stop_activity()
  crawl.redraw_screen()
  crawl.more()
  crawl.redraw_screen()
end

-- Conditional force_more_message
function BRC.mpr.optmore(show_more, text, color, channel)
  if show_more then
    BRC.mpr.more(text, color, channel)
  else
    BRC.mpr.color(text, color, channel)
  end
end

-- Queue the message, to dispay at start of next turn
function BRC.mpr.que(text, color, channel)
  for _, msg in ipairs(_mpr_queue) do
    if msg.text == text and msg.channel == channel then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { text = BRC.text.color(color, text), channel = channel, show_more = false }
end

-- Queue msg w/ conditional force_more_message
function BRC.mpr.que_optmore(show_more, text, color, channel)
  for _, msg in ipairs(_mpr_queue) do
    if msg.text == text and msg.channel == channel and msg.show_more == show_more then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { text = BRC.text.color(color, text), channel = channel, show_more = show_more }
end

-- Display queued messages and clear the queue
function BRC.mpr.consume_queue()
  local do_more = false
  for _, msg in ipairs(_mpr_queue) do
    crawl.mpr(tostring(msg.text), msg.channel)
    crawl.flush_prev_message()
    if msg.show_more then do_more = true end
  end

  if do_more then
    you.stop_activity()
    crawl.redraw_screen()
    crawl.more()
    crawl.redraw_screen()
  end

  _mpr_queue = {}
end

-- Get a yes/no response
function BRC.mpr.yesno(text, color, capital_only)
  local msg = string.format("%s (%s)", text, capital_only and "Y/N" or "y/n")
  local MAX_TRIES = 10

  for i = 1, MAX_TRIES do
    crawl.formatted_mpr(BRC.text.color(color, msg), "prompt")
    local res = crawl.getch()
    if res and res >= 0 and res <= 255 then
      if string.char(res) == "Y" or string.char(res) == "y" and not capital_only then return true end
      if string.char(res) == "N" or string.char(res) == "n" and not capital_only then return false end
    end
    if i == 1 and capital_only then msg = "[CAPS ONLY] " .. msg end
  end

  BRC.mpr.lightmagenta("Feels like a no.")
  return false
end

-----------------------------------------------------
---- BRC.get - Functions to get non-boolean data ----
BRC.get = {}

function BRC.get.num_equip_slots(it)
  local player_race = you.race()
  if it.is_weapon then return player_race == "Coglin" and 2 or 1 end
  if BRC.is.aux_armour(it) then
    if player_race == "Formicid" then return it.subtype() == "gloves" and 2 or 1 end
    return player_race == "Poltergeist" and 6 or 1
  end

  return 1
end

function BRC.get.command_key(cmd)
  local key = crawl.get_command(cmd)
  if not key then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  if key:contains("Ctrl") then return BRC.util.control_key(char_key) end
  return char_key
end

--[[
BRC.get.equipped_at() - Returns 2 values (usually a list of length 1, with num_slots==1):
  1. A list of equipped items at the same slot as the item
  2. the num_slots (ie maximum size the list can ever be)
--]]
function BRC.get.equipped_at(it)
  local all_aux = {}
  local num_slots = BRC.get.num_equip_slots(it)
  local slot_name = it.is_weapon and "weapon" or BRC.is.body_armour(it) and "armour" or it.subtype()
  for i = 1, num_slots do
    local eq = items.equipped_at(slot_name, i)
    all_aux[#all_aux + 1] = eq
  end
  return all_aux, num_slots
end

function BRC.get.mut(mutation, include_all)
  return you.get_base_mutation_level(mutation, true, include_all, include_all)
end

function BRC.get.preferred_weapon_type()
  local max_weap_skill = 0
  local pref = nil
  for _, v in ipairs(BRC.WEAP_SCHOOLS) do
    if BRC.get.skill(v) > max_weap_skill then
      max_weap_skill = BRC.get.skill(v)
      pref = v
    end
  end
  return pref
end

function BRC.get.skill(skill)
  if skill and not skill:contains(",") then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local sum = 0
  local count = 0
  for _, s in ipairs(skills) do
    sum = sum + you.skill(s)
    count = count + 1
  end
  return sum / count
end

function BRC.get.skill_with(it)
  if BRC.is.magic_staff(it) then return math.max(BRC.get.skill(BRC.get.staff_school(it)), BRC.get.skill("Staves")) end
  if it.is_weapon then return BRC.get.skill(it.weap_skill) end
  if BRC.is.body_armour(it) then return BRC.get.skill("Armour") end
  if BRC.is.shield(it) then return BRC.get.skill("Shields") end
  if BRC.is.talisman(it) then return BRC.you.shapeshifting_skill() end

  BRC.log.error("Unknown skill for item: " .. it.name())
end

function BRC.get.staff_school(it)
  for k, v in pairs(BRC.STAFF_SCHOOLS) do
    if it.subtype() == k then return v end
  end
end

function BRC.get.talisman_min_level(it)
  if it.name() == "protean talisman" then return 6 end

  -- Parse the item description
  local tokens = crawl.split(it.description, "\n")
  for _, v in ipairs(tokens) do
    if v:sub(1, 4) == "Min " then
      local start_pos = v:find("%d", 4)
      if start_pos then
        local end_pos = v:find("[^%d]", start_pos)
        return tonumber(v:sub(start_pos, end_pos - 1))
      end
    end
  end

  BRC.log.error("Failed to find skill required for: " .. it.name())
  return -1
end

------------------------------------------
---- BRC.is - Boolean checks of items ----
BRC.is = {}

function BRC.is.amulet(it)
  return it and it.name("base") == "amulet"
end

function BRC.is.armour(it, include_orbs)
  -- exclude orbs by default
  if not it or it.class(true) ~= "armour" then return false end
  if not include_orbs and BRC.is.orb(it) then return false end
  return true
end

function BRC.is.aux_armour(it)
  return BRC.is.armour(it) and not (BRC.is.body_armour(it) or BRC.is.shield(it))
end

function BRC.is.body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.is.jewellery(it)
  return it and it.class(true) == "jewellery"
end

function BRC.is.list(value)
  return value and type(value) == "table" and #value > 0
end

function BRC.is.magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

function BRC.is.map(value)
  return value and type(value) == "table" and next(value) ~= nil and #value == 0
end

function BRC.is.ring(it)
  return it and it.name("base") == "ring"
end

function BRC.is.scarf(it)
  return it and it.class(true) == "armour" and it.subtype() == "cloak" and it.name():contains("scarf")
end

function BRC.is.shield(it)
  return it and it.is_shield()
end

function BRC.is.talisman(it)
  if not it then return false end
  local c = it.class(true)
  return c and (c == "talisman" or c == "bauble")
end

function BRC.is.orb(it)
  return it and it.class(true) == "armour" and it.subtype() == "offhand" and not it.is_shield()
end

function BRC.is.polearm(it)
  return it and it.weap_skill:contains("Polearms")
end

-------------------------------------------------------
---- BRC.you - Boolean attributes of the character ----
BRC.you = {}

function BRC.you.by_slimy_wall()
  for x = -1, 1 do
    for y = -1, 1 do
      if view.feature_at(x, y) == "slimy_wall" then return true end
    end
  end
  return false
end

function BRC.you.free_offhand()
  if BRC.get.mut(BRC.MUTATIONS.missing_hand, true) > 0 then return true end
  return not items.equipped_at("offhand")
end

function BRC.you.have_shield()
  return BRC.is.shield(items.equipped_at("offhand"))
end

function BRC.you.in_hell(exclude_vestibule)
  local branch = you.branch()
  if exclude_vestibule and branch == "Hell" then return false end
  return util.contains(BRC.HELL_BRANCHES, branch)
end

function BRC.you.miasma_immune()
  if util.contains(BRC.UNDEAD_RACES, you.race()) then return true end
  if util.contains(BRC.NONLIVING_RACES, you.race()) then return true end
  return false
end

function BRC.you.mutation_immune()
  return util.contains(BRC.UNDEAD_RACES, you.race())
end

function BRC.you.shapeshifting_skill()
  local skill = you.skill("Shapeshifting")
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.name() == "amulet of wildshape" then return skill + 5 end
  end
  return skill
end

function BRC.you.zero_stat()
  return you.strength() <= 0 or you.dexterity() <= 0 or you.intelligence() <= 0
end

--------------------------------------------------
---- BRC.set - Wrappers around crawl.setopt() ----
BRC.set = {}

function BRC.set.autopickup_exceptions(pattern, add_pattern)
  local op = add_pattern and "^=" or "-="
  crawl.setopt(string.format("autopickup_exceptions %s %s", op, pattern))
end

function BRC.set.explore_stop(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop %s %s", op, pattern))
end

function BRC.set.explore_stop_pickup_ignore(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop_pickup_ignore %s %s", op, pattern))
end

function BRC.set.flash_screen_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("flash_screen_message %s %s", op, pattern))
end

function BRC.set.force_more_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("force_more_message %s %s", op, pattern))
end

-- Binds a macro to a key. Function must be global and not a member of a module.
function BRC.set.macro(key, function_name)
  BRC.log.debug(
    string.format(
      "Assigning macro: %s to key: %s",
      BRC.text.magenta(function_name .. "()"),
      BRC.text.lightred("<<< '" .. key .. "' >>")
    )
  )
  crawl.setopt(string.format("macros += M %s ===%s", key, function_name))
end

function BRC.set.message_mute(pattern, mute_pattern)
  local op = mute_pattern and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.set.runrest_ignore_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_ignore_message %s %s", op, pattern))
end

function BRC.set.runrest_stop_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_stop_message %s %s", op, pattern))
end

------------------------------------------------------------------------------
--- BRC.dump - Debugging messages for char dump or in-game lua interpreter ---
BRC.dump = {}

-- BRC.dump.all(): Main debug dump. Serializes from non-dependent modules, after checking for existence
-- Usage: In lua interpreter, usually `BRC.dump.all()`, or `BRC.dump.all(1)` for verbose output
function BRC.dump.all(verbose, skip_mpr)
  local tokens = {}

  if BRC.Data and BRC.Data.serialize and type(BRC.Data.serialize) == "function" then
    tokens[#tokens + 1] = BRC.Data.serialize()
  else
    BRC.log.error("Failed to run BRC.Data.serialize()")
  end

  if verbose then
    tokens[#tokens + 1] = serialize_config()
    tokens[#tokens + 1] = serialize_inventory()
    tokens[#tokens + 1] = serialize_chk_lua_save()
    if _weapon_cache and _weapon_cache.serialize and type(_weapon_cache.serialize) == "function" then
      tokens[#tokens + 1] = _weapon_cache.serialize()
    else
      BRC.log.error("Failed to run _weapon_cache.serialize()")
    end
  end

  local text = table.concat(tokens, "\n")
  if not skip_mpr then BRC.mpr.white(text) end

  return text
end

function BRC.dump.char(add_debug_info)
  if add_debug_info then
    crawl.take_note(BRC.dump.all(true, true))
    BRC.mpr.lightgrey("BRC debug info added to character dump.")
  else
    BRC.mpr.darkgrey("No debug info added.")
  end
  BRC.util.do_cmd("CMD_CHARACTER_DUMP")
end

function BRC.dump.var(v)
  crawl.mpr(BRC.util.tostring(v))
end

function macro_brc_dump_character()
  if not BRC.active then BRC.util.do_cmd("CMD_CHARACTER_DUMP") end
  BRC.dump.char(BRC.mpr.yesno("Add BRC debug info to character dump?", BRC.COLOR.lightcyan))
end

----------------------------------------------
---- BRC.util - General utility functions ----
BRC.util = {}

function BRC.util.control_key(c)
  return string.byte(c:upper()) - 64
end

-- BRC.util.do_cmd(): Tries keypress first, then crawl.do_commands() (which isn't always immediate)
function BRC.util.do_cmd(cmd)
  local key = BRC.get.command_key(cmd)
  if key then
    crawl.sendkeys({ key })
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.int2char(num)
  return string.char(string.byte("a") + num)
end

function BRC.util.tostring(value, indent_count)
  indent_count = indent_count or 1
  local indent = string.rep("  ", indent_count)
  local parent_indent = string.rep("  ", indent_count - 1)
  local list_separator = ",\n" .. indent

  local type = type(value)
  if type == "string" then
    return string.format('"%s"', value:gsub('"', ""))
  elseif type == "table" then
    if BRC.is.list(value) then
      local tokens = {}
      for _, v in ipairs(value) do
        tokens[#tokens + 1] = BRC.util.tostring(v, indent_count + 1)
      end
      if #tokens < 4 then return string.format("{ %s }", table.concat(tokens, ", ")) end
      return "{\n" .. indent .. table.concat(tokens, list_separator) .. "\n" .. parent_indent .. "}"
    elseif BRC.is.map(value) then
      local tokens = {}
      for k, v in pairs(value) do
        tokens[#tokens + 1] = string.format('["%s"] = %s', k, BRC.util.tostring(v, indent_count + 1))
      end
      return "{\n" .. indent .. table.concat(tokens, list_separator) .. "\n" .. parent_indent .. "}"
    else
      return "{}"
    end
  else
    return tostring(value)
  end
end

--[[
The functions above are general purpose: They should apply to any crawl RC file.
The functions below contain design choices or logic that are somewhat specific to BRC.
Examples: Weapon DPS calculation, treat dragon scales as branded, defining what a "risky item" is.
--]]

-- Local functions; Often mirroring calculations that live in crawl.
-- Last verified against: dcss v0.33.1

local function format_dmg(dmg)
  -- Always return a string of length 4
  if dmg < 10 then return string.format("%.2f", dmg) end
  if dmg > 99.9 then return ">100" end
  return string.format("%.1f", dmg)
end

local function format_stat(abbr, val, is_worn)
  local stat_str = string.format("%.1f", val)
  if val < 0 then
    return string.format("%s%s", abbr, stat_str)
  elseif is_worn then
    return string.format("%s:%s", abbr, stat_str)
  else
    return string.format("%s+%s", abbr, stat_str)
  end
end

local function get_size_penalty()
  if util.contains(BRC.LITTLE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LITTLE
  elseif util.contains(BRC.SMALL_RACES, you.race()) then
    return BRC.SIZE_PENALTY.SMALL
  elseif util.contains(BRC.LARGE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LARGE
  else
    return BRC.SIZE_PENALTY.NORMAL
  end
end

local function get_unadjusted_armour_pen(encumb)
  local pen = encumb - 2 * BRC.get.mut(BRC.MUTATIONS.sturdy_frame, true)
  if pen > 0 then return pen end
  return 0
end

local function get_adjusted_armour_pen(encumb, str)
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_adjusted_dodge_bonus(encumb, str, dex)
  local size_factor = -2 * get_size_penalty()
  local dodge_bonus = 8 * (10 + you.skill("Dodging") * dex) / (20 - size_factor) / 10
  local armour_dodge_penalty = get_unadjusted_armour_pen(encumb) - 3
  if armour_dodge_penalty <= 0 then return dodge_bonus end

  if armour_dodge_penalty >= str then return dodge_bonus * str / (armour_dodge_penalty * 2) end
  return dodge_bonus - dodge_bonus * armour_dodge_penalty / (str * 2)
end

local function get_shield_penalty(sh)
  return 2 * sh.encumbrance * sh.encumbrance * (27 - you.skill("Shields")) / 27 / (25 + 5 * you.strength())
end

local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Doesn't check brand or delay >=3, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):contains("woodcutter's axe") then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:contains("crossbow") or basename:contains("arbalest")
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

local function get_weap_delay(it)
  -- dcss v0.33.1
  local delay = it.delay - BRC.get.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.get.ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.is.shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

local function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaict
  for i = 0, 20 do
    local inv = items.equipped_at(i)
    if inv then
      if BRC.is.ring(inv) then
        if inv.artefact then
          local name = inv.name()
          local idx = name:find("Slay", 1, true)
          if idx then
            local slay = tonumber(name:sub(idx + 5, idx + 5))
            if slay == 1 then
              local next_digit = tonumber(name:sub(idx + 6, idx + 6))
              if next_digit then slay = 10 + next_digit end
            end

            if name:sub(idx + 4, idx + 4) == "+" then
              sum = sum + slay
            else
              sum = sum - slay
            end
          end
        elseif BRC.get.ego(inv) == "Slay" then
          sum = sum + inv.plus
        end
      elseif inv.artefact and (BRC.is.armour(inv, true) or BRC.is.amulet(inv)) then
        local slay = inv.artprops["Slay"]
        if slay then sum = sum + slay end
      end
    end
  end

  if you.race() == "Demonspawn" then
    sum = sum + 3 * BRC.get.mut(BRC.MUTATIONS.augmentation, true)
    sum = sum + BRC.get.mut(BRC.MUTATIONS.sharp_scales, true)
  end

  return sum
end

local function get_staff_bonus_dmg(it, dmg_type)
  -- dcss v0.33.1
  if dmg_type == BRC.DMG_TYPE.unbranded then return 0 end
  if dmg_type == BRC.DMG_TYPE.plain then
    local basename = it.name("base")
    if basename ~= "staff of earth" and basename ~= "staff of conjuration" then return 0 end
  end

  local spell_skill = BRC.get.skill(BRC.get.staff_school(it))
  local evo_skill = you.skill("Evocations")

  local chance = (2 * evo_skill + spell_skill) / 30
  if chance > 1 then chance = 1 end
  -- 0.75 is an acceptable approximation; most commonly 63/80
  -- Varies by staff type in sometimes complex ways
  local avg_dmg = 3 / 4 * (evo_skill / 2 + spell_skill)
  return avg_dmg * chance
end

-- Formatting for stat inscriptions & alerts
function BRC.get.armour_stats(it)
  if not BRC.is.armour(it) then return "", "" end

  local cur = items.equipped_at(it.equip_type)
  local is_worn = it.equipped or (it.ininventory and cur and cur.slot == it.slot)
  local cur_ac = 0
  local cur_sh = 0
  local cur_ev = 0
  -- Never show deltas if multiple equip slots
  if cur and not is_worn and BRC.get.num_equip_slots(it) == 1 then
    -- Show deltas if not worn, else compare against 0
    if BRC.is.shield(cur) then
      cur_sh = BRC.get.shield_sh(cur)
      cur_ev = -get_shield_penalty(cur)
    else
      cur_ac = BRC.get.armour_ac(cur)
      cur_ev = BRC.get.armour_ev(cur)
    end
  end

  if BRC.is.shield(it) then
    local sh_str = format_stat("SH", BRC.get.shield_sh(it) - cur_sh, is_worn)
    local ev_str = format_stat("EV", -get_shield_penalty(it) - cur_ev, is_worn)
    return sh_str, ev_str
  else
    local ac_str = format_stat("AC", BRC.get.armour_ac(it) - cur_ac, is_worn)
    if not BRC.is.body_armour(it) then return ac_str end
    local ev_str = format_stat("EV", BRC.get.armour_ev(it) - cur_ev, is_worn)
    return ac_str, ev_str
  end
end

function BRC.get.weapon_stats(it, dmg_type)
  if not it.is_weapon then return end
  dmg_type = dmg_type or BRC.DMG_TYPE[BRC.Config.inscribe_dps_type] or BRC.DMG_TYPE.plain
  local dmg = format_dmg(BRC.get.weap_damage(it, dmg_type))
  local delay = get_weap_delay(it)
  local delay_str = string.format("%.1f", delay)
  if delay < 1 then
    delay_str = string.format("%.2f", delay)
    delay_str = delay_str:sub(2, #delay_str)
  end

  local dps = format_dmg(dmg / delay)
  local acc = it.accuracy + (it.plus or 0)
  if acc >= 0 then acc = string.format("+%s", acc) end

  --TODO: This would be nice if it worked in all UIs
  --return string.format("DPS:<w>%s</w> (%s/%s), Acc<w>%s</w>", dps, dmg, delay_str, acc)
  return string.format("DPS: %s (%s/%s), Acc%s", dps, dmg, delay_str, acc)
end

-- BRC.get.ego() - Weapon + Armour egos, with custom logic:
-- Treats unusable egos as no ego. Consistently lowercases non-artefacts.
-- Includes: artefacts, armours with innate egos (except steam dragon scales)
-- If an artefact has a normal brand, it returns just that. (ie a return value of "flame" could be an artefact or not)
function BRC.get.ego(it, exclude_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    if BRC.is.unusable_ego(ego) or (exclude_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.is.body_armour(it) then
    local qualname = it.name("qual")
    if qualname:contains("troll leather") or qualname:contains("dragon scales") and not qualname:contains("steam") then
      return qualname
    end
  end

  if it.artefact then return it.name() end
end

function BRC.get.hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  local st = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end

function BRC.get.items_in_slot(slot)
  local inv_items = {}
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.slot == slot then inv_items[#inv_items + 1] = inv end
  end
  return inv_items
end

function BRC.is.risky_item(it)
  if it.artefact then
    for k, v in pairs(it.artprops) do
      if util.contains(BRC.BAD_ART_PROPS, k) or v < 0 then return true end
    end
  end

  local ego_name = BRC.get.ego(it)
  return ego_name and util.contains(BRC.RISKY_EGOS, ego_name)
end

function BRC.is.unusable_ego(ego)
  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
    or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
    or ego == "pain" and you.skill("Necromancy") == 0
end

-- Armour stats
function BRC.get.armour_ac(it)
  -- dcss v0.33.1
  local it_plus = it.plus or 0

  if it.artefact and it.is_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end

  local ac = it.ac * (1 + you.skill("Armour") / 22) + it_plus
  if not BRC.is.body_armour(it) then return ac end

  local deformed = BRC.get.mut(BRC.MUTATIONS.deformed, true) > 0
  local pseudopods = BRC.get.mut(BRC.MUTATIONS.pseudopods, true) > 0
  if pseudopods or deformed then return ac * 6 / 10 end

  return ac
end

function BRC.get.armour_ev(it)
  -- dcss v0.33.1
  -- This function computes the armour-based component to standard EV (not paralysed, etc)
  -- Factors in stat changes from this armour and removing current one
  local str = you.strength()
  local dex = you.dexterity()
  local no_art_str = str
  local no_art_dex = dex
  local art_ev = 0

  -- Adjust str/dex/EV for artefact stat changes
  local worn = items.equipped_at("armour")
  if worn and worn.artefact then
    if worn.artprops["Str"] then str = str - worn.artprops["Str"] end
    if worn.artprops["Dex"] then dex = dex - worn.artprops["Dex"] end
    if worn.artprops["EV"] then art_ev = art_ev - worn.artprops["EV"] end
  end

  if it.artefact then
    if it.artprops["Str"] then str = str + it.artprops["Str"] end
    if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
    if it.artprops["EV"] then art_ev = art_ev + it.artprops["EV"] end
  end

  if str <= 0 then str = 1 end

  local dodge_bonus = get_adjusted_dodge_bonus(it.encumbrance, str, dex)
  local naked_dodge_bonus = get_adjusted_dodge_bonus(0, no_art_str, no_art_dex)
  return (dodge_bonus - naked_dodge_bonus) + art_ev - get_adjusted_armour_pen(it.encumbrance, str)
end

function BRC.get.shield_sh(it)
  -- dcss v0.33.1
  local dex = you.dexterity()
  if it.artefact and it.is_identified then
    local art_dex = it.artprops["Dex"]
    if art_dex then dex = dex + art_dex end
  end

  local cur = items.equipped_at("offhand")
  if BRC.is.shield(cur) and cur.artefact and cur.slot ~= it.slot then
    local art_dex = cur.artprops["Dex"]
    if art_dex then dex = dex - art_dex end
  end

  local it_plus = it.plus or 0

  local base_sh = it.ac * 2
  local shield = base_sh * (50 + you.skill("Shields") * 5 / 2)
  shield = shield + 200 * it_plus
  shield = shield + 38 * (you.skill("Shields") + 3 + dex * (base_sh + 13) / 26)
  return shield / 200
end

-- Weapon stats
function BRC.get.weap_dps(it, dmg_type)
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  return BRC.get.weap_damage(it, dmg_type) / get_weap_delay(it)
end

function BRC.get.weap_damage(it, dmg_type)
  -- Returns an adjusted weapon damage = damage * speed
  -- Includes stat/slay changes between weapon and the one currently wielded
  -- Aux attacks not included
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  local it_plus = it.plus or 0
  -- Adjust str/dex/slay from artefacts
  local str = you.strength()
  local dex = you.dexterity()

  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local wielded = items.equipped_at("weapon")
    if wielded and wielded.artefact then
      if wielded.artprops["Str"] then str = str - wielded.artprops["Str"] end
      if wielded.artprops["Dex"] then dex = dex - wielded.artprops["Dex"] end
      if wielded.artprops["Slay"] then it_plus = it_plus - wielded.artprops["Slay"] end
    end

    if it.artefact and it.is_identified then
      if it.artprops["Str"] then str = str + it.artprops["Str"] end
      if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
      if it.artprops["Slay"] then it_plus = it_plus + it.artprops["Slay"] end
    end
  end

  local stat = str
  if it.is_ranged or it.weap_skill:contains("Blades") then stat = dex end

  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + BRC.get.skill(it.weap_skill) / 25 / 2) * (1 + you.skill("Fighting") / 30 / 2)

  it_plus = it_plus + get_slay_bonuses()

  local pre_brand_dmg_no_plus = it.damage * stat_mod * skill_mod
  local pre_brand_dmg = pre_brand_dmg_no_plus + it_plus

  if BRC.is.magic_staff(it) then return pre_brand_dmg + get_staff_bonus_dmg(it, dmg_type) end

  if dmg_type == BRC.DMG_TYPE.plain then
    local ego = BRC.get.ego(it)
    if ego and util.contains(BRC.NON_ELEMENTAL_DMG_EGOS, ego) then
      local bonus = BRC.Config.BrandBonus[ego] or BRC.Config.BrandBonus.subtle[ego]
      return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset
    end
  elseif dmg_type >= BRC.DMG_TYPE.branded then
    local ego = BRC.get.ego(it)
    if ego then
      local bonus = BRC.Config.BrandBonus[ego]
      if not bonus and dmg_type == BRC.DMG_TYPE.scoring then bonus = BRC.Config.BrandBonus.subtle[ego] end
      if bonus then return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset end
    end
  end

  return pre_brand_dmg
end

}
############################### End lua/core/util.lua ###############################
##########################################################################################

################################### Begin lua/core/data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC.Data - Persistent data management module
Manages persistent data across games and saves
Author: buehler
Dependencies: core/constants.lua, core/util.lua
--]]

-- Initialize BRC namespace and Data module
BRC = BRC or {}
BRC.Data = {}
BRC.data = BRC.Data -- alias

-- Local variables
local _persist_names = {}
local _game_trackers = { -- Values to detect when character is changed
  brc_version = nil,
  brc_name = nil,
  brc_race = nil,
  brc_class = nil,
  brc_turn = nil,
} -- _game_trackers (do not remove this comment)

-- Local functions
local function verify_game_trackers()
  local success = true

  if you.turns() > 0 then
    for k, v in pairs(_game_trackers) do
      local prev = _G[k]
      if prev ~= v then
        success = false
        _G[k] = v
        BRC.log.warning(string.format("Unexpected change of %s: %s -> %s", k, prev, v))
      end
    end

    if not _G["reload_complete"] then
      success = false
      BRC.log.warning(string.format("Did not reload persistent data for BRC v%s!", BRC.VERSION))
      BRC.mpr.lightgrey("[BRC] This is usually from a malformed RC file. Will attempt to restore from backup.")
    end
  end

  return success
end

local function verify_num_autopickup_funcs()
  _G.num_autopickup_funcs = BRC.Data.persist("num_autopickup_funcs", 0) -- Use _G to make checklua happy
  if _G.num_autopickup_funcs == 0 then _G.num_autopickup_funcs = #chk_force_autopickup end
  if _G.num_autopickup_funcs == #chk_force_autopickup then return true end

  BRC.log.warning(string.format("%s\nExpected: %s but got: %s",
    "Warning: Extra autopickup funcs detected. (Commonly from reloading a local game.)",
    _G.num_autopickup_funcs,
    #chk_force_autopickup
  ))
  BRC.mpr.lightgrey("If this is unexpected, you might want to restart crawl.")
  if BRC.mpr.yesno("Update expected number of autopickup functions?") then
    _G.num_autopickup_funcs = #chk_force_autopickup
  end

  return nil
end

local function is_usable_backup()
  if
    type(c_persist.BRC) ~= "table"
    or type(c_persist.BRC.Backup) ~= "table"
    or c_persist.BRC.Backup.brc_version ~= BRC.VERSION
    or c_persist.BRC.Backup.brc_name ~= you.name()
    or c_persist.BRC.Backup.brc_race ~= you.race()
    or c_persist.BRC.Backup.brc_class ~= you.class()
  then
    return false
  end

  local turn_diff = you.turns() - c_persist.BRC.Backup.backup_turn
  if turn_diff == 0 then return true end
  return BRC.mpr.yesno(string.format("Use backup from %s turns ago?", turn_diff))
end

local function restore_from_backup()
  if type(c_persist.BRC) ~= "table" or type(c_persist.BRC.Backup) ~= "table" then return false end
  for name, value in pairs(c_persist.BRC.Backup) do
    BRC.data.persist(name, value)
    _G[name] = c_persist.BRC.Backup[name]
  end
end

-- Public API

--[[
BRC.Data.persist() Creates a persistent global variable or table, initialized to the default value if it doesn't exist.
The variable/table is automatically persisted across saves.
Returns the current value.
Usage: variable_name = BRC.Data.persist("variable_name", default_value)
--]]
function BRC.Data.persist(name, default_value)
  -- Set global if it doesn't exist, or on turn 0
  if you.turns() == 0 or _G[name] == nil then _G[name] = default_value end

  if not util.contains({ "table", "string", "number", "boolean" }, type(_G[name])) then
    BRC.log.error(string.format("Cannot persist %s. Its value (%s) is of type %s", name, _G[name], type(_G[name])))
  elseif not util.contains(_persist_names, name) then
    _persist_names[#_persist_names + 1] = name
    table.insert(chk_lua_save, function()
      if not _G[name] then return "" end
      return name .. " = " .. BRC.util.tostring(_G[name]) .. BRC.KEYS.LF
    end)
  end

  return _G[name]
end

function BRC.Data.serialize()
  local tokens = { "\n---PERSISTENT TABLES---\n" }
  for _, name in ipairs(_persist_names) do
    if type(_G[name]) == "table" then
      tokens[#tokens + 1] = string.format("%s = %s\n\n", name, BRC.util.tostring(_G[name]))
    end
  end

  tokens[#tokens + 1] = "\n---PERSISTENT VARIABLES---\n"
  for _, name in ipairs(_persist_names) do
    if type(_G[name]) ~= "table" then
      tokens[#tokens + 1] = string.format("%s = %s\n", name, BRC.util.tostring(_G[name]))
    end
  end

  return table.concat(tokens)
end

function BRC.Data.erase()
  if _persist_names then
    for _, name in ipairs(_persist_names) do
      _G[name] = nil
    end
  end

  _persist_names = {}
  BRC.active = false
  BRC.log.warning("Erased all persistent data and disabled BRC. Restart crawl to reload defaults.")
end

function BRC.Data.init()
  -- Update game trackers; Important that this happens in init()
  _game_trackers.brc_version = BRC.VERSION
  _game_trackers.brc_name = you.name()
  _game_trackers.brc_race = you.race()
  _game_trackers.brc_class = you.class()
  _game_trackers.brc_turn = you.turns()

  -- Ensure turns() is captured on save, before persist() to get the updated value in chk_lua_save before it's checked
  table.insert(chk_lua_save, function()
    _G["brc_turn"] = you.turns()
    return ""
  end)
  for k, v in pairs(_game_trackers) do
    BRC.Data.persist(k, v)
  end

  -- reload_complete comes after all other data, defaults to false. If true, confirms all data reloaded.
  BRC.Data.persist("reload_complete", false)
end

-- BRC.Data.verify_reinit(): After all feature init(), verifies data restored as expected
-- Returns true if successful, false if failed, nil if warning only
function BRC.Data.verify_reinit()
  local success = true

  if not verify_game_trackers() then success = false end
  local autopickup_valid = verify_num_autopickup_funcs()
  if not autopickup_valid then success = autopickup_valid end -- False, or nil for warning only

  -- Update game trackers, to compare on next init()
  for k, v in pairs(_game_trackers) do
    BRC.Data.persist(k, v)
  end

  _G["reload_complete"] = true
  return success
end

-- Backup and Restore from c_persist.BRC.Backup
function BRC.Data.backup()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
  c_persist.BRC.Backup = {}
  for _, name in ipairs(_persist_names) do
    c_persist.BRC.Backup[name] = _G[name]
  end
  c_persist.BRC.Backup.backup_turn = you.turns()
end

function BRC.Data.try_backup_restore()
  if not is_usable_backup() then
    local msg = "[BRC] Could not restore from backup. Try restarting. "
    BRC.mpr.lightgrey(msg .. "For detailed startup info, set BRC.Config.show_debug_messages=True.")
    return false
  end

  restore_from_backup()
  BRC.mpr.lightblue("[BRC] Restored data using c_persist.BRC.Backup.")
  return true
end

}
############################### End lua/core/data.lua ###############################
##########################################################################################

################################### Begin lua/core/brc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC (Buehler RC) Core Module
This module serves as the central coordinator for all feature modules
It automatically loads any global module/table that defines `BRC_FEATURE_NAME`
It then manages the feature's lifecycle and hook dispatching
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua
--]]

-- Initialize BRC namespace and non-persistent public variables
BRC = BRC or {}
BRC.VERSION = "1.2.0"
BRC.active = nil

-- Local constants
local HOOK_FUNCTIONS = {
  autopickup = "autopickup",
  c_answer_prompt = "c_answer_prompt",
  c_assign_invletter = "c_assign_invletter",
  c_message = "c_message",
  init = "init",
  ready = "ready",
} -- HOOK_FUNCTIONS (do not remove this comment)

-- Local variables
local _features = {}
local _hooks = {}
local turn_count = nil
local depth = nil

-- Local functions
local function is_feature_module(maybe_feature_module)
  return maybe_feature_module
    and type(maybe_feature_module) == "table"
    and maybe_feature_module.BRC_FEATURE_NAME
    and type(maybe_feature_module.BRC_FEATURE_NAME) == "string"
    and #maybe_feature_module.BRC_FEATURE_NAME > 0
end

local function feature_is_disabled(feature_module)
  return feature_module and feature_module.Config and feature_module.Config.disabled
    or BRC.Config[feature_module.BRC_FEATURE_NAME] and BRC.Config[feature_module.BRC_FEATURE_NAME].disabled
end

local function handle_feature_error(feature_name, hook_name, result)
  BRC.log.error(string.format("Failure in %s.%s", feature_name, hook_name), result)
  if BRC.mpr.yesno(string.format("Deactivate %s?", feature_name), BRC.COLOR.yellow) then
    BRC.unregister_feature(feature_name)
  else
    BRC.mpr.okay()
  end
end

local function handle_core_error(hook_name, result, ...)
  local params = {}
  for i = 1, select("#", ...) do
    local param = select(i, ...)
    if param and param.name and type(param.name) == "function" then
      params[#params + 1] = param.name()
    else
      params[#params + 1] = BRC.util.tostring(param):gsub("<", "<_")
    end
  end
  local param_str = table.concat(params, ", ")

  BRC.log.error("BRC failure in safe_call_all_hooks(" .. hook_name .. ", " .. param_str .. ")", result)
  if BRC.mpr.yesno("Deactivate BRC." .. hook_name .. "?", BRC.COLOR.yellow) then
    _hooks[hook_name] = nil
    BRC.mpr.brown("Unregistered hook: " .. tostring(hook_name))
  else
    BRC.mpr.okay("Returning nil to " .. hook_name .. ".")
  end
end

local function override_feature_config_table(source, dest)
  for key, value in pairs(source) do
    if BRC.is.map(value) then
      if not dest[key] then dest[key] = {} end
      override_feature_config_table(value, dest[key])
    else
      dest[key] = value
    end
  end
end

local function override_feature_config(feature_name)
  if not BRC.Config[feature_name] then return end
  if not _features[feature_name].Config then _features[feature_name].Config = {} end
  override_feature_config_table(BRC.Config[feature_name], _features[feature_name].Config)
  if type(_features[feature_name].Config.init) == "function" then _features[feature_name].Config:init() end
end

-- Hook dispatching
local function call_all_hooks(hook_name, ...)
  local last_return_value = nil
  local returning_feature = nil

  for i = #_hooks[hook_name], 1, -1 do
    local hook_info = _hooks[hook_name][i]
    if not feature_is_disabled(_features[hook_info.feature_name]) then
      local success, result = pcall(hook_info.func, ...)
      if not success then
        handle_feature_error(hook_info.feature_name, hook_name, result)
      else
        if last_return_value and result and last_return_value ~= result then
          BRC.log.warning(string.format("Return value mismatch in %s:\n  (first) %s -> %s\n  (final) %s -> %s",
              hook_name,
              returning_feature,
              BRC.util.tostring(last_return_value),
              hook_info.feature_name,
              BRC.util.tostring(result)
          ))
        end

        last_return_value = result
        returning_feature = hook_info.feature_name
      end
    end
  end

  return last_return_value
end

-- safe_call_all_hooks() - Errors in this function won't show up in crawl, so it is kept very simple + protected.
-- Errors in call_all_hooks() or handle_core_error() are caught by this function.
local function safe_call_all_hooks(hook_name, ...)
  if not BRC.active and hook_name ~= HOOK_FUNCTIONS.init then return end
  if not _hooks or not _hooks[hook_name] then return end

  local success, result = pcall(call_all_hooks, hook_name, ...)
  if success then return result end

  success, result = pcall(handle_core_error, hook_name, result, ...)
  if success then return end

  -- This is a serious error. Failed in the hook, and when we tried to report it.
  BRC.log.error("Failed to report BRC core error!", result)
  if BRC.mpr.yesno("Dump char and deactivate BRC?", BRC.COLOR.yellow) then
    BRC.active = false
    BRC.mpr.brown("BRC deactivated.", "Error in hook: " .. tostring(hook_name))
    pcall(BRC.dump.char, true)
  else
    BRC.mpr.okay()
  end
end

-- Hook management
local function register_all_features(parent_module)
  local loaded_count = 0

  -- Default to scanning the global namespace for modules
  parent_module = parent_module or _G
  if type(parent_module) ~= "table" then
    BRC.log.warning("Invalid parent module (must be a table). Using global namespace instead.")
    parent_module = _G
  end

  -- Scan the namespace for feature modules and load them
  for name, value in pairs(parent_module) do
    if is_feature_module(value) then
      local feature_name = value.BRC_FEATURE_NAME
      local success = BRC.register_feature(feature_name, value)

      if success then
        BRC.log.debug(string.format("Feature '%s' registered", BRC.text.lightcyan(feature_name)))
        loaded_count = loaded_count + 1
      elseif success == false then
        BRC.log.error(string.format("Failed to register feature: %s. Aborting bulk registration.", name))
        return loaded_count
      end
    end
  end

  return loaded_count
end

-- Public API
-- BRC.register_feature(): Return true if success, false if error, nil if feature is disabled
function BRC.register_feature(feature_name, feature_module)
  if not feature_name or not feature_module then
    BRC.log.error("Invalid feature registration: missing name or module")
    return false
  elseif _features[feature_name] then
    BRC.log.error(BRC.text.yellow(feature_name) .. " is already registered")
    return false
  elseif feature_is_disabled(feature_name) then
    BRC.log.debug(string.format("Feature '%s' is disabled", BRC.text.lightcyan(feature_name)))
    return nil
  end

  _features[feature_name] = feature_module

  -- Register hooks
  for _, hook_name in pairs(HOOK_FUNCTIONS) do
    if feature_module[hook_name] then
      if not _hooks[hook_name] then _hooks[hook_name] = {} end
      table.insert(_hooks[hook_name], {
        feature_name = feature_name,
        hook_name = hook_name,
        func = feature_module[hook_name],
      })
    end
  end

  -- Handle config init() and overrides
  if type(feature_module.Config) == "table" and type(feature_module.Config.init) == "function" then
    feature_module.Config:init()
  end
  override_feature_config(feature_name)
  return true
end

function BRC.unregister_feature(feature_name)
  if not _features[feature_name] then
    BRC.log.error(string.format("Feature '%s' is not registered", BRC.text.yellow(feature_name)))
    return false
  end

  _features[feature_name] = nil
  for _, hook_list in pairs(_hooks) do
    for i = #hook_list, 1, -1 do
      if hook_list[i].feature_name == feature_name then
        BRC.log.info(string.format("Unregistered hook: %s.%s", hook_list[i].feature_name, hook_list[i].hook_name))
        table.remove(hook_list, i)
      end
    end
  end

  BRC.log.debug(string.format("Feature '%s' unregistered", BRC.text.lightcyan(feature_name)))
  return true
end

function BRC.get_registered_features()
  return _features
end

function BRC.init(parent_module)
  _features = {}
  _hooks = {}

  -- Load and log config
  if BRC.load_config(BRC.config_to_use) then
    BRC.log.info(string.format("Using config: %s", BRC.text.lightcyan(BRC.config_to_use or "Default")))
  elseif type(BRC.config_to_use ~= nil) then
    BRC.log.error(string.format("Failed to load config: %s", BRC.text.red(BRC.config_to_use)))
    return false
  end

  -- Register all features
  local loaded_count = register_all_features(parent_module)
  if loaded_count == 0 then
    BRC.mpr.lightred("No features loaded. BRC is inactive.")
    return false
  end
  BRC.log.debug(string.format("Loaded %d features.", loaded_count, parent_module))

  -- Init all features
  BRC.log.debug(BRC.text.green("Initializing features..."))
  safe_call_all_hooks(HOOK_FUNCTIONS.init)

  -- Add the autopickup hook
  add_autopickup_func(BRC.autopickup)

  -- Register the char_dump macro
  if BRC.Config.offer_debug_notes_on_char_dump then
    BRC.set.macro(BRC.get.command_key("CMD_CHARACTER_DUMP") or "#", "macro_brc_dump_character")
  end

  -- Init and verify persistent data
  BRC.Data.init()
  local reinit_success = BRC.Data.verify_reinit()
  if reinit_success == true then
    BRC.Data.backup() -- Only backup on clean success
    local msg = string.format("Successfully initialized BRC v%s!", BRC.VERSION)
    msg = msg .. BRC.text.blue(string.format(" (%s features loaded)", loaded_count))
    if BRC.EMOJI.SUCCESS then msg = string.format("%s %s %s", BRC.EMOJI.SUCCESS, msg, BRC.EMOJI.SUCCESS) end
    BRC.mpr.lightgreen(string.format("\n%s\n", msg))
  elseif reinit_success == false then
    if not BRC.Data.try_backup_restore() then
      if BRC.mpr.yesno("Deactivate BRC?", BRC.COLOR.yellow) then
        BRC.active = false
        BRC.mpr.lightred("\nBRC is off.\n")
        return false
      end
    end
  end

  if not reinit_success then
    local msg = string.format("Initialized BRC v%s with warnings", BRC.VERSION)
    msg = msg .. BRC.text.blue(string.format(" (%s features loaded)", loaded_count))
    BRC.mpr.magenta(string.format("\n%s\n", msg))
  end

  -- We're a go!
  turn_count = -1
  depth = you.depth()
  BRC.active = true
  BRC.ready()
  return true
end

function BRC.load_config(config_name)
  if type(config_name) ~= "string" or type(BRC.Configs[config_name]) ~= "table" then
    BRC.log.error(string.format("Config '%s' not found", config_name))
    return false
  end

  BRC.config_to_use = config_name
  BRC.Config = BRC.Configs.Default
  for k, v in pairs(BRC.Configs[config_name]) do
    BRC.Config[k] = v
  end

  if type(BRC.Config.init) == "function" then BRC.Config:init() end

  for name, _ in pairs(_features) do
    override_feature_config(name)
  end

  return true
end

-- Hook methods
function BRC.autopickup(it, _)
  return safe_call_all_hooks(HOOK_FUNCTIONS.autopickup, it)
end

function BRC.ready()
  crawl.redraw_screen()

  if you.turns() == turn_count then return end
  turn_count = you.turns()

  if you.depth() ~= depth and not you.have_orb() then
    depth = you.depth()
    BRC.Data.backup()
  end

  safe_call_all_hooks(HOOK_FUNCTIONS.ready)
  BRC.mpr.consume_queue()
end

function BRC.c_message(text, channel)
  safe_call_all_hooks(HOOK_FUNCTIONS.c_message, text, channel)
end

function BRC.c_answer_prompt(prompt)
  if not prompt then return end -- This fires from crawl, e.g. Shop purchase confirmation
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_answer_prompt, prompt)
end

function BRC.c_assign_invletter(it)
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_assign_invletter, it)
end

}
############################### End lua/core/brc.lua ###############################
##########################################################################################
