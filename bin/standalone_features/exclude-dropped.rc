## Standalone BRC Feature: exclude-dropped
## Generated from: lua/features/exclude-dropped.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false

f_exclude_dropped = {}
f_exclude_dropped.Config = {
  not_weapon_scrolls = true, -- Don't exclude enchant/brand scrolls if holding an enchantable weapon
} -- f_exclude_dropped.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine",
  "horn of Geryon", "lightning rod", "phantom mirror", "phial of floods", "sack of spiders",
  "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.it = BRC.it or {}
BRC.opt = BRC.opt or {}
BRC.txt = BRC.txt or {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.it module
function BRC.it.is_jewellery(it)
  return it and it.class(true) == "jewellery"
end

function BRC.it.is_magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

-- BRC.opt module
local _claimed_macro_keys = {}

function BRC.opt.autopickup_exceptions(pattern, create)
  local op = create and "^=" or "-="
  crawl.setopt(string.format("autopickup_exceptions %s %s", op, pattern))
end

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

function BRC.txt.clean(text)
  if type(text) ~= "string" then return text end
  return text:gsub("\n", ""):gsub("<[^>]*>", "")
end

function BRC.txt.get_pickup_info(text)
  local cleaned = BRC.txt.clean(text)
  if cleaned:sub(2, 4) ~= " - " then return nil end
  return cleaned:sub(5, #cleaned), items.letter_to_index(cleaned:sub(1, 1))
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: exclude-dropped
-- @module f_exclude_dropped
-- Excludes dropped items from autopickup, pickup resumes autopickup.
-- @todo Can remove when crawl's drop_disables_autopickup setting reaches feature parity.
--    (Configurable/optional, dropping partial stack does not exclude, pickup resumes autopickup)
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
ed_dropped_items = BRC.Data.persist("ed_dropped_items", {})

---- Local functions ----
local function add_exclusion(item_name)
  if not util.contains(ed_dropped_items, item_name) then
    table.insert(ed_dropped_items, item_name)
  end
  BRC.opt.autopickup_exceptions(item_name, true)
end

local function remove_exclusion(item_name)
  util.remove(ed_dropped_items, item_name)
  BRC.opt.autopickup_exceptions(item_name, false)
end

local function enchantable_weap_in_inv()
  return util.exists(items.inventory(), function(i)
    return i.is_weapon
      and not BRC.it.is_magic_staff(i)
      and i.plus < 9
      and (not i.artefact or you.race() == "Mountain Dwarf")
  end)
end

local function clean_item_text(text)
  text = BRC.txt.clean(text)
  text = text:gsub("{.*}", "")
  text = text:gsub("[.]", "")
  text = text:gsub("%(.*%)", "")
  return util.trim(text)
end

local function extract_jewellery_or_evoker(text)
  local idx = text:find("ring of", 1, true)
    or text:find("amulet of", 1, true)
    or text:find("wand of", 1, true)
  if idx then return text:sub(idx, #text) end

  for _, item_name in ipairs(BRC.MISC_ITEMS) do
    if text:find(item_name) then return item_name end
  end
end

local function extract_missile(text)
  for _, item_name in ipairs(BRC.MISSILES) do
    if text:contains(item_name) then return item_name end
  end
end

local function extract_potion(text)
  local idx = text:find("potions? of")
  if idx then return "potions? of " .. util.trim(text:sub(idx + 10, #text)) end
end

local function extract_scroll(text)
  local idx = text:find("scrolls? of")
  if idx then return "scrolls? of " .. util.trim(text:sub(idx + 10, #text)) end
end

--[[
  get_item_name() - Tries to extract item name from text.
  Returns name of item, or nil if not recognized as an excludable item.
--]]
local function get_item_name(text)
  text = clean_item_text(text)
  return extract_jewellery_or_evoker(text)
    or extract_missile(text)
    or extract_potion(text)
    or extract_scroll(text)
end

local function should_exclude(item_name, full_msg)
  -- Enchant/Brand weapon scrolls continue pickup if they're still useful
  if
    f_exclude_dropped.Config.not_weapon_scrolls
    and (item_name:contains("enchant weapon") or item_name:contains("brand weapon"))
    and enchantable_weap_in_inv()
  then
    return false
  end

  -- Don't exclude if we dropped partial stack (except for jewellery)
  for _, inv in ipairs(items.inventory()) do
    if inv.name("qual"):contains(item_name) then
      return BRC.it.is_jewellery(inv)
        or inv.quantity == 1
        or full_msg:contains("ou drop " .. inv.quantity .. " " .. item_name)
    end
  end

  return true
end

---- Initialization ----
function f_exclude_dropped.init()
  for _, v in ipairs(ed_dropped_items) do
    add_exclusion(v)
  end
end

---- Crawl hook functions ----
function f_exclude_dropped.c_message(text, channel)
  if channel ~= "plain" then return end

  local picked_up = BRC.txt.get_pickup_info(text)
  if not picked_up and not text:contains("ou drop ") then return end

  local item_name = get_item_name(text)
  if not item_name then return end

  if picked_up then
    remove_exclusion(item_name)
  elseif should_exclude(item_name, text) then
    add_exclusion(item_name)
  end
end


-- Crawl hook wrappers
function c_message(...)
  return f_exclude_dropped.c_message(...)
end


-- Initialize feature
if f_exclude_dropped.init then f_exclude_dropped.init() end
}
