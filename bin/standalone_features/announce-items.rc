## Standalone BRC Feature: announce-items
## Generated from: lua/features/announce-items.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false

f_announce_items = {}
f_announce_items.Config = {
  disabled = false, -- Disabled by default. Intended only for turncount runs.
  announce_class = { "book", "gold", "jewellery", "misc", "missile", "potion", "scroll", "wand" },
  announce_glowing = true,
  announce_artefacts = true,
  max_gold_announcements = 3, -- Stop announcing gold after 3rd pile on screen
  announce_duplicate_consumables = true, -- Announce when standing on not-id'd duplicates
} -- f_announce_items.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)


-- BRC module tables (Don't overwrite existing globals)
BRC.txt = BRC.txt or {}

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end


---------------------------------------------------------------------------------------------------
-- BRC feature module: announce-items
-- @module f_announce_items
-- Announce when items of certain classes come into view. Off by default.
-- Intended and configured for turncount runs, to avoid having to manually check floor items.
---------------------------------------------------------------------------------------------------


---- Local constants ----
local ALERT_COLOR = {
  gold = BRC.COL.yellow,
  book = BRC.COL.lightcyan,
  jewellery = BRC.COL.magenta,
  misc = BRC.COL.lightcyan,
  missile = BRC.COL.white,
  potion = BRC.COL.lightgreen,
  scroll = BRC.COL.lightgreen,
  wand = BRC.COL.magenta,
  default = BRC.COL.lightblue,
} -- ALERT_COLOR (do not remove this comment)

---- Local variables ----
local C -- config alias
local los_items
local prev_item_names
local prev_gold_count

---- Initialization ----
function f_announce_items.init()
  C = f_announce_items.Config
  los_items = {}
  prev_item_names = {}
  prev_gold_count = 0
end

---- Local functions ----
local function should_announce_item(it)
  if it.is_useless then return false end
  if not it.is_identified then
    if it.artefact then return C.announce_artefacts end
    if it.branded then return C.announce_glowing end
  elseif crawl.messages(2):contains(it.name()) then
    -- Avoid duplicating "You see here ..." after floor-id
    return false
  end

  return util.contains(C.announce_class, it.class(true):lower())
end

local function announce_item(it)
  if not should_announce_item(it) then return end
  local class = it.class(true):lower()
  if class == "gold" then
    prev_gold_count = prev_gold_count + 1
    if prev_gold_count > C.max_gold_announcements then return end
  end

  local item_col = ALERT_COLOR[class] or ALERT_COLOR.default
  crawl.mpr(BRC.txt.white("Found: ") .. BRC.txt[item_col](it.name()))
  you.stop_activity()
end

---- Crawl hook functions ----
function f_announce_items.ready()
  los_items = {}
  local r = you.los()
  for x = -r, r do
    for y = -r, r do
      if you.see_cell(x, y) then
        local items_xy = items.get_items_at(x, y)
        if items_xy and #items_xy > 0 then
          for _, it in ipairs(items_xy) do
            los_items[#los_items+1] = it

            if C.announce_duplicate_consumables then
              if x == 0 and y == 0 and not it.is_identified
                and (it.class(true) == "scroll" or it.class(true) == "potion")
               then
                if util.exists(items.inventory(), function(i)
                  return i.name("qual", false) == it.name("qual", false)
                end) then
                  crawl.mpr(BRC.txt.magenta("Duplicate: ") .. it.name())
                end
              end
            end
          end
        end
      end
    end
  end

  for _, it in ipairs(los_items) do
    if not util.contains(prev_item_names, it.name()) then
      announce_item(it)
    end
  end

  -- Save history for comparison
  prev_item_names = {}
  prev_gold_count = 0
  for _, it in ipairs(los_items) do
    prev_item_names[#prev_item_names+1] = it.name()
    if it.class(true):lower() == "gold" then
      prev_gold_count = prev_gold_count + 1
    end
  end
end


-- Crawl hook wrappers
local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_announce_items.ready(...)
  end
end


-- Initialize feature
if f_announce_items.init then f_announce_items.init() end
}
