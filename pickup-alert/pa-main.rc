include = pickup-alert/pa-data.rc

{
----------------------------------------
---- Persistant data access / logic ----
----------------------------------------
function update_high_scores(it)
  local ret_val = nil
  
  if it.class(true) == "armour" then
    local ac = get_armour_ac(it)
    if ac > armour_high_score then
      armour_high_score = ac
      if not ret_val then ret_val = "Strongest armour" end
    end
  elseif it.class(true) == "weapon" then
    local it_plus = it.plus
    if not it_plus then it_plus = 0 end
    local score = get_weap_dps(it) + (it.accuracy + it_plus) / 2
    if score > weapon_high_score then
	  weapon_high_score = score
      if not ret_val then ret_val = "Good weapon" end
    end
    
    local unbranded_score = get_weap_dps(it, false) + (it.accuracy + it_plus) / 2
    if unbranded_score > unbranded_high_score then
      unbranded_high_score = score
      if not ret_val then ret_val = "High pure damage" end
    end
    
    if it.weap_skill == "Polearms" then
      if score > polearm_high_score then
        polearm_high_score = score
        if not items.equipped_at("shield") and not ret_val then ret_val = "Good polearm" end
      end

      if get_hands(it) == 1 and score > polearm_onehand_high_score then
        polearm_onehand_high_score = score
        if not ret_val then ret_val = "1-handed polearm" end
      end
    end
  end

  return ret_val
end

function pickup_item(it)
  local ret_val = false
  local name = it.name("plain")
  if not it.fully_identified then
    name = "+0 " .. name
  end

  if it.artefact then
    ret_val = true
  elseif not util.contains(items_picked, name) then
    -- Add to the table on pickup, in c_assign_invletter() hook function
    ret_val = true
  end
  
  -- Remove from rare_items if it's there
  local rare_idx = get_rare_item_index(it)
  if rare_idx ~= -1 then
    util.remove(rare_items, rare_items[rare_idx])
	return true
  end

  -- Returns true if we haven't picked up this item previously
  return ret_val
end


function alert_item(it, alert_type)
  local name = it.name("plain")
  
  if (it.artefact or it.branded) and not it.fully_identified then
    if not it.artefact then table.insert(items_alerted, name) end
    show_alert_msg("Item alert, "..alert_type..": ", name)
    table.insert(level_alerts, name)
    return
  end
  
  -- Prefix unidentified items with "+0"
  if not it.fully_identified then
    name = "+0 " .. name
  end

  if not util.contains(items_alerted, name) then
    if it.class(true) == "weapon" or it.class(true) == "magical staff" then
      show_alert_msg("Item alert, "..alert_type..": ", name.." "..get_weapon_info(it))
      table.insert(level_alerts, name)
    elseif it.class(true) == "armour" then
      show_alert_msg("Item alert, "..alert_type..": ", name.." "..get_armour_info(it))
      table.insert(level_alerts, name)
    else
      show_alert_msg("Item alert, "..alert_type..": ", name)
      table.insert(level_alerts, name)
    end

    if not it.artefact then insert_item_and_less_enchanted(items_alerted, name) end
  end
  
  -- Returns true to make other code more concise; indicates that we tried to alert this item
  return true
end
crawl.setopt("runrest_stop_message += Item alert, ")




---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------

function c_assign_invletter_item_alerts(it)
  local name = it.name("plain")
  if it.delay or it.class(true) == "armour" then
    if not util.contains(items_picked, name) then
      if not it.artefact then 
	    insert_item_and_less_enchanted(items_picked, name)
        insert_item_and_less_enchanted(items_alerted, name)
	  end
      update_high_scores(it)
      
	  local rare_idx = get_rare_item_index(it)
	  if idx ~= -1 then util:remove(rare_items, rare_items[rare_idx]) end
    end
  end
  
  if util.contains(level_alerts, name) then util.remove(level_alerts, name) end
end

function c_message_item_alerts(text, channel)
  if text:find("Done exploring.") or text:find("Partly explored") then
    local all_alerts
    for v in iter.invent_iterator:new(level_alerts) do
      if not all_alerts then all_alerts = v
      else all_alerts = all_alerts..", "..v
      end
    end
    
    level_alerts = {}
    crawl.mpr("<magenta>Level alerts: "..all_alerts.."</magenta>")
  end
end

function ready_item_alerts()
  for it in iter.invent_iterator:new(items.inventory()) do
    if it.delay then update_high_scores(it, false)
    elseif it.subtype() == "body" then update_high_scores(it, true)
    end
  end
end

-------------------------------------------------
------------------- End Hooks -------------------
-------------------------------------------------



-------------------------
---- Autopickup main ----
-------------------------
add_autopickup_func(function (it, name)
  local class = it.class(true)

  -- Check for pickup
  local retVal = false
  if class == "armour" and loaded_pa_armour then retVal = pickup_armour(it)
  elseif class == "weapon" and loaded_pa_weapons then retVal = pickup_weapons(it)
  elseif class == "magical staff" and loaded_pa_misc then retVal = pickup_staves(it)
  end
  
  if retVal == true then return pickup_item(it) end

  -- Update inventory high scores before alerting; relevant when XP gained same turn item is dropped
  ready_item_alerts()
  
  -- Not picking up this item. Check for alerts
  if loaded_pa_misc then
    alert_rare_items(it)
    if class == "magical staff" then alert_staves(it) end
  end

  if it.name("base") == "orb" and loaded_pa_misc then alert_orbs(it)
  elseif class == "armour" and loaded_pa_armour then alert_armour(it)
  elseif class == "weapon" and loaded_pa_weapons then alert_weapons(it)
  end
end)
}