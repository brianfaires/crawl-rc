## Standalone BRC Feature: display-realtime
## Generated from: lua/features/display-realtime.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false

f_display_realtime = {}
f_display_realtime.Config = {
  disabled = false, -- Disabled by default
  interval_s = 60, -- seconds between updates
  emoji = BRC.Config.emojis and "ðŸ•’" or "--",
} -- f_display_realtime.Config (do not remove this comment)

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.mpr = BRC.mpr or {}
BRC.txt = BRC.txt or {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.mpr module
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end


-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

function BRC.txt.wrap(text, wrapper, no_space)
  if not wrapper then return text end
  return table.concat({ wrapper, text, wrapper }, no_space and "" or " ")
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: display-realtime
-- @module f_display_realtime
-- Display the realtime periodically in the output channel.
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
dr_total_time = BRC.Data.persist("dr_total_time", 0)

---- Local variables ----
local last_time
local last_cycle

---- Initialization ----
function f_display_realtime.init()
  last_time = you.real_time()
  last_cycle = 0
end

---- Crawl hook functions ----
function f_display_realtime.ready()
  dr_total_time = dr_total_time + you.real_time() - last_time
  local cycle = dr_total_time // f_display_realtime.Config.interval_s
  if cycle > last_cycle then
    local time_str = "Game time: "
    if dr_total_time > 3600 then time_str = time_str .. (dr_total_time // 3600) .. ":" end
    local remain = dr_total_time % 3600
    time_str = time_str .. (remain // 60) .. ":" .. (remain % 60)

    BRC.mpr.white(BRC.txt.wrap(time_str, f_display_realtime.Config.emoji))
    last_cycle = cycle
  end
  last_time = you.real_time()
end


-- Crawl hook wrappers
local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_display_realtime.ready(...)
  end
end


-- Initialize feature
if f_display_realtime.init then f_display_realtime.init() end
}
