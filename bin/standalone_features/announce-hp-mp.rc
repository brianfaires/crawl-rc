## Standalone BRC Feature: announce-hp-mp
## Generated from: lua/features/announce-hp-mp.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace (Don't overwrite existing globals)
BRC = BRC or {}
BRC.Config = BRC.Config or {}
BRC.Config.emojis = false

f_announce_hp_mp = {}
f_announce_hp_mp.Config = {
  dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
  dmg_fm_threshold = 0.30, -- Force more for losing this % of max HP
  always_on_bottom = false, -- Rewrite HP/MP meters after each turn with messages
  meter_length = 10, -- Number of pips in each meter

  Announce = {
    hp_loss_limit = 1, -- Announce when HP loss >= this
    hp_gain_limit = 4, -- Announce when HP gain >= this
    mp_loss_limit = 1, -- Announce when MP loss >= this
    mp_gain_limit = 2, -- Announce when MP gain >= this
    hp_first = false, -- Show HP first in the message
    same_line = true, -- Show HP/MP on the same line
    always_both = true, -- If showing one, show both
    very_low_hp = 0.10, -- At this % of max HP, show all HP changes and mute % HP alerts
  },

  HP_METER = { FULL = "‚ù§Ô∏è", PART = "‚ù§Ô∏è‚Äçü©π", EMPTY = "ü§ç" },
  MP_METER = { FULL = "üü¶", PART = "üîπ", EMPTY = "‚ûñ" },

  init = function()
    if not BRC.Config.emojis then
      f_announce_hp_mp.Config.HP_METER = {
        BORDER = "<white>|</white>",
        FULL = "<lightgreen>+</lightgreen>",
        PART = "<lightgrey>+</lightgrey>",
        EMPTY = "<darkgrey>-</darkgrey>",
      } -- HP_METER (do not remove this comment)
      f_announce_hp_mp.Config.MP_METER = {
        BORDER = "<white>|</white>",
        FULL = "<lightblue>+</lightblue>",
        PART = "<lightgrey>+</lightgrey>",
        EMPTY = "<darkgrey>-</darkgrey>",
      } -- MP_METER (do not remove this comment)
    end
  end,
} -- f_announce_hp_mp.Config (do not remove this comment)

-- define string:contains() for all strings
function BRC_txt_str_contains(self, text)
  return self:find(text, 1, true) ~= nil
end
getmetatable("").__index.contains = BRC_txt_str_contains

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.EMOJI = {}


-- BRC module tables (Don't overwrite existing globals)
BRC.Data = BRC.Data or {}
BRC.mpr = BRC.mpr or {}
BRC.opt = BRC.opt or {}
BRC.txt = BRC.txt or {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local function brc_tostr(value)
  if type(value) == "table" then
    if #value == 0 then
      local result = "{ "
      for k, v in pairs(value) do
        result = result .. k .. " = " .. brc_tostr(v) .. ", "
      end
      return result .. " }"
    else
      return "{ " .. table.concat(value, ", ") .. " }"
    end
  elseif type(value) == "string" then
    return "\"" .. value:gsub("\"", "") .. "\""
  else
    return tostring(value)
  end
end

function BRC.Data.persist(name, default_value)
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = util.copy_table(default_value)
    else
      _G[name] = default_value
    end
  end
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    return name .. " = " .. brc_tostr(_G[name]) .. "\n"
  end)
  return _G[name]
end

-- BRC.mpr module
BRC.mpr.brc_prefix = BRC.txt.darkgrey("[BRC] ")
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

function BRC.mpr.que(msg, color, channel)
  BRC.mpr.que_optmore(false, msg, color, channel)
end

function BRC.mpr.que_optmore(show_more, msg, msg_color, channel)
  for _, q in ipairs(_mpr_queue) do
    if q.m == msg and q.ch == channel and q.more == show_more then return end
  end
  msg_color = msg_color or BRC.COL.lightgrey
  if not msg or #msg == 0 then
    msg = ""
  else
    msg = BRC.txt[msg_color](msg)
  end
  _mpr_queue[#_mpr_queue + 1] = { m = msg, ch = channel, more = show_more }
end

-- BRC.opt module
local _claimed_macro_keys = {}

function BRC.opt.message_mute(pattern, create)
  local op = create and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

-- BRC.txt module
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

function BRC.txt.clean(text)
  if type(text) ~= "string" then return text end
  return text:gsub("\n", ""):gsub("<[^>]*>", "")
end

function BRC.txt.wrap(text, wrapper, no_space)
  if not wrapper then return text end
  return table.concat({ wrapper, text, wrapper }, no_space and "" or " ")
end

-- mpr queue support: _mpr_queue and BRC.mpr.consume_queue()
_mpr_queue = {}
function BRC.mpr.consume_queue()
  local do_more = util.exists(_mpr_queue, function(q) return q.more end)
  -- stop_activity() can generate more autopickups, and thus more queue'd messages
  if do_more then
    you.stop_activity()
  end

  for _, msg in ipairs(_mpr_queue) do
    if msg.m and #msg.m > 0 then
      crawl.mpr(tostring(msg.m), msg.ch)
      crawl.flush_prev_message()
    end
  end
  _mpr_queue = {}

  if do_more then
    crawl.redraw_screen()
    crawl.more()
  end
end

---------------------------------------------------------------------------------------------------
-- BRC feature module: announce-hp-mp
-- @module f_announce_hp_mp
-- @author magus, buehler
-- Announce changes in HP/MP, with visual meters and additional warnings for severe damage.
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
ad_prev = BRC.Data.persist("ad_prev", { hp = 0, mhp = 0, mp = 0, mmp = 0 })

---- Local constants ----
local ALWAYS_BOTTOM_SETTINGS = {
  hp_loss_limit = 0, hp_gain_limit = 0, mp_loss_limit = 0, mp_gain_limit = 0,
  hp_first = true, same_line = true, always_both = true, very_low_hp = 0,
} -- ALWAYS_BOTTOM_SETTINGS (do not remove this comment)

---- Local variables ----
local C -- config alias

---- Initialization ----
function f_announce_hp_mp.init()
  C = f_announce_hp_mp.Config

  ad_prev.hp = 0
  ad_prev.mhp = 0
  ad_prev.mp = 0
  ad_prev.mmp = 0

  if C.always_on_bottom then C.Announce = ALWAYS_BOTTOM_SETTINGS end

  if C.dmg_fm_threshold > 0 and C.dmg_fm_threshold <= 0.5 then
      BRC.opt.message_mute("Ouch! That really hurt!", true)
  end
end

---- Local functions ----
local function create_meter(perc, emojis)
  perc = math.max(0, math.min(1, perc)) -- Clamp between 0 and 1

  local num_halfpips = math.floor(perc * C.meter_length * 2)
  local num_full_emojis = math.floor(num_halfpips / 2)
  local num_part_emojis = num_halfpips % 2
  local num_empty_emojis = C.meter_length - num_full_emojis - num_part_emojis

  return table.concat({
    emojis.BORDER or "",
    string.rep(emojis.FULL, num_full_emojis),
    string.rep(emojis.PART, num_part_emojis),
    string.rep(emojis.EMPTY, num_empty_emojis),
    emojis.BORDER or "",
  })
end

local function format_delta(delta)
  if delta > 0 then
    return BRC.txt.green("+" .. delta)
  elseif delta < 0 then
    return BRC.txt.red(delta)
  else
    return BRC.txt.darkgrey("+0")
  end
end

local function format_ratio(cur, max)
  local ratio_color
  if cur <= (max * 0.25) then
    ratio_color = BRC.COL.lightred
  elseif cur <= (max * 0.50) then
    ratio_color = BRC.COL.red
  elseif cur <= (max * 0.75) then
    ratio_color = BRC.COL.yellow
  elseif cur < max then
    ratio_color = BRC.COL.white
  else
    ratio_color = BRC.COL.green
  end

  return BRC.txt[ratio_color](string.format(" -> %s/%s", cur, max))
end

local function get_hp_message(hp_delta, mhp_delta)
  local hp, mhp = you.hp()
  local msg_tokens = {}
  msg_tokens[#msg_tokens + 1] = create_meter(hp / mhp, C.HP_METER)
  msg_tokens[#msg_tokens + 1] = BRC.txt.white(string.format(" HP[%s]", format_delta(hp_delta)))
  msg_tokens[#msg_tokens + 1] = format_ratio(hp, mhp)

  if mhp_delta ~= 0 then
    local text = string.format(" (%s max HP)", format_delta(mhp_delta))
    msg_tokens[#msg_tokens + 1] = BRC.txt.lightgrey(text)
  end

  if not C.Announce.same_line and hp == mhp then
    msg_tokens[#msg_tokens + 1] = BRC.txt.white(" (Full HP)")
  end

  return table.concat(msg_tokens)
end

local function get_mp_message(mp_delta, mmp_delta)
  local mp, mmp = you.mp()
  local msg_tokens = {}
  msg_tokens[#msg_tokens + 1] = create_meter(mp / mmp, C.MP_METER)
  msg_tokens[#msg_tokens + 1] = BRC.txt.lightcyan(string.format(" MP[%s]", format_delta(mp_delta)))
  msg_tokens[#msg_tokens + 1] = format_ratio(mp, mmp)

  if mmp_delta ~= 0 then
    local tok = string.format(" (%s max MP)", format_delta(mmp_delta))
    msg_tokens[#msg_tokens + 1] = BRC.txt.cyan(tok)
  end

  if not C.Announce.same_line and mp == mmp then
    msg_tokens[#msg_tokens + 1] = BRC.txt.lightcyan(" (Full MP)")
  end

  return table.concat(msg_tokens)
end

local function last_msg_is_meter()
  local last_msg = crawl.messages(1)
  return f_announce_hp_mp.msg_is_meter(last_msg)
end

---- Public API ----
function f_announce_hp_mp.msg_is_meter(msg)
  -- Might be better to check more rigorously, but this seems robust and quick.
  msg = BRC.txt.clean(msg)
  return msg:contains("] -> ") and (msg:contains(" HP[") or msg:contains(" MP["))
end

---- Crawl hook functions ----
function f_announce_hp_mp.ready()
  -- Update prev state first, so we can safely return early below
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  local is_startup = ad_prev.hp == 0
  local hp_delta = hp - ad_prev.hp
  local mp_delta = mp - ad_prev.mp
  local mhp_delta = mhp - ad_prev.mhp
  local mmp_delta = mmp - ad_prev.mmp
  local damage_taken = mhp_delta - hp_delta
  ad_prev.hp = hp
  ad_prev.mhp = mhp
  ad_prev.mp = mp
  ad_prev.mmp = mmp

  if is_startup then return end
  if hp_delta == 0 and mp_delta == 0 and last_msg_is_meter() then return end
  local is_very_low_hp = hp <= C.Announce.very_low_hp * mhp

  -- Determine which messages to show
  local do_hp = true
  local do_mp = true
  if hp_delta <= 0 and hp_delta > -C.Announce.hp_loss_limit then do_hp = false end
  if hp_delta >= 0 and hp_delta < C.Announce.hp_gain_limit then do_hp = false end
  if mp_delta <= 0 and mp_delta > -C.Announce.mp_loss_limit then do_mp = false end
  if mp_delta >= 0 and mp_delta < C.Announce.mp_gain_limit then do_mp = false end

  if not do_hp and is_very_low_hp and hp_delta ~= 0 then do_hp = true end
  if not do_hp and not do_mp then return end
  if C.Announce.always_both then
    do_hp = true
    do_mp = true
  end

  -- Put messages together
  local hp_msg = get_hp_message(hp_delta, mhp_delta)
  local mp_msg = get_mp_message(mp_delta, mmp_delta)
  local msg_tokens = {}
  msg_tokens[1] = (C.Announce.hp_first and do_hp) and hp_msg or mp_msg
  if do_mp and do_hp then
    msg_tokens[2] = C.Announce.same_line and string.rep(" ", 7) or "\n"
    msg_tokens[3] = C.Announce.hp_first and mp_msg or hp_msg
  end
  if #msg_tokens > 0 then BRC.mpr.que(table.concat(msg_tokens)) end

  -- Add Damage-related warnings, when damage >= threshold
  if damage_taken >= mhp * C.dmg_flash_threshold then
    if is_very_low_hp then return end -- mute % HP alerts
    if damage_taken >= (mhp * C.dmg_fm_threshold) then
      local msg = BRC.txt.lightmagenta("MASSIVE DAMAGE")
      BRC.mpr.que_optmore(true, BRC.txt.wrap(msg, BRC.EMOJI.EXCLAMATION_2))
    else
      local msg = BRC.txt.magenta("BIG DAMAGE")
      BRC.mpr.que_optmore(false, BRC.txt.wrap(msg, BRC.EMOJI.EXCLAMATION))
    end
  end
end


-- Crawl hook wrappers
local brc_last_turn = -1
function ready(...)
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_announce_hp_mp.ready(...)
  end
  BRC.mpr.consume_queue()
end


-- Initialize feature
if f_announce_hp_mp.init then f_announce_hp_mp.init() end
}
