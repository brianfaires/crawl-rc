## BRC Pickup-alert feature - Copy/paste this file above only_core.rc.

################################### Begin lua/features/pickup-alert/pa-armour.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-armour
Description: Armour pickup logic and alert system for the pickup-alert system
Author: Original Equipment autopickup by Medar, gammafunk, and various others. Extended by buehler.
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_pa_armour = {}
--f_pa_armour.BRC_FEATURE_NAME = "pickup-alert-armour"

-- Local constants / configuration
local ENCUMB_ARMOUR_DIVISOR = 2 -- Encumbrance penalty is offset by (Armour / ENCUMB_ARMOUR_DIVISOR)
local SAME = "same_ego"
local LOST = "lost_ego"
local GAIN = "gain_ego"
local DIFF = "diff_ego"
local HEAVIER = "heavier"
local LIGHTER = "lighter"

local ARMOUR_ALERT = {
  artefact = { msg = "Artefact armour", emoji = BRC.Emoji.ARTEFACT },
  [GAIN] = { msg = "Gain ego", emoji = BRC.Emoji.EGO },
  [DIFF] = { msg = "Diff ego", emoji = BRC.Emoji.EGO },
  [LIGHTER] = {
    [GAIN] = { msg = "Gain ego (Lighter armour)", emoji = BRC.Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Lighter armour)", emoji = BRC.Emoji.EGO },
    [SAME] = { msg = "Lighter armour", emoji = BRC.Emoji.LIGHTER },
    [LOST] = { msg = "Lighter armour (Lost ego)", emoji = BRC.Emoji.LIGHTER },
  },
  [HEAVIER] = {
    [GAIN] = { msg = "Gain ego (Heavier armour)", emoji = BRC.Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Heavier armour)", emoji = BRC.Emoji.EGO },
    [SAME] = { msg = "Heavier Armour", emoji = BRC.Emoji.HEAVIER },
    [LOST] = { msg = "Heavier Armour (Lost ego)", emoji = BRC.Emoji.HEAVIER },
  }, -- ARMOUR_ALERT.heavier (do not remove this comment)
} -- ARMOUR_ALERT (do not remove this comment)

-- Local functions
local function aux_slot_is_impaired(it)
  local st = it.subtype()
  -- Skip boots/gloves/helmet if wearing Lear's hauberk
  local worn = items.equipped_at("armour")
  if worn and worn.name("qual") == "Lear's hauberk" and st ~= "cloak" then return true end

  -- Mutation interference
  if st == "gloves" then
    return BRC.get.mut(BRC.MUTATIONS.demonic_touch, true) >= 3 and not BRC.you.free_offhand()
        or BRC.get.mut(BRC.MUTATIONS.claws, true) > 0 and not items.equipped_at("weapon")
  elseif st == "boots" then
    return BRC.get.mut(BRC.MUTATIONS.hooves, true) > 0
        or BRC.get.mut(BRC.MUTATIONS.talons, true) > 0
  elseif it.name("base"):find("helmet", 1, true) then
    return BRC.get.mut(BRC.MUTATIONS.horns, true) > 0
        or BRC.get.mut(BRC.MUTATIONS.beak, true) > 0
        or BRC.get.mut(BRC.MUTATIONS.antennae, true) > 0
  end

  return false
end

local function get_adjusted_ev_delta(encumb_delta, ev_delta)
  local encumb_skills = you.skill("Spellcasting")
    + you.skill("Ranged Weapons")
    - you.skill("Armour") / ENCUMB_ARMOUR_DIVISOR
  local encumb_impact = encumb_skills / you.xl()
  encumb_impact = math.max(0, math.min(1, encumb_impact)) -- Clamp to 0-1

  -- Subtract weighted encumbrance penalty, to align with ev_delta (negative == heavier)
  return ev_delta - encumb_delta * encumb_impact * BRC.Tuning.armour.encumb_penalty_weight
end

local function get_ego_change_type(cur_ego, it_ego)
  if it_ego == cur_ego then
    return SAME
  elseif not it_ego then
    return LOST
  elseif not cur_ego then
    return GAIN
  else
    return DIFF
  end
end

local function is_new_ego(ego_change)
  return ego_change == GAIN or ego_change == DIFF
end

local function send_armour_alert(it, alert_type)
  return f_pickup_alert.do_alert(it, alert_type.msg, alert_type.emoji, BRC.Config.fm_alert.body_armour)
end

-- Local functions: Pickup
local function pickup_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end -- surely am naked for a reason

  -- No pickup if wearing an artefact
  if cur.artefact then return false end

  -- No pickup if adding encumbrance or losing AC
  local encumb_delta = it.encumbrance - cur.encumbrance
  if encumb_delta > 0 then return false end
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  if ac_delta < 0 then return false end

  -- Pickup: Pure upgrades
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if it_ego == cur_ego then return (ac_delta > 0 or encumb_delta < 0) end
  return not cur_ego and (ac_delta >= 0 or encumb_delta <= 0)
end

local function pickup_shield(it)
  -- Don't replace these
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end
  if cur.encumbrance ~= it.encumbrance then return false end
  if cur.artefact then return false end

  -- Pickup: artefact
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_plus = it.plus or 0
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if it_ego == cur_ego then return it_plus > cur.plus end
  return not cur_ego and it_plus >= cur.plus
end

local function pickup_aux_armour(it)
  -- Pickup: Anything if the slot is empty, unless downside from mutation
  if aux_slot_is_impaired(it) then return false end
  local all_equipped, num_slots = BRC.get.equipped_at(it)
  if #all_equipped < num_slots then
    -- If we're carrying one (implying a blocking mutation), don't pickup another
    if #all_equipped == 0 and num_slots == 1 then
      local st = it.subtype()
      for inv in iter.invent_iterator:new(items.inventory()) do
        if inv.subtype() == st then return false end
      end
    end
    return true
  end

  -- Pickup: artefact, unless slot(s) already full of artefact(s)
  for i, cur in ipairs(all_equipped) do
    if not cur.artefact then break end
    if i == num_slots then return false end
  end
  if it.is_identified and it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_ac = BRC.get.armour_ac(it)
  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local cur_ac = BRC.get.armour_ac(cur)
    local cur_ego = BRC.get.ego(cur)
    if it_ego == cur_ego then
      if it_ac > cur_ac then return true end
    elseif not cur_ego then
      if it_ac >= cur_ac then return true end
    end
  end
  return false
end

-- Local functions: Alerting
local function should_alert_body_armour(weight, gain, loss, ego_change)
  local meets_ratio = loss <= 0 or (gain / loss > BRC.Tuning.armour[weight][ego_change])
  if not meets_ratio then return false end

  -- Additional ego-specific restrictions
  if is_new_ego(ego_change) then
    return loss <= BRC.Tuning.armour[weight].max_loss
  elseif ego_change == LOST then
    return gain >= BRC.Tuning.armour[weight].min_gain
  end

  return true
  -- local function should_alert_lighter_armour(ac_delta, ev_delta, ego_change)
  --     local meets_ratio = ac_delta >= 0 or (ev_delta / -ac_delta > BRC.Tuning.armour.lighter[ego_change])
  --     if not meets_ratio then return false end

  --     -- Apply ego-specific restrictions
  --     if ego_change == LOST and ev_delta < BRC.Tuning.armour.lighter.min_gain then return false end
  --     if ego_change ~= SAME and -ac_delta > BRC.Tuning.armour.lighter.max_loss then return false end

  --     return true
  -- end

  -- local function should_alert_heavier_armour(ac_delta, ev_delta, ego_change)
  --     local meets_ratio = ev_delta >= 0 or (ac_delta / -ev_delta > BRC.Tuning.armour.heavier[ego_change])
  --     if not meets_ratio then return false end

  --     -- Apply ego-specific restrictions
  --     if ego_change == LOST and ac_delta < BRC.Tuning.armour.heavier.min_gain then return false end
  --     if ego_change ~= SAME and -ev_delta > BRC.Tuning.armour.heavier.max_loss then return false end

  --     return true
  -- end
end

-- If training armour in early/mid game, alert user to any armour that is the strongest found so far
local function alert_pa_high_score_ac(it)
  if not BRC.is.body_armour(it) then return false end
  if you.skill("Armour") == 0 then return false end
  if you.xl() > 12 then return false end

  if pa_high_score.ac == 0 then
    local worn = items.equipped_at("armour")
    if not worn then return false end
    pa_high_score.ac = BRC.get.armour_ac(worn)
  else
    local itAC = BRC.get.armour_ac(it)
    if itAC > pa_high_score.ac then
      pa_high_score.ac = itAC
      return f_pickup_alert.do_alert(it, "Highest AC", BRC.Emoji.STRONGEST, BRC.Config.fm_alert.high_score_armour)
    end
  end

  return false
end

local function alert_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end

  -- Always alert artefacts once identified
  if it.artefact then
    if not it.is_identified then return false end
    return send_armour_alert(it, ARMOUR_ALERT.artefact)
  end

  -- Get changes to ego, AC, EV, encumbrance
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  local ego_change = get_ego_change_type(cur_ego, it_ego)
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  local ev_delta = BRC.get.armour_ev(it) - BRC.get.armour_ev(cur)
  local encumb_delta = it.encumbrance - cur.encumbrance

  -- Alert new egos if same encumbrance, or small change to total (AC+EV)
  if is_new_ego(ego_change) then
    if encumb_delta == 0 then return send_armour_alert(it, ARMOUR_ALERT[ego_change]) end

    local weight = encumb_delta < 0 and LIGHTER or HEAVIER
    if math.abs(ac_delta + ev_delta) <= BRC.Tuning.armour[weight].ignore_small then
      return send_armour_alert(it, ARMOUR_ALERT[weight][ego_change])
    end
  end

  -- Alert for lighter/heavier armour, based on configured AC/EV ratio
  if encumb_delta < 0 then
    if should_alert_body_armour(LIGHTER, ev_delta, -ac_delta, ego_change) then
      return send_armour_alert(it, ARMOUR_ALERT.lighter[ego_change])
    end
  elseif encumb_delta > 0 then
    local adj_ev_delta = get_adjusted_ev_delta(encumb_delta, ev_delta)
    if should_alert_body_armour(HEAVIER, ac_delta, -adj_ev_delta, ego_change) then
      return send_armour_alert(it, ARMOUR_ALERT.heavier[ego_change])
    end
  end

  -- Alert for highest AC found so far, or early armour with any ego
  if alert_pa_high_score_ac(it) then return true end
  if it_ego and you.xl() <= BRC.Tuning.armour.early_xl then
    return f_pickup_alert.do_alert(it, "Early armour", BRC.Emoji.EGO)
  end
end

local function alert_shield(it)
  if it.artefact then
    if not it.is_identified then return false end
    return f_pickup_alert.do_alert(it, "Artefact shield", BRC.Emoji.ARTEFACT, BRC.Config.fm_alert.shields)
  end

  -- Don't alert shields if not wearing one (one_time_alerts fire for the first of each type)
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end

  -- Alert: New ego, Gain SH
  local ego_change = get_ego_change_type(BRC.get.ego(cur), BRC.get.ego(it))
  if is_new_ego(ego_change) then
    local alert_msg = ego_change == DIFF and "Diff ego" or "Gain ego"
    return f_pickup_alert.do_alert(it, alert_msg, BRC.Emoji.EGO, BRC.Config.fm_alert.shields)
  elseif BRC.get.shield_sh(it) > BRC.get.shield_sh(cur) then
    return f_pickup_alert.do_alert(it, "Higher SH", BRC.Emoji.STRONGER, BRC.Config.fm_alert.shields)
  end
end

local function alert_aux_armour(it, unworn_inv_item)
  if it.artefact then
    if not it.is_identified then return false end
    return f_pickup_alert.do_alert(it, "Artefact aux armour", BRC.Emoji.ARTEFACT, BRC.Config.fm_alert.aux_armour)
  end

  local all_equipped, num_slots = BRC.get.equipped_at(it)
  if #all_equipped < num_slots then
    if unworn_inv_item then
      all_equipped[#all_equipped + 1] = unworn_inv_item
    else
      -- Catch dangerous brands or items blocked by non-innate mutations
      return f_pickup_alert.do_alert(it, "Aux armour", BRC.Emoji.EXCLAMATION, BRC.Config.fm_alert.aux_armour)
    end
  end

  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local ego_change = get_ego_change_type(BRC.get.ego(cur), it_ego)
    if is_new_ego(ego_change) then
      local alert_msg = ego_change == DIFF and "Diff ego" or "Gain ego"
      return f_pickup_alert.do_alert(it, alert_msg, BRC.Emoji.EGO, BRC.Config.fm_alert.aux_armour)
    elseif BRC.get.armour_ac(it) > BRC.get.armour_ac(cur) then
      return f_pickup_alert.do_alert(it, "Higher AC", BRC.Emoji.STRONGER, BRC.Config.fm_alert.aux_armour)
    end
  end
end

-- Public API
function f_pa_armour.pickup_armour(it)
  if BRC.is.risky_item(it) then return false end

  if BRC.is.body_armour(it) then
    return pickup_body_armour(it)
  elseif BRC.is.shield(it) then
    return pickup_shield(it)
  else
    return pickup_aux_armour(it)
  end
end

--[[
    f_pa_armour.alert_armour() - Alerts armour items that didn't auto-pickup but are worth consideration.
    This comes after pickup, so there will be no pure upgrades.
    Optional `unworn_inv_item` param, to compare against an unworn aux armour item in inventory.
--]]
function f_pa_armour.alert_armour(it, unworn_inv_item)
  if BRC.is.body_armour(it) then
    return alert_body_armour(it)
  elseif BRC.is.shield(it) then
    return alert_shield(it)
  else
    return alert_aux_armour(it, unworn_inv_item)
  end
end

}
############################### End lua/features/pickup-alert/pa-armour.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-weapons.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-weapons
Description: Weapon pickup logic, caching, and alert system for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/util.lua
--]]

f_pa_weapons = {}
--f_pa_weapons.BRC_FEATURE_NAME = "pickup-alert-weapons"

-- Persistent variables
lowest_num_hands_alerted = BRC.data.persist("lowest_num_hands_alerted", {
  ["Ranged Weapons"] = 3, -- Start with 3 (to fire both 1 and 2-handed alerts)
  ["Polearms"] = 3, -- Start with 3 (to fire both 1 and 2-handed alerts)
}) -- lowest_num_hands_alerted (do not remove this comment)

-- Local constants / configuration
local FIRST_WEAPON_XL_CUTOFF = 4 -- Stop looking for first weapon after this XL
local RANGED_XL_THRESHOLD = 3 -- At this skill level, don't bother alerting for polearms
local RANGED = "range_"
local MELEE = "melee_"

-- Local variables
local top_attack_skill

-- Global variable: Cache weapons in inventory (so we don't recompute DPS, etc on every autopickup call)
_weapon_cache = {}

function _weapon_cache.get_primary_key(it)
  local tokens = {}
  tokens[1] = it.is_ranged and RANGED or MELEE
  tokens[2] = tostring(it.hands)
  if BRC.get.ego(it) then tokens[3] = "b" end
  return table.concat(tokens)
end

-- Get all categories this weapon fits into (both its real category and any more-restrictive categories)
function _weapon_cache.get_keys(is_ranged, hands, is_branded)
  local ranged_types = is_ranged and { RANGED, MELEE } or { MELEE }
  local handed_types = hands == 1 and { "1", "2" } or { "2" }
  local branded_types = is_branded and { "b", "" } or { "" }

  -- Generate all combinations
  local keys = {}
  for _, r in ipairs(ranged_types) do
    for _, h in ipairs(handed_types) do
      for _, b in ipairs(branded_types) do
        keys[#keys + 1] = table.concat({ r, h, b })
      end
    end
  end

  return keys
end

function _weapon_cache.add_weapon(it)
  local weap_data = {}
  weap_data.is_weapon = it.is_weapon
  weap_data.basename = it.name("base")
  weap_data._subtype = it.subtype()
  weap_data.subtype = function() return weap_data._subtype end -- For consistency in other code
  weap_data.weap_skill = it.weap_skill
  weap_data.skill_lvl = BRC.get.skill(it.weap_skill)
  weap_data.is_ranged = it.is_ranged
  weap_data.hands = BRC.get.hands(it)
  weap_data.artefact = it.artefact
  weap_data._ego = BRC.get.ego(it)
  weap_data.ego = function() return weap_data._ego end -- For consistency in other code
  weap_data.plus = it.plus or 0
  weap_data.acc = it.accuracy + weap_data.plus
  weap_data.damage = it.damage
  weap_data.dps = BRC.get.weap_dps(it)
  weap_data.score = BRC.get.weap_score(it)
  weap_data.unbranded_score = BRC.get.weap_score(it, true)

  -- Check for exclusion tags
  local lower_insc = it.inscription:lower()
  weap_data.allow_upgrade = not (lower_insc:find("!u", 1, true) or lower_insc:find("!brc", 1, true))

  -- Track unique egos
  if weap_data._ego and not util.contains(_weapon_cache.egos, weap_data._ego) then
    _weapon_cache.egos[#_weapon_cache.egos + 1] = weap_data._ego
  end

  -- Track max damage for applicable weapon categories
  local keys = _weapon_cache.get_keys(weap_data.is_ranged, weap_data.hands, weap_data._ego ~= nil)

  -- Update the max DPS for each category
  for _, key in ipairs(keys) do
    if weap_data.dps > _weapon_cache.max_dps[key].dps then
      _weapon_cache.max_dps[key].dps = weap_data.dps
      _weapon_cache.max_dps[key].acc = weap_data.acc
    end
  end

  _weapon_cache.weapons[#_weapon_cache.weapons + 1] = weap_data
  return weap_data
end

function _weapon_cache.is_empty()
  return _weapon_cache.max_dps["melee_2"].dps == 0 -- The most restrictive category
end

function _weapon_cache.serialize()
  local tokens = { "\n---INVENTORY WEAPONS---" }
  for _, weap in ipairs(_weapon_cache.weapons) do
    tokens[#tokens + 1] = string.format("\n%s\n", weap.basename)
    for k, v in pairs(weap) do
      if k ~= "basename" then tokens[#tokens + 1] = string.format("  %s: %s\n", k, tostring(v)) end
    end
  end
  return table.concat(tokens)
end

-- Local functions
-- is_weapon_upgrade(it, cur) -> boolean : For pickup; Check if a weapon is an upgrade to one currently in inventory.
-- `cur` comes from _weapon_cache - it has some pre-computed values
local function is_weapon_upgrade(it, cur)
  if it.subtype() == cur.subtype() then
    -- Exact weapon type match
    if it.artefact then return true end
    if cur.artefact then return false end
    local it_ego = BRC.get.ego(it)
    local cur_ego = BRC.get.ego(cur)
    if cur_ego and not it_ego then return false end
    if it_ego and it.is_identified and not cur_ego then
      return BRC.get.weap_score(it) / cur.score > BRC.Tuning.weap.pickup.add_ego
    end
    return it_ego == cur_ego and BRC.get.weap_score(it) > cur.score
  elseif it.weap_skill == cur.weap_skill or you.race() == "Gnoll" then
    -- Return false if no clear upgrade possible
    if BRC.get.hands(it) > cur.hands then return false end
    if cur.is_ranged ~= it.is_ranged then return false end
    if BRC.is.polearm(cur) ~= BRC.is.polearm(it) then return false end

    if it.artefact then return true end
    if cur.artefact then return false end

    local min_ratio = it.is_ranged and BRC.Tuning.weap.pickup.same_type_ranged or BRC.Tuning.weap.pickup.same_type_melee
    return BRC.get.weap_score(it) / cur.score > min_ratio
  end

  return false
end

local function need_first_weapon()
  return you.xl() < FIRST_WEAPON_XL_CUTOFF
    and _weapon_cache.is_empty()
    and you.skill("Unarmed Combat") == 0
    and BRC.get.mut(BRC.MUTATIONS.claws, true) == 0
end

-- Local functions: Alerting
local function alert_first_of_skill(it, silent)
  local skill = it.weap_skill
  if not lowest_num_hands_alerted[skill] then return false end

  local hands = BRC.get.hands(it)
  if lowest_num_hands_alerted[skill] > hands then
    -- Some early checks to skip alerts
    if hands == 2 and BRC.you.have_shield() then return false end
    if skill == "Polearms" and you.skill("Ranged Weapons") >= RANGED_XL_THRESHOLD then return false end

    -- Update lowest # hands alerted, and alert
    lowest_num_hands_alerted[skill] = hands
    if silent then return true end
    local msg = string.format("First %s%s", string.sub(skill, 1, -2), hands == 1 and " (1-handed)" or "")
    return f_pickup_alert.do_alert(it, msg, BRC.Emoji.WEAPON, BRC.Config.fm_alert.early_weap)
  end
  return false
end

local function alert_early_weapons(it)
  -- Alert really good usable ranged weapons
  if you.xl() <= BRC.Tuning.weap.alert.early_ranged.xl then
    if it.is_identified and it.is_ranged then
      if
        it.plus >= BRC.Tuning.weap.alert.early_ranged.min_plus and BRC.get.ego(it)
        or it.plus >= BRC.Tuning.weap.alert.early_ranged.branded_min_plus
      then
        local low_shield_training = you.skill("Shields") <= BRC.Tuning.weap.alert.early_ranged.max_shields
        if BRC.get.hands(it) == 1 or not BRC.you.have_shield() or low_shield_training then
          return f_pickup_alert.do_alert(it, "Ranged weapon", BRC.Emoji.RANGED, BRC.Config.fm_alert.early_weap)
        end
      end
    end
  end

  if you.xl() <= BRC.Tuning.weap.alert.early.xl then
    -- Skip items if we're clearly going another route
    local skill_setting = BRC.Tuning.weap.alert.early.skill
    local skill_diff = BRC.get.skill(top_attack_skill) - BRC.get.skill(it.weap_skill)
    if skill_diff > you.xl() * skill_setting.factor + skill_setting.offset then return false end

    local it_plus = it.plus or 0
    if BRC.get.ego(it) or it_plus and it_plus >= BRC.Tuning.weap.alert.early.branded_min_plus then
      return f_pickup_alert.do_alert(it, "Early weapon", BRC.Emoji.WEAPON, BRC.Config.fm_alert.early_weap)
    end
  end

  return false
end

--[[
alert_interesting_weapon() -> boolean : `cur` comes from _weapon_cache - it has some pre-computed values
Check if weapon is worth alerting for, compared against one weapon currently in inventory
--]]
local function alert_interesting_weapon(it, cur)
  if it.artefact and it.is_identified then return f_pickup_alert.do_alert(it, "Artefact weapon", BRC.Emoji.ARTEFACT) end

  local inv_best = _weapon_cache.max_dps[_weapon_cache.get_primary_key(it)]
  local best_dps = math.max(cur.dps, inv_best and inv_best.dps or 0)
  local best_score = math.max(cur.score, inv_best and BRC.get.weap_score(inv_best) or 0)

  if cur.subtype() == it.subtype() then
    -- Exact weapon type match; alert new egos or higher DPS/weap_score
    local it_ego = BRC.get.ego(it, true) -- Don't overvalue speed/heavy egos (only look at their DPS)
    local cur_ego = BRC.get.ego(cur)
    if not cur.artefact and it_ego and it_ego ~= cur_ego then
      local alert_msg = cur_ego and "Diff ego" or "Gain ego"
      return f_pickup_alert.do_alert(it, alert_msg, BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
    elseif BRC.get.weap_score(it) > best_score or BRC.get.weap_dps(it) > best_dps then
      return f_pickup_alert.do_alert(it, "Weapon upgrade", BRC.Emoji.WEAPON, BRC.Config.fm_alert.upgrade_weap)
    end
    return false
  end

  if cur.is_ranged ~= it.is_ranged then return false end
  if BRC.is.polearm(cur) ~= BRC.is.polearm(it) then return false end
  if 2 * BRC.get.skill(it.weap_skill) < BRC.get.skill(cur.weap_skill) then return false end

  -- Penalize lower-trained skills
  local damp = BRC.Tuning.weap.alert.low_skill_penalty_damping
  local penalty = (BRC.get.skill(it.weap_skill) + damp) / (BRC.get.skill(top_attack_skill) + damp)
  local ratio = penalty * BRC.get.weap_score(it) / best_score

  if BRC.get.hands(it) > cur.hands then
    if BRC.you.free_offhand() or (you.skill("Shields") < BRC.Tuning.weap.alert.add_hand.ignore_sh_lvl) then
      local it_ego = BRC.get.ego(it)
      local unique_ego = it_ego and not util.contains(_weapon_cache.egos, it_ego)
      if unique_ego and ratio > BRC.Tuning.weap.alert.new_ego then
        return f_pickup_alert.do_alert(it, "New ego (2-handed)", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
      elseif ratio > BRC.Tuning.weap.alert.add_hand.not_using then
        return f_pickup_alert.do_alert(it, "2-handed weapon", BRC.Emoji.TWO_HAND, BRC.Config.fm_alert.upgrade_weap)
      end
    elseif BRC.get.ego(it) and not BRC.get.ego(cur) and ratio > BRC.Tuning.weap.alert.add_hand.add_ego_lose_sh then
      local msg = "2-handed weapon (Gain ego)"
      return f_pickup_alert.do_alert(it, msg, BRC.Emoji.TWO_HAND, BRC.Config.fm_alert.weap_ego)
    end
  else -- No extra hand required
    if cur.artefact then return false end
    if BRC.get.ego(it, true) then -- Don't overvalue Speed/Heavy egos (only look at their DPS)
      local it_ego = BRC.get.ego(it)
      if not BRC.get.ego(cur) then
        if ratio > BRC.Tuning.weap.alert.gain_ego then
          return f_pickup_alert.do_alert(it, "Gain ego", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
        end
      elseif not util.contains(_weapon_cache.egos, it_ego) and ratio > BRC.Tuning.weap.alert.new_ego then
        return f_pickup_alert.do_alert(it, "New ego", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
      end
    end
    if ratio > BRC.Tuning.weap.alert.pure_dps then
      return f_pickup_alert.do_alert(it, "Weapon upgrade", BRC.Emoji.WEAPON, BRC.Config.fm_alert.upgrade_weap)
    end
  end

  return false
end

local function alert_interesting_weapons(it)
  for _, inv in ipairs(_weapon_cache.weapons) do
    if alert_interesting_weapon(it, inv) then return true end
  end
  return false
end

local function alert_weap_high_scores(it)
  local category = f_pa_data.update_high_scores(it)
  if not category then return false end
  return f_pickup_alert.do_alert(it, category, BRC.Emoji.WEAPON, BRC.Config.fm_alert.high_score_weap)
end

-- Public API
function f_pa_weapons.pickup_weapon(it)
  -- Check if we need the first weapon of the game
  if need_first_weapon() then
    -- Check if we're carrying a weapon that didn't go into _weapon_cache (like a staff)
    for inv in iter.invent_iterator:new(items.inventory()) do
      if inv.is_weapon then return false end
    end
    return true
  end

  if BRC.is.risky_item(it) then return false end
  for _, inv in ipairs(_weapon_cache.weapons) do
    if inv.allow_upgrade and is_weapon_upgrade(it, inv) then return true end
  end
end

function f_pa_weapons.alert_weapon(it)
  if alert_interesting_weapons(it) then return true end
  if alert_first_of_skill(it) then return true end
  if alert_early_weapons(it) then return true end

  -- Skip high score alerts if not using weapons
  if _weapon_cache.is_empty() then return false end
  return alert_weap_high_scores(it)
end

-- Hook functions
function f_pa_weapons.init()
  _weapon_cache.weapons = {}
  _weapon_cache.egos = {}

  -- Track max DPS by weapon category
  _weapon_cache.max_dps = {}
  local keys = { "melee_1", "melee_1b", "melee_2", "melee_2b", "range_1", "range_1b", "range_2", "range_2b" }
  for _, key in ipairs(keys) do
    _weapon_cache.max_dps[key] = { dps = 0, acc = 0 }
  end

  -- Set top weapon skill
  top_attack_skill = "Unarmed Combat"
  local max_weap_skill = BRC.get.skill(top_attack_skill)
  for _, v in ipairs(BRC.WEAP_SCHOOLS) do
    if BRC.get.skill(v) > max_weap_skill then
      max_weap_skill = BRC.get.skill(v)
      top_attack_skill = v
    end
  end
end

function f_pa_weapons.ready()
  f_pa_weapons:init()
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.is_weapon and not BRC.is.magic_staff(inv) then
      _weapon_cache.add_weapon(inv)
      f_pa_data.update_high_scores(inv)
    end
  end
end

}
############################### End lua/features/pickup-alert/pa-weapons.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-misc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-misc
Description: Miscellaneous item pickup logic and alert system for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
--]]

f_pa_misc = {}
--f_pa_misc.BRC_FEATURE_NAME = "pickup-alert-misc"

function f_pa_misc.alert_orb(it)
  if not it.is_identified then return false end
  return f_pickup_alert.do_alert(it, "New orb", BRC.Emoji.ORB, BRC.Config.fm_alert.orbs)
end

function f_pa_misc.alert_OTA(it)
  local ota_item = f_pa_data.find(pa_OTA_items, it)
  if not ota_item then return end

  local do_alert = true

  if BRC.is.shield(it) then
    if you.skill("Shields") < BRC.Config.alert.OTA_require_skill.shield then return end

    -- Don't alert if already wearing a larger shield
    if ota_item == "buckler" then
      if BRC.you.have_shield() then do_alert = false end
    elseif ota_item == "kite shield" then
      local sh = items.equipped_at("offhand")
      if sh and sh.name("qual") == "tower shield" then do_alert = false end
    end
  elseif BRC.is.armour(it) then
    if you.skill("Armour") < BRC.Config.alert.OTA_require_skill.armour then return end
  elseif it.is_weapon then
    if you.skill(it.weap_skill) < BRC.Config.alert.OTA_require_skill.weapon then return end
  end

  f_pa_data.remove(pa_OTA_items, it)
  if not do_alert then return false end
  return f_pickup_alert.do_alert(it, "Found first", BRC.Emoji.RARE_ITEM, BRC.Config.fm_alert.one_time_alerts)
end

function f_pa_misc.alert_staff(it)
  if not it.is_identified then return false end
  local needRes = false
  local basename = it.name("base")

  if basename == "staff of fire" then
    needRes = you.res_fire() == 0
  elseif basename == "staff of cold" then
    needRes = you.res_cold() == 0
  elseif basename == "staff of air" then
    needRes = you.res_shock() == 0
  elseif basename == "staff of poison" then
    needRes = you.res_poison() == 0
  elseif basename == "staff of death" then
    needRes = you.res_draining() == 0
  end

  if not needRes then return false end
  return f_pickup_alert.do_alert(it, "Staff resistance", BRC.Emoji.STAFF_RESISTANCE, BRC.Config.fm_alert.staff_resists)
end

function f_pa_misc.alert_talisman(it)
  if it.artefact then
    if not it.is_identified then return false end
    return f_pickup_alert.do_alert(it, "Artefact talisman", BRC.Emoji.TALISMAN, BRC.Config.fm_alert.talismans)
  end
  local required_skill = BRC.get.talisman_min_level(it) - BRC.Config.alert.talisman_lvl_diff
  if required_skill > BRC.you.shapeshifting_skill() then return false end
  return f_pickup_alert.do_alert(it, "New talisman", BRC.Emoji.TALISMAN, BRC.Config.fm_alert.talismans)
end

function f_pa_misc.is_unneeded_ring(it)
  if not BRC.is.ring(it) or it.artefact or you.race() == "Octopode" then return false end
  local missing_hand = BRC.get.mut(BRC.MUTATIONS.missing_hand, true)
  local st = it.subtype()
  local found_first = false
  for inv in iter.invent_iterator:new(items.inventory()) do
    if BRC.is.ring(inv) and inv.subtype() == st then
      if found_first or missing_hand then return true end
      found_first = true
    end
  end
  return false
end

function f_pa_misc.pickup_staff(it)
  return it.is_identified and BRC.get.skill(BRC.get.staff_school(it)) > 0
end

}
############################### End lua/features/pickup-alert/pa-misc.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-data
Description: Data management and persistent storage for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_pa_data = {}
--f_pa_data.BRC_FEATURE_NAME = "pickup-alert-data"

-- Persistent variables
pa_items_alerted = BRC.data.persist("pa_items_alerted", {})
pa_recent_alerts = BRC.data.persist("pa_recent_alerts", {})
pa_OTA_items = BRC.data.persist("pa_OTA_items", BRC.Config.alert.one_time)
pa_high_score = BRC.data.persist("pa_high_score", { ac = 0, weapon = 0, plain_dmg = 0 })

-- Local functions
local function get_pa_keys(it, use_plain_name)
  if it.class(true) == "bauble" then
    return it.name("qual"):gsub('"', ""), 0
  elseif BRC.is.talisman(it) or BRC.is.orb(it) then
    return it.name():gsub('"', ""), 0
  elseif BRC.is.magic_staff(it) then
    return it.name("base"):gsub('"', ""), 0
  else
    local name = it.name(use_plain_name and "plain" or "base"):gsub('"', "")
    local value = tonumber(name:sub(1, 3))
    if not value then return name, 0 end
    return util.trim(name:sub(4)), value
  end
end

-- Public API
-- Return name of first entry found in item name, or nil if not found
function f_pa_data.find(table_ref, it)
  if table_ref == pa_OTA_items then
    local qualname = it.name("qual")
    for _, v in ipairs(pa_OTA_items) do
      if v and qualname:find(v) then return v end
    end
  else
    local name, value = get_pa_keys(it)
    if table_ref[name] ~= nil and tonumber(table_ref[name]) >= value then return name end
  end
end

function f_pa_data.insert(table_ref, it)
  if table_ref == pa_recent_alerts then
    pa_recent_alerts[#pa_recent_alerts + 1] = f_pa_data.get_keyname(it)
  else
    local is_armour = BRC.is.armour(it, true)
    if not (it.is_weapon or is_armour or BRC.is.talisman(it)) then return end
    local name, value = get_pa_keys(it)
    local cur_val = tonumber(table_ref[name])
    if not cur_val or value > cur_val then table_ref[name] = value end

    -- For armour with good brand, also add the unbranded version to the table
    if is_armour and it.branded and not (it.artefact or BRC.is.risky_item(it)) then
      name = it.name("qual")
      cur_val = tonumber(table_ref[name])
      if not cur_val or value > cur_val then table_ref[name] = value end
    end
  end
end

function f_pa_data.remove(table_ref, it)
  if table_ref == pa_OTA_items then
    repeat
      local item_name = f_pa_data.find(pa_OTA_items, it)
      if item_name == nil then return end
      util.remove(pa_OTA_items, item_name)
    until item_name == nil
  elseif table_ref == pa_recent_alerts then
    util.remove(pa_recent_alerts, f_pa_data.get_keyname(it))
  else
    local name, _ = get_pa_keys(it)
    table_ref[name] = nil
  end
end

-- Get name with plus included and quotes removed; stored in pa_recent_alerts table
function f_pa_data.get_keyname(it, use_plain_name)
  local name, value = get_pa_keys(it, use_plain_name)
  if BRC.is.talisman(it) or BRC.is.orb(it) or BRC.is.magic_staff(it) then return name end
  if value >= 0 then value = string.format("+%s", value) end
  return string.format("%s %s", value, name)
end

-- Returns a string of the high score type if item sets a new high score, else nil
function f_pa_data.update_high_scores(it)
  if not it then return end
  local ret_val = nil

  if BRC.is.armour(it) then
    local ac = BRC.get.armour_ac(it)
    if ac > pa_high_score.ac then
      pa_high_score.ac = ac
      if not ret_val then ret_val = "Highest AC" end
    end
  elseif it.is_weapon then
    -- Don't alert for unusable weapons
    if BRC.get.hands(it) == 2 and not BRC.you.free_offhand() then return end

    local dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.branded)
    if dmg > pa_high_score.weapon then
      pa_high_score.weapon = dmg
      if not ret_val then ret_val = "Highest damage" end
    end

    dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.plain)
    if dmg > pa_high_score.plain_dmg then
      pa_high_score.plain_dmg = dmg
      if not ret_val then ret_val = "Highest plain damage" end
    end
  end

  return ret_val
end

-- Hook functions
function f_pa_data.init()
  -- Update alerts & tables for starting items
  for inv in iter.invent_iterator:new(items.inventory()) do
    f_pa_data.remove(pa_OTA_items, inv)
  end
end

}
############################### End lua/features/pickup-alert/pa-data.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-main.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert
Description: Comprehensive pickup and alert system for weapons, armour, and miscellaneous items
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua,
  pa-armour.lua, pa-data.lua, pa-misc.lua, pa-weapons.lua
--]]

f_pickup_alert = {}
f_pickup_alert.BRC_FEATURE_NAME = "pickup-alert"

-- Persistent variables
pa_num_autopickup_funcs = BRC.data.persist("pa_num_autopickup_funcs", #chk_force_autopickup + 1)

-- Local variables
local pause_pa_system

-- Local functions
local function has_configured_force_more(it)
  if it.artefact then
    if BRC.Config.fm_alert.artefact then return true end
    if BRC.Config.fm_alert.trained_artefacts and BRC.get.skill_with(it) > 0 then return true end
  end
  if BRC.Config.fm_alert.armour_ego and BRC.is.armour(it) and BRC.get.ego(it) then return true end
  return false
end

-- Public API
function f_pickup_alert.autopickup(it, _)
  if (
    pause_pa_system or
    you.have_orb() or
    BRC.get.ego(it) and not it.is_identified
  ) then return end

  local unworn_aux_item = nil -- Conditionally set for pa-alert-armour
  if it.is_useless then
    -- Allow alerts for useless aux armour, iff you're carrying one (implies a temporary mutation)
    if not BRC.is.aux_armour(it) then return end
    local st = it.subtype()
    for inv in iter.invent_iterator:new(items.inventory()) do
      local inv_st = inv.subtype()
      if inv_st and inv_st == st then
        unworn_aux_item = inv
        break
      end
    end
    if not unworn_aux_item then return end
  else
    -- Pickup main
    if f_pa_armour and BRC.Config.pickup.armour and BRC.is.armour(it) then
      if f_pa_armour.pickup_armour(it) then return true end
    elseif f_pa_misc and BRC.Config.pickup.staves and BRC.is.magic_staff(it) then
      if f_pa_misc.pickup_staff(it) then return true end
    elseif f_pa_weapons and BRC.Config.pickup.weapons and it.is_weapon then
      if f_pa_weapons.pickup_weapon(it) then return true end
    elseif f_pa_misc and f_pa_misc.is_unneeded_ring(it) then
      return false
    end
  end

  -- Not picking up this item. Now check for alerts.
  if not BRC.Config.alert.system_enabled or f_pa_data.find(pa_items_alerted, it) then return end

  if f_pa_misc and BRC.Config.alert.one_time and #BRC.Config.alert.one_time > 0 then
    if f_pa_misc.alert_OTA(it) then return end
  end

  if f_pa_misc and BRC.Config.alert.staff_resists and BRC.is.magic_staff(it) then
    if f_pa_misc.alert_staff(it) then return end
  elseif f_pa_misc and BRC.Config.alert.orbs and BRC.is.orb(it) then
    if f_pa_misc.alert_orb(it) then return end
  elseif f_pa_misc and BRC.Config.alert.talismans and BRC.is.talisman(it) then
    if f_pa_misc.alert_talisman(it) then return end
  elseif f_pa_armour and BRC.Config.alert.armour and BRC.is.armour(it) then
    if f_pa_armour.alert_armour(it, unworn_aux_item) then return end
  elseif f_pa_weapons and BRC.Config.alert.weapons and it.is_weapon then
    if f_pa_weapons.alert_weapon(it) then return end
  end
end

function f_pickup_alert.do_alert(it, alert_type, emoji, force_more)
  local item_name = f_pa_data.get_keyname(it, true)
  local alert_col
  if it.is_weapon then
    alert_col = BRC.AlertColor.weapon
    f_pa_data.update_high_scores(it)
    local weapon_info = string.format(" (%s)", BRC.get.weapon_stats(it))
    item_name = item_name .. BRC.text.color(BRC.AlertColor.weapon.stats, weapon_info)
  elseif BRC.is.body_armour(it) then
    alert_col = BRC.AlertColor.body_arm
    f_pa_data.update_high_scores(it)
    local ac, ev = BRC.get.armour_stats(it)
    local armour_info = string.format(" {%s, %s}", ac, ev)
    item_name = item_name .. BRC.text.color(BRC.AlertColor.body_arm.stats, armour_info)
  elseif BRC.is.armour(it) then
    alert_col = BRC.AlertColor.aux_arm
  elseif BRC.is.orb(it) then
    alert_col = BRC.AlertColor.orb
  elseif BRC.is.talisman(it) then
    alert_col = BRC.AlertColor.talisman
  else
    alert_col = BRC.AlertColor.misc
  end

  local tokens = {}
  tokens[1] = emoji and emoji or BRC.text.cyan("----")
  tokens[#tokens + 1] = BRC.text.color(alert_col.desc, string.format(" %s:", alert_type))
  tokens[#tokens + 1] = BRC.text.color(alert_col.item, string.format(" %s ", item_name))
  tokens[#tokens + 1] = tokens[1]
  BRC.mpr.que_optmore(force_more or has_configured_force_more(it), table.concat(tokens))

  f_pa_data.insert(pa_recent_alerts, it)
  f_pa_data.insert(pa_items_alerted, it)
  you.stop_activity()
  return true
end

-- Hook functions
function f_pickup_alert.init()
  BRC.log.debug("Initializing pickup-alert submodules...")
  local indent = "  "
  pause_pa_system = false
  f_pa_data.init()
  BRC.log.debug(indent .. "pa-data loaded")

  if f_pa_armour then
    if f_pa_armour.init then f_pa_armour.init() end
    BRC.log.debug(indent .. "pa-armour loaded")
  end

  if f_pa_weapons then
    if f_pa_weapons.init then f_pa_weapons.init() end
    BRC.log.debug(indent .. "pa-weapons loaded")
  end

  if f_pa_misc then
    if f_pa_misc.init then f_pa_misc.init() end
    BRC.log.debug(indent .. "pa-misc loaded")
  end

  -- Check for duplicate autopickup creation (affects local only)
  if pa_num_autopickup_funcs < #chk_force_autopickup then
    BRC.log.warning(table.concat({
      "Warning: Extra autopickup funcs detected. (Commonly from reloading a local game.)\n",
      "Expected: ", pa_num_autopickup_funcs, " but got: ", #chk_force_autopickup, "\n",
      "If this is not expected, restart crawl to clear its memory."
    }))
    if not BRC.mpr.yesno("Continue adding BRC autopickup function?") then
      BRC.log.info("Skipping BRC autopickup function.")
      return
    end
  end

  pa_num_autopickup_funcs = #chk_force_autopickup
end

function f_pickup_alert.c_assign_invletter(it)
  f_pa_misc.alert_OTA(it)
  f_pa_data.remove(pa_recent_alerts, it)

  -- Re-enable the alert, iff we are able to use another one
  if BRC.get.num_equip_slots(it) > 1 then
    f_pa_data.remove(pa_items_alerted, it)
  end

  -- Ensure we always stop for these autopickup types
  if it.is_weapon or BRC.is.armour(it) then
    f_pa_data.update_high_scores(it)
    you.stop_activity()
  end
end

function f_pickup_alert.c_message(text, channel)
  if channel == "multiturn" then
    if not pause_pa_system and text:find("ou start ", 1, true) then pause_pa_system = true end
  elseif channel == "plain" then
    if pause_pa_system and (text:find("ou stop ", 1, true) or text:find("ou finish ", 1, true)) then
      pause_pa_system = false
    elseif text:find("one exploring", 1, true) or text:find("artly explored", 1, true) then
      local tokens = { "Recent alerts:" }
      for _, v in ipairs(pa_recent_alerts) do
        tokens[#tokens + 1] = string.format("\n  %s", v)
      end
      if #tokens > 1 then BRC.mpr.que(table.concat(tokens), BRC.COLORS.magenta) end
      pa_recent_alerts = {}
    end
  end
end

function f_pickup_alert.ready()
  if pause_pa_system then return end
  f_pa_weapons.ready()
  f_pa_data.update_high_scores(items.equipped_at("armour"))
end

}
############################### End lua/features/pickup-alert/pa-main.lua ###############################
##########################################################################################
