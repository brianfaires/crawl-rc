## Standalone BRC Feature: bread-swinger
## Generated from: lua/features/bread-swinger.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace
BRC = { Config = { emojis = false } }

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.KEYS = { ENTER = 13, ESC = 27, ["Cntl-S"] = 20, ["Cntl-E"] = 5 }

BRC.MAGIC_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", conjuration = "Conjurations",
  death = "Necromancy", earth = "Earth Magic", fire = "Fire Magic", necromancy = "Necromancy",
} -- BRC.MAGIC_SCHOOLS (do not remove this comment)

BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant" }
BRC.LITTLE_RACES = { "Spriggan" }
BRC.SMALL_RACES = { "Kobold" }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll" }

---- Skills ----

BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant" }


f_bread_swinger = {}
f_bread_swinger.Config = {
  disabled = false, -- Disable by default
  allow_plant_damage = false, -- Allow damaging plants to rest
  walk_delay = 50, -- ms delay between walk commands. Makes visuals less jarring. 0 to disable.
  alert_slow_weap_min = 1.5, -- Alert when finding the slowest weapon yet, starting at this delay.
} -- f_bread_swinger.Config (do not remove this comment)

-- BRC module tables
BRC.Data = {}
BRC.eq = {}
BRC.it = {}
BRC.mpr = {}
BRC.opt = {}
BRC.txt = {}
BRC.util = {}
BRC.you = {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local _persist_names = {}
function BRC.Data.persist(name, default_value)
  -- If variable already exists (from chk_lua_save), use it
  -- Otherwise initialize from default
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = {}
      for k, v in pairs(default_value) do
        _G[name][k] = v
      end
    else
      _G[name] = default_value
    end
  end

  _persist_names[#_persist_names + 1] = name
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    local val_str
    if type(_G[name]) == "table" then
      -- Simple table serialization (basic, but works for simple tables)
      local parts = {}
      for k, v in pairs(_G[name]) do
        if type(v) == "string" then
          table.insert(parts, string.format('[%s] = "%s"', tostring(k), v))
        else
          table.insert(parts, string.format('[%s] = %s', tostring(k), tostring(v)))
        end
      end
      val_str = "{" .. table.concat(parts, ", ") .. "}"
    else
      val_str = tostring(_G[name])
    end
  return name .. " = " .. val_str .. "\\n"
  end)

  return _G[name]
end

-- BRC.eq module
local function get_adjusted_armour_pen(encumb, str)
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_shield_penalty(sh)
  return 2 * sh.encumbrance * sh.encumbrance
    * (27 - you.skill("Shields")) / 27
    / (25 + 5 * you.strength())
end

local function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Doesn't check brand or delay >=3, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):contains("woodcutter's axe") then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:contains("crossbow") or basename:contains("arbalest")
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

function BRC.eq.get_ego(it, no_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    ego = ego:lower()
    if BRC.eq.is_useless_ego(ego) or (no_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.it.is_body_armour(it) then
    local name = it.name("qual")
    local good_scales = name:contains("dragon scales") and not name:contains("steam")
    if name:contains("troll leather") or good_scales then return name end
  end

  return it.artefact and it.name() or nil
end

function BRC.eq.get_hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  local st = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end

function BRC.eq.get_weap_delay(it)
  local delay = it.delay - BRC.you.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.eq.get_ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.it.is_shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

function BRC.eq.is_useless_ego(ego)
  if BRC.MAGIC_SCHOOLS[ego] then
    return BRC.Config.unskilled_egos_usable or you.skill(BRC.MAGIC_SCHOOLS[ego]) > 0
  end

  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
    or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
    or ego == "pain" and you.skill("Necromancy") == 0
end

-- BRC.it module
function BRC.it.is_body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.it.is_shield(it)
  return it and it.is_shield()
end

-- BRC.mpr module
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, color)
  -- Avoid referencing BRC, to stay robust during startup
  color = color or "lightgrey"
  local msg = "[BRC] " .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

function BRC.mpr.debug(message, context)
  if BRC.Config.mpr.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Debug) " .. message)
  end
end

function BRC.mpr.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  you.stop_activity()
  crawl.redraw_screen()

  if not skip_more then
    crawl.more()
    crawl.redraw_screen()
  end

  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Error) " .. message)
  end
end

function BRC.mpr.info(message, context)
  log_message(message, context, BRC.COL.darkgrey)
end

function BRC.mpr.que(msg, color, channel)
  BRC.mpr.que_optmore(false, msg, color, channel)
end

function BRC.mpr.que_optmore(show_more, msg, color, channel)
  for _, q in ipairs(_mpr_queue) do
    if q.m == msg and q.ch == channel and q.more == show_more then return end
  end
  color = color or BRC.COL.lightgrey
  _mpr_queue[#_mpr_queue + 1] = { m = BRC.txt[color](msg), ch = channel, more = show_more }
end

function BRC.mpr.warning(message, context)
  log_message(message, context, BRC.COL.yellow)
  you.stop_activity()
  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Warning) " .. message)
  end
end

-- BRC.opt module
function BRC.opt.macro(key, function_name)
  if type(_G[function_name]) ~= "function" then
    BRC.mpr.error("Function %s is not a global function", function_name)
    return
  end

  -- Format msg for debugging and keycode for crawl.setopt()
  local key_str = nil
  if type(key) == "number" then
    -- Try to convert to key name for better debug msg
    for k, v in pairs(BRC.KEYS) do
      if v == key then
        key_str = "<<< " .. k .. " >>"
        break
      end
    end
    -- Format keycode string for crawl.setopt()
    key = "\\{" .. key .. "}"
    if key_str == nil then key_str = "<<< \\" .. key .. " >>" end
  end

  -- The << >> formatting protects against crawl thinking '<' is a tag
  if key_str == nil then key_str = "<<< '" .. key .. "' >>" end

  crawl.setopt(string.format("macros += M %s ===%s", key, function_name))

  BRC.mpr.debug(
    string.format(
      "Assigned macro: %s to key: %s",
      BRC.txt.magenta(function_name .. "()"),
      BRC.txt.lightred(key_str)
    )
  )
end

function BRC.opt.message_mute(pattern, create)
  local op = create and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.opt.single_turn_mute(pattern)
  BRC.opt.message_mute(pattern, true)
  _single_turn_mutes[#_single_turn_mutes + 1] = pattern
end

-- BRC.txt module
getmetatable("").__index.contains = BRC.txt.contains
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

local function tostr_list(var, pretty, indents)
  local tokens = {}
  for _, v in ipairs(var) do
    tokens[#tokens + 1] = limit_lines(BRC.txt.tostr(v, pretty, indents + 1))
  end
  if #tokens < 4 and not util.exists(var, function(t) return type(t) == "table" end) then
    return "{ " .. table.concat(tokens, ", ") .. " }"
  else
    local INDENT = string.rep("  ", indents)
    local CHILD_INDENT = string.rep("  ", indents + 1)
    local LIST_SEP = ",\n" .. CHILD_INDENT
    return "{\n" .. CHILD_INDENT .. table.concat(tokens, LIST_SEP) .. "\n" .. INDENT .. "}"
  end
end

local function tostr_map(var, pretty, indents)
  local tokens = {}

  if pretty then
    local keys = BRC.util.get_sorted_keys(var)
    local contains_table = false
    for i = 1, #keys do
      local v = limit_lines(BRC.txt.tostr(var[keys[i]], true, indents + 1))
      if v then
        if type(var[keys[i]]) == "table" then
          contains_table = true
          tokens[#tokens + 1] = string.format('["%s"] = %s', keys[i], v)
        else
          tokens[#tokens + 1] = string.format("%s = %s", keys[i], v)
        end
      end
    end
    if #tokens <= 2 and not contains_table then
      return "{ " .. table.concat(tokens, ", ") .. " }"
    end
  else
    for k, v in pairs(var) do
      local val_str = BRC.txt.tostr(v, pretty, indents + 1)
      if val_str then
        tokens[#tokens + 1] = '["' .. k .. '"] = ' .. val_str
      end
    end
  end

  local INDENT = string.rep("  ", indents)
  local CHILD_INDENT = string.rep("  ", indents + 1)
  local LIST_SEP = ",\n" .. CHILD_INDENT
  return "{\n" .. CHILD_INDENT .. table.concat(tokens, LIST_SEP) .. "\n" .. INDENT .. "}"
end

local function tostr_string(var, pretty)
  local s
  if var:contains("\n") then
    s = string.format("[[\n%s]]", var)
  else
    s = '"' .. var:gsub('"', "") .. '"'
  end

  if not pretty then return s end
  -- Replace > and < to display the color tags instead of colored text
  return s:gsub(">", "TempGT"):gsub("<", "TempLT"):gsub("TempGT", "<gt>"):gsub("TempLT", "<lt>")
end

function BRC.txt.contains(self, text)
  return self:find(text, 1, true) ~= nil
end

function BRC.txt.tostr(var, pretty, _indents)
  local var_type = type(var)
  if var_type == "string" then
    return tostr_string(var, pretty)
  elseif var_type == "table" then
    _indents = _indents or 0
    if BRC.util.is_list(var) then
      return tostr_list(var, pretty, _indents)
    elseif BRC.util.is_map(var) then
      return tostr_map(var, pretty, _indents)
    else
      return "{}"
    end
  end

  if BRC.Config.dump.omit_pointers and (var_type == "function" or var_type == "userdata") then
    return nil
  end

  return tostring(var) -- fallback to tostring()
end

-- BRC.util module
function BRC.util.cntl(c)
  return string.byte(c:upper()) - 64
end

function BRC.util.is_list(value)
  return value and type(value) == "table" and #value > 0
end

function BRC.util.is_map(value)
  return value and type(value) == "table" and next(value) ~= nil and #value == 0
end

-- BRC.you module
function BRC.you.free_offhand()
  if BRC.you.mut_lvl("missing a hand") > 0 then return true end
  return not items.equipped_at("offhand")
end

function BRC.you.mut_lvl(mutation, innate_only)
  return you.get_base_mutation_level(mutation, true, not innate_only, not innate_only)
end

function BRC.you.skill(skill)
  if skill and not skill:contains(",") then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local sum = 0
  local count = 0
  for _, s in ipairs(skills) do
    sum = sum + you.skill(s)
    count = count + 1
  end

  return sum / count
end

-- mpr queue support: _mpr_queue and BRC.mpr.consume_queue()
_mpr_queue = {}
function BRC.mpr.consume_queue()
  local do_more = util.exists(_mpr_queue, function(q) return q.more end)
  -- stop_activity() can generate more autopickups, and thus more queue'd messages
  if do_more then
    you.stop_activity()
    crawl.redraw_screen()
  end

  for _, msg in ipairs(_mpr_queue) do
    crawl.mpr(tostring(msg.m), msg.ch)
    crawl.flush_prev_message()
  end
  _mpr_queue = {}

  if do_more then
    crawl.more()
    crawl.redraw_screen()
  end
end

-- single turn mutes support: _single_turn_mutes and BRC.opt.clear_single_turn_mutes()
_single_turn_mutes = {}
function BRC.opt.clear_single_turn_mutes()
  util.foreach(_single_turn_mutes, function(m) BRC.opt.message_mute(m, false) end)
  _single_turn_mutes = {}
end

-- Feature code
---------------------------------------------------------------------------------------------------
-- BRC feature module: bread-swinger
-- @module f_bread_swinger
-- @author gammafunk, buehler
-- Efficient resting during turncount runs, by wielding slow weapons, or walking back and forth.
-- Based on: https://github.com/gammafunk/dcss-rc/blob/master/speedrun_rest.lua
---------------------------------------------------------------------------------------------------



---- Persistent variables ----
bs_manual_swing_slot = BRC.Data.persist("bs_manual_swing_slot", nil)
bs_highest_delay = BRC.Data.persist("bs_highest_delay", 0)
bs_highest_delay_1h = BRC.Data.persist("bs_highest_delay_1h", 0)

---- Local constants ----
local DIR_TO_VI = {
  [-1] = { [-1] = "y", [0] = "h", [1] = "b" },
  [0] = { [-1] = "k", [1] = "j" },
  [1] = { [-1] = "u", [0] = "l", [1] = "n" },
} -- DIR_TO_VI (do not remove this comment)

local SOLID_FEATURES = {
  "wall", "grate", "tree", "mangrove", "endless_lava", "open_sea", "statue", "idol",
  "malign_gateway", "sealed_door", "closed_door", "runed_door", "explore_horizon"
} -- SOLID_FEATURES (do not remove this comment)

---- Local variables ----
local C -- config alias
local swing_slot
local turns_remaining
local turns_to_rest
local rest_type
local wielding
local dir

---- Local functions ----
local function reset_rest(msg)
  -- Display msg iff we're aborting a rest command
  if turns_remaining and turns_remaining > 0 and msg then
    if turns_remaining ~= turns_to_rest then
      local diff = turns_to_rest - turns_remaining
      msg = string.format("%s (Rested %s/%s turns)", msg, diff, turns_to_rest)
    end
    BRC.mpr.warning(msg)
  end

  swing_slot = nil
  turns_remaining = 0
  turns_to_rest = 0
  rest_type = nil
  wielding = false
  dir = { x = nil, y = nil }
end

local function get_num_turns()
  BRC.mpr.info(BRC.txt.white("Enter number of turns to rest")
    .. " (Esc to manually set weapon slot): ")
  local input = crawl.c_input_line()
  local turns = tonumber(input)
  if not turns then
    return nil
  elseif turns <= 0 then
    BRC.mpr.warning("Must be a positive number!")
    return 0
  end
  return turns
end

local function do_alert(msg, it)
  local tokens = {}
  tokens[1] = BRC.Config.emojis and "ðŸž " or BRC.txt.cyan("---- ")
  tokens[#tokens + 1] = msg .. ": "
  tokens[#tokens + 1] = BRC.txt.cyan(it.name() .. " (")
  tokens[#tokens + 1] = BRC.txt.lightmagenta(string.format("%.2f", BRC.eq.get_weap_delay(it)))
  tokens[#tokens + 1] = BRC.txt.cyan(") ")
  tokens[#tokens + 1] = tokens[1]
  BRC.mpr.que(table.concat(tokens))
  you.stop_activity()
end

-- Weapon functions
local function weapon_can_swap()
  local weapon = items.equipped_at("Weapon")
  if not weapon then return true end

  if weapon.ego() == "distortion" and you.god() ~= "Lugonu" then return false end

  if weapon.artefact then
    local artp = weapon.artprops
    return not (artp["*Contam"] or artp["*Drain"])
  end

  return true
end

local function get_slowest_slot()
  local slowest_slot = nil
  local largest_delay = 0
  for _, item in ipairs(items.inventory()) do
    if item.class() == "Hand Weapons" and BRC.eq.get_weap_delay(item) > largest_delay then
      largest_delay = BRC.eq.get_weap_delay(item)
      slowest_slot = item.slot
    end
  end

  if not slowest_slot then return nil end
  return items.index_to_letter(slowest_slot)
end

local function swing_item_wielded()
  local weapon = items.equipped_at("Weapon")
  if not weapon or not swing_slot then return false end
  return weapon.slot == items.letter_to_index(swing_slot)
end

local function wield_swing_item()
  if not swing_slot then return end
  wielding = true
  BRC.opt.single_turn_mute(swing_slot .. " - ")
  crawl.sendkeys({ "w", "*", swing_slot })
  crawl.flush_input()
end

-- Feature checks
local function is_water(x, y)
  local feat = view.feature_at(x, y)
  return feat and feat:contains("water") and not you.status("flying")
end

local function is_monster(x, y)
  local mon = monster.get_monster_at(x, y)
  return mon and not (C.allow_plant_damage and mon.is_stationary())
end

local function is_solid(x, y)
  local feat = view.feature_at(x, y):lower()
  return util.exists(SOLID_FEATURES, function(f) return feat:find(f) end)
end

-- Setting direction to move or swing
local function is_good_dir_walk(x, y)
  if x == 0 and y == 0 then return false end
  return is_water(x, y) == is_water(0, 0)
    and view.is_safe_square(x, y)
    and not is_solid(x, y)
    and not monster.get_monster_at(x, y)
end

local function is_good_dir_swing(x, y)
  if x == 0 and y == 0 then return false end
  local weapon = items.equipped_at("Weapon")
  if not weapon then return false end

  if weapon.is_ranged then
    -- Confirm no monsters in straight line
    for i = 1, you.los() do
      local cur_x = i * x
      local cur_y = i * y
      if is_monster(cur_x, cur_y) then return false end
      if is_solid(cur_x, cur_y) then break end
    end
  elseif weapon.weap_skill:contains("Axes") then
    -- Confirm no monsters in adjacent squares
    for cur_x = -1, 1 do
      for cur_y = -1, 1 do
        if is_monster(cur_x, cur_y) then return false end
      end
    end
  else
    return not is_solid(x, y) and not is_monster(x, y)
  end

  return true
end

local function get_good_direction()
  local func_is_good_dir = rest_type == "walk" and is_good_dir_walk or is_good_dir_swing
  for x = -1, 1 do
    for y = -1, 1 do
      if func_is_good_dir(x, y) then return x, y end
    end
  end
  return nil
end

local function set_good_direction()
  if rest_type == "walk" and dir.x ~= nil then
    -- Try to move back and forth by saving next dir
    if is_good_dir_walk(dir.x, dir.y) then return true end
    dir.x = nil
  end
  if dir.x == nil or not is_good_dir_swing(dir.x, dir.y) then
    dir.x, dir.y = get_good_direction()
    if not dir.x then
      reset_rest("No good direction found!")
      return false
    end
  end

  return true
end

-- Resting
local function set_rest_type()
  local inv = items.inslot(items.letter_to_index(swing_slot))
  if not swing_slot
    or (not swing_item_wielded() and not weapon_can_swap())
    or you.movement_cost and you.movement_cost() > 10 * BRC.eq.get_weap_delay(inv)
  then
    rest_type = "walk"
  else
    rest_type = "item"
  end
end

local function verify_safe_rest()
  local hp, mhp = you.hp()
  if hp == mhp then
    reset_rest("You are already at full health!")
    return false
  elseif turns_remaining <= 0 then
    reset_rest()
    return false
  elseif not you.feel_safe() then
    reset_rest("You can't rest with a hostile monster in view!")
    return false
  elseif rest_type == "walk" then
    if you.movement_cost and you.movement_cost() <= 10 then
      reset_rest("You can't walk slowly right now!")
      return false
    elseif you.status("manticore barbs") then
      reset_rest("You must remove the manticore barbs first.")
      return false
    end
  end
  return true
end

local function do_resting()
  if not set_good_direction() then return end

  if rest_type == "item" then
    BRC.opt.single_turn_mute("You swing at nothing.")
    BRC.opt.single_turn_mute("You shoot ")
    crawl.sendkeys({ BRC.util.cntl(DIR_TO_VI[dir.x][dir.y]) })
    crawl.flush_input()
  else
    -- Save the return direction as our next direction
    local cur_x = dir.x
    local cur_y = dir.y
    dir.x = -dir.x
    dir.y = -dir.y
    crawl.sendkeys({ DIR_TO_VI[cur_x][cur_y] })
    crawl.flush_input()

    if C.walk_delay > 0 then crawl.delay(C.walk_delay) end
  end

  turns_remaining = turns_remaining - 1
  if turns_remaining <= 0 then
    BRC.mpr.green("Resting complete. (" .. turns_to_rest .. " turns)")
    reset_rest()
  end
end


---- Public API ----
function macro_brc_bread_swing(turns)
  turns_to_rest = turns or get_num_turns()
  if not turns_to_rest then
    f_bread_swinger.set_swing_slot()
    return
  elseif turns_to_rest <= 0 then
    return
  end
  turns_remaining = turns_to_rest

  -- Set swing slot
  local slowest_slot = get_slowest_slot()
  swing_slot = bs_manual_swing_slot or slowest_slot
  if not swing_slot then return end
  local weap = items.inslot(items.letter_to_index(swing_slot))
  if not weap or not weap.is_weapon then
    BRC.mpr.warning("Swing slot " .. BRC.txt.lightmagenta(swing_slot) .. " is not a weapon!")
    return
  end

  -- Determine rest type
  set_rest_type()
  if rest_type == "walk" and turns_to_rest % 2 == 1 then
    turns_to_rest = turns_to_rest - 1
    turns_remaining = turns_remaining - 1
  end

  f_bread_swinger.ready()
end

function f_bread_swinger.set_swing_slot()
  BRC.mpr.info(BRC.txt.white("Enter the inventory slot") .. " for the swing item: ")
  local letter = crawl.getch()
  if not letter or letter < string.byte('A') or letter > string.byte('z') then
    bs_manual_swing_slot = nil
    BRC.mpr.info(BRC.txt.magenta("Swing slot cleared.") .. " (Must be a letter a-z or A-Z).")
    return
  end
  bs_manual_swing_slot = string.char(letter)
  BRC.mpr.info(BRC.txt.lightgrey("Set swing slot to " .. BRC.txt.cyan(bs_manual_swing_slot) .. "."))
end

---- Initialization ----
function f_bread_swinger.init()
  C = f_bread_swinger.Config
  reset_rest()
  BRC.opt.macro("5", "macro_brc_bread_swing")
end

---- Crawl hook functions ----
function f_bread_swinger.c_message(_, channel)
  if turns_remaining <= 0 then return end
  if channel == "recovery" or channel == "duration" then return end
  reset_rest() -- Stop on any unrecognized message
end

function f_bread_swinger.ready()
  if not turns_remaining or turns_remaining <= 0 then return end
  if not verify_safe_rest() then return end

  if wielding and not swing_item_wielded() then
    -- An error happened with the 'w' command
    reset_rest("Unable to wield swing item on slot " .. swing_slot .. "!")
    return
  end

  if rest_type == "item" and not swing_item_wielded() then
    wield_swing_item()
  else
    do_resting()
  end
end

function f_bread_swinger.autopickup(it)
  if it.is_useless or not it.is_weapon then return nil end
  local delay = BRC.eq.get_weap_delay(it)
  if delay < C.alert_slow_weap_min then return nil end

  if delay > bs_highest_delay and (BRC.eq.get_hands(it) == 1 or BRC.you.free_offhand()) then
    bs_highest_delay = delay
    if BRC.eq.get_hands(it) == 1 then bs_highest_delay_1h = delay end
    do_alert("Found slowest weapon", it)
  elseif delay > bs_highest_delay_1h
    and BRC.eq.get_hands(it) == 1
    and not BRC.you.free_offhand()
  then
    bs_highest_delay_1h = delay
    do_alert("Found slowest 1-handed weapon", it)
  end
end


-- Crawl hook wrappers
add_autopickup_func(f_bread_swinger.autopickup)

function c_message(...)
  return f_bread_swinger.c_message(...)
end

local brc_last_turn = -1
function ready(...)
  BRC.opt.clear_single_turn_mutes()
  if you.turns() > brc_last_turn then
    brc_last_turn = you.turns()
    f_bread_swinger.ready(...)
  end
  BRC.mpr.consume_queue()
end


-- Initialize feature
f_bread_swinger.init()

}
