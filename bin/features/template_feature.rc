## Standalone BRC Feature: template_feature
## Generated from: lua/features/_template.lua
## This file is self-contained and can be copy-pasted into your RC file.
## No external dependencies required.

{

-- Minimal BRC namespace
BRC = { Config = { emojis = false } }

-- BRC Constants
BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)


-- BRC module tables
BRC.Data = {}
BRC.mpr = {}
BRC.txt = {}
BRC.util = {}

-- BRC.Data module
-- Minimal persistence system for standalone features
local _persist_names = {}
function BRC.Data.persist(name, default_value)
  -- If variable already exists (from chk_lua_save), use it
  -- Otherwise initialize from default
  if _G[name] == nil then
    if type(default_value) == "table" then
      _G[name] = {}
      for k, v in pairs(default_value) do
        _G[name][k] = v
      end
    else
      _G[name] = default_value
    end
  end

  _persist_names[#_persist_names + 1] = name
  table.insert(chk_lua_save, function()
    if _G[name] == nil then return "" end
    local val_str
    if type(_G[name]) == "table" then
      -- Simple table serialization (basic, but works for simple tables)
      local parts = {}
      for k, v in pairs(_G[name]) do
        if type(v) == "string" then
          table.insert(parts, string.format('[%s] = "%s"', tostring(k), v))
        else
          table.insert(parts, string.format('[%s] = %s', tostring(k), tostring(v)))
        end
      end
      val_str = "{" .. table.concat(parts, ", ") .. "}"
    else
      val_str = tostring(_G[name])
    end
  return name .. " = " .. val_str .. "\\n"
  end)

  return _G[name]
end

-- BRC.mpr module
local _mpr_queue = {}
for k, color in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.txt[color](msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[color] = BRC.mpr[k]
end

local function log_message(message, context, color)
  -- Avoid referencing BRC, to stay robust during startup
  color = color or "lightgrey"
  local msg = "[BRC] " .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

function BRC.mpr.debug(message, context)
  if BRC.Config.mpr.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Debug) " .. message)
  end
end

function BRC.mpr.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  you.stop_activity()
  crawl.redraw_screen()

  if not skip_more then
    crawl.more()
    crawl.redraw_screen()
  end

  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Error) " .. message)
  end
end

function BRC.mpr.warning(message, context)
  log_message(message, context, BRC.COL.yellow)
  you.stop_activity()
  if BRC.Config.mpr.debug_to_stderr then
    crawl.stderr("[BRC] (Warning) " .. message)
  end
end

-- BRC.txt module
getmetatable("").__index.contains = BRC.txt.contains
for k, color in pairs(BRC.COL) do
  BRC.txt[k] = function(text)
    return string.format("<%s>%s</%s>", color, tostring(text), color)
  end
  BRC.txt[color] = BRC.txt[k]
end

local function tostr_list(var, pretty, indents)
  local tokens = {}
  for _, v in ipairs(var) do
    tokens[#tokens + 1] = limit_lines(BRC.txt.tostr(v, pretty, indents + 1))
  end
  if #tokens < 4 and not util.exists(var, function(t) return type(t) == "table" end) then
    return "{ " .. table.concat(tokens, ", ") .. " }"
  else
    local INDENT = string.rep("  ", indents)
    local CHILD_INDENT = string.rep("  ", indents + 1)
    local LIST_SEP = ",\n" .. CHILD_INDENT
    return "{\n" .. CHILD_INDENT .. table.concat(tokens, LIST_SEP) .. "\n" .. INDENT .. "}"
  end
end
local function tostr_map(var, pretty, indents)
  local tokens = {}

  if pretty then
    local keys = BRC.util.get_sorted_keys(var)
    local contains_table = false
    for i = 1, #keys do
      local v = limit_lines(BRC.txt.tostr(var[keys[i]], true, indents + 1))
      if v then
        if type(var[keys[i]]) == "table" then
          contains_table = true
          tokens[#tokens + 1] = string.format('["%s"] = %s', keys[i], v)
        else
          tokens[#tokens + 1] = string.format("%s = %s", keys[i], v)
        end
      end
    end
    if #tokens <= 2 and not contains_table then
      return "{ " .. table.concat(tokens, ", ") .. " }"
    end
  else
    for k, v in pairs(var) do
      local val_str = BRC.txt.tostr(v, pretty, indents + 1)
      if val_str then
        tokens[#tokens + 1] = '["' .. k .. '"] = ' .. val_str
      end
    end
  end

  local INDENT = string.rep("  ", indents)
  local CHILD_INDENT = string.rep("  ", indents + 1)
  local LIST_SEP = ",\n" .. CHILD_INDENT
  return "{\n" .. CHILD_INDENT .. table.concat(tokens, LIST_SEP) .. "\n" .. INDENT .. "}"
end
local function tostr_string(var, pretty)
  local s
  if var:contains("\n") then
    s = string.format("[[\n%s]]", var)
  else
    s = '"' .. var:gsub('"', "") .. '"'
  end

  if not pretty then return s end
  -- Replace > and < to display the color tags instead of colored text
  return s:gsub(">", "TempGT"):gsub("<", "TempLT"):gsub("TempGT", "<gt>"):gsub("TempLT", "<lt>")
end

function BRC.txt.contains(self, text)
  return self:find(text, 1, true) ~= nil
end

function BRC.txt.tostr(var, pretty, _indents)
  local var_type = type(var)
  if var_type == "string" then
    return tostr_string(var, pretty)
  elseif var_type == "table" then
    _indents = _indents or 0
    if BRC.util.is_list(var) then
      return tostr_list(var, pretty, _indents)
    elseif BRC.util.is_map(var) then
      return tostr_map(var, pretty, _indents)
    else
      return "{}"
    end
  end

  if BRC.Config.dump.omit_pointers and (var_type == "function" or var_type == "userdata") then
    return nil
  end

  return tostring(var) -- fallback to tostring()
end

-- BRC.util module
function BRC.util.is_list(value)
  return value and type(value) == "table" and #value > 0
end

function BRC.util.is_map(value)
  return value and type(value) == "table" and next(value) ~= nil and #value == 0
end

-- Feature code
---------------------------------------------------------------------------------------------------
-- BRC feature module: template_feature
-- @module f_template
-- @author Your Name
-- Description of what this feature does.
---------------------------------------------------------------------------------------------------

-- Core definitions: module, feature name, and config
f_template = {}

f_template.Config = {
  example_boolean = true,
  example_number = 42,
  example_list = { "Done exploring.", "A gnoll comes into view." },
  example_map = {
    key1 = 1,
    key2 = 2,
    ["100"] = "value for key=100",
  }, -- Include comma or comment after a lone "}" to avoid RC parser errors
} -- f_template.Config (Always add a comment to a line with only "}"). Or crawl's RC parser breaks

---- Persistent variables ---- (Defined globally, so give them unique names)
persistent_int = BRC.Data.persist("persistent_int", 0)
persistent_bool = BRC.Data.persist("persistent_bool", false)
persistent_list = BRC.Data.persist("persistent_list", {})
persistent_map = BRC.Data.persist("persistent_map", {})

---- Local constants ----
local CONSTANT_STRING = "Hand Weapons"

---- Local variables ----
local C -- config alias
-- Declare locals, but initialize their values in init()
local local_var
local local_table

---- Initialization ----
function f_template.init()
  -- Called when game opens, or re-init after loading a new config
  C = f_template.Config
  local_var = CONSTANT_STRING
  local_table = { local_var }

  persistent_int = persistent_int + 1
  persistent_map.num_startups = persistent_int

  if C.example_boolean then BRC.mpr.debug("Template feature initialized.") end
end

---- Local functions ----

---- Crawl hook functions (Remove any hooks you don't need) ----
function f_template.ready()
  -- Called at the start of each turn
  if you.turns() == C.example_number then BRC.mpr.blue("Hit magic number!") end
end

function f_template.autopickup(it)
  -- When considering autopickup for an item. Any function returning false will block the pickup.
  -- Can also use this function to do checks on each item you find, and just return nil at the end.
  if it.is_ranged then return true end -- Picks up every ranged weapon you find
  return nil -- Return nil for no opinion
end

function f_template.c_message(text, channel)
  -- React to incoming messages
  crawl.mpr(string.format("Got message: '%s' on channel %s", text, channel), channel)
end

function f_template.c_answer_prompt(prompt)
  -- Respond to prompts (return true/false or nil)
  if util.contains(persistent_list, prompt) then return true end
  return nil -- Don't answer
end

function f_template.c_assign_invletter(it)
  -- Inventory letter assignment; fires on every pickup of a new item
  if util.contains(local_table, it.class()) then return 0 end -- Equipment slot 'a'
  return nil
end


-- Crawl hook wrappers
function autopickup(...)
  if f_template.autopickup then
    return f_template.autopickup(...)
  end
end
add_autopickup_func(f_template.autopickup)
function c_answer_prompt(...)
  if f_template.c_answer_prompt then
    return f_template.c_answer_prompt(...)
  end
end
function c_assign_invletter(...)
  if f_template.c_assign_invletter then
    return f_template.c_assign_invletter(...)
  end
end
function c_message(...)
  if f_template.c_message then
    return f_template.c_message(...)
  end
end
function ready(...)
  if f_template.ready then
    return f_template.ready(...)
  end
end

-- Initialize feature
f_template.init()

}