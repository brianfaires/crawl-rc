

########.\init.txt########

#################################
####### Main options ############
#################################
autofight_stop = 65
item_stack_summary_minimum = 8
default_manual_training = true
show_more = false
autofight_caught = true
rest_wait_both = true
rest_wait_ancestor = true
sort_menus = true:equipped,art,ego,glowing,identified,basename,qualname,>qty
drop_filter += useless_item, forbidden
fire_order = silver javelin, javelin, silver boomerang, boomerang, curare-tipped dart, poisoned dart, stone
hp_warning = 20


#################################
####### Explore options #########
#################################
explore_delay = -1
travel_delay = -1
rest_delay = -1
view_delay = 500
show_travel_trail = true

explore_greedy_visit = artefacts,glowing_items,stacks
explore_stop = artefacts,altars,branches,portals,runed_doors,greedy_pickup_smart
explore_stop_pickup_ignore += scroll, potion, wand, stone, dart, boomerang, javelin

autopickup_exceptions ^= <potions? of attraction, <potions? of lignification, <potions? of mutation
autopickup_exceptions ^= <scrolls? of immolation, <scrolls? of poison
autopickup_exceptions ^= >useless_item, <misc


#############################
####### RC files ############
#############################

### Mostly normal RC options ###


########macros.rc########

bindkey = [~] CMD_LUA_CONSOLE


# Auto drop filter macro
macros += M d d,

# Numpad keymaps
macros += K \{-1019} f
macros += K \{-1018} 3
macros += K \{-1016} \{9}
macros += K \{-1015} 2
macros += K \{-1012} 1
macros += K \{-1010} o
macros += K \{-1000} .
macros += K \{-247} 5
macros += K2 \{-1019} .

# Spellcasting macros
macros += M 1 za
macros += M 2 zb
macros += M 3 zc
macros += M 4 zd
macros += M 6 zf
macros += M 7 zg
macros += M 8 zh
macros += M 9 zi
macros += M 0 zj

# Confirm targeting with same keys as spellcasting
macros += K2 \{-1018} \{13}
macros += K2 \{-1015} \{13}
macros += K2 \{-1012} \{13}
macros += K2 1 \{13}
macros += K2 2 \{13}
macros += K2 4 \{13}
macros += K2 6 \{13}
macros += K2 7 \{13}
macros += K2 8 \{13}
macros += K2 9 \{13}
macros += K2 0 \{13}


########runrest.rc########

# Aliases
stop := runrest_stop_message
ignore := runrest_ignore_message


# Monsters to ignore at a distance
runrest_ignore_monster += fire vortex:1
runrest_ignore_monster += neutral:1

# Message mutes: CAREFUL WITH THESE!
message_colour += mute:plain:No target in view!

# Stop for consumables you want to use immediately
stop += potions? of experience
stop += scrolls? of acquirement

# Don't stop for noisy doors unless someone shouts back
stop -= it creaks loudly
stop -= flies open with a bang
stop += You hear

# Re-enable stops for all ally actions then ignore some
ignore -= friend_action:
ignore -= friend_spell:
ignore -= friend_enchant:
ignore ^= butterfly disappears
ignore ^= friend_action:(a|the) web
ignore ^= friend_action:(seems|blinks)
stop += friend_action:
stop += friend_spell:
stop += friend_enchant:
stop += appears from out of your range of vision
stop += hits your
stop += your.*is destroyed

# Expiring effects; Turn on transmutation|flight|swiftness ending and ignore the rest
ignore -= transformation is almost over\.
ignore -= transformation has ended\.
ignore -= revert to a slightly less stony form\.
ignore -= revert to your normal fleshy form\.
ignore -= You feel yourself come back to life
ignore ^= Your unholy channel is weakening
stop ^= Your transformation is almost over
stop ^= Your transformation has ended
stop ^= revert to a slightly less stony form\.
stop ^= You revert to your normal fleshy form
stop ^= You feel yourself come back to life
stop ^= Your unholy channel expires
stop ^= You are starting to lose your buoyancy
stop ^= You feel.*sluggish
# Expiring effects for friends too
stop ^= no longer petrified
ignore += no longer covered in acid
# Rest through recovery (this is turned back on below when resting from full hp/mp)
ignore += recovery:.*
ignore += duration:.*

# Misc
stop -= You now have enough gold to
ignore += nearby plant withers and dies
ignore += disentangle yourself
ignore += You swap places.

########fm-messages.rc########

# Alias
more := force_more_message

# Remove annoying defaults
more -= You have reached level
more -= The lock glows eerily
more -= Heavy smoke blows from the lock
more -= The gate opens wide
more -= With a soft hiss the gate opens wide
more -= You pick up the .* rune and feel its power


# Significant spells/effects ending
more += is no longer charmed
more += You are starting to lose your buoyancy
# Death's Door
more += time is.*running out
more += life is in your own
# Death channel
more += unholy channel is weakening


# Monsters doing things
more += monster_warning:wielding.*of chaos
more += monster_warning:carrying a wand of
more += monster_warning:curare
more += (?<!You)(?<!yourself) speeds? up
more += danger:goes berserk
more += The forest starts to sway and rumble
more += begins to recite a word of recall
more += doors? slams? shut
more += blows on a signal horn
more += The.*offers itself to Yredelemnul
more += Deactivating autopickup
more += Your?.*suddenly stops? moving
more += There is.*feeling in your soul
more += swoops through the air toward you
more += Its appearance distorts for a moment
more += wretched star pulses
more += Strange energies course through your body


# Crowd control
more += You ((?<!( too|less)) confused|blown|knocked back|mesmerised|trampled|stumble backwards|encased|(?<!hands )slow.*down|lose consciousness)
more += infuriates you
more += danger:Space.*around you
more += hits you.*distortion
more += The pull of.*song draws you forward
more += The.*engulfs you in water
more += surroundings become eerily quiet
more += Your limbs are stiffening
more += Your magical effects are unraveling
more += Your magical defenses are stripped away
more += You stop (a|de)scending the stairs
more += A sentinel's mark forms upon you


# Clouds
more += danger:(calcify|mutagenic)
more += You are engulfed in.*miasma
more += Miasma billows from the


# You Screwed Up
more += power of Zot
more += is no longer ready
more += You really shouldn't be using
more += You don't have enough magic to cast this spell
more += Your body shudders with the violent release


# Found something important
more += Found a staircase to the Ecumenical Temple
more += timed_portal:.*
more += Found.*(treasure|bazaar|ziggurat)
more += .*resides here
more += You have a vision of.*gates?


# Translocations
more += You blink
more += danger:You feel strangely .*stable
more += danger:sense of stasis
more += Your surroundings.*(different|flicker)
more += You are suddenly pulled into a different region
more += delayed


# Big damage
more += your body is wracked
more += Ouch! That really hurt!
more += silver sears you
more += The poison in your body grows stronger
more += You.*re (more poisoned|lethally poisoned)
more += danger:You convulse
more += You feel a (horrible|terrible) chill
more += You are (blasted|electrocuted|burned terribly)


# Hit by something
more += Terrible wounds
more += danger:corrodes you
more += The air around.*erupts in flames
more += The air twists around and violently strikes you in flight
more += You shudder from the earth-shattering force
more += You feel.*(?<!less )(haunted|rot|vulnerable)
more += Your damage is reflected back at you
more += (?<!You.*)reflects


# FYI
more += seems mollified
more += You have finished your manual


# Unexpected monsters
more += appears in a (shower|flash)
more += appears out of thin air
more += You sense the presence of something unfriendly
more += Wisps of shadow swirl around


# Misc
more += hell effect:.*
more += god:wrath finds you
more += The walls disappear
more += guardian golem overheats


## If you understand this, I trust you not to troll me
more += dgl_message:.*



########fm-monsters.rc########

{
------------------------------------------------------------------------------------------
------------------------------- Monster force_mores config -------------------------------
------------------------------------------------------------------------------------------
-- This stops on all Uniques & Pan lords
crawl.setopt("force_more_message += monster_warning:(?!Orb)(?!Guardian)(?-i:[A-Z]).*comes into view")

---- Everything included in this list will cause a more() prompt.
---- It should contain monsters that always need alerts, regardless of HP, xl, willpower, and resistances
local force_more_monsters = {
  -- High damage/speed
    "shrike", "juggernaut", "orbs? of fire", "flayed ghost",
  -- Torment
    "tormentor", "curse (toe|skull)", "Fiend", "tzitzimi", "royal mummy", "mummy priest", "(dread|ancient) lich", "lurking horror",
  --Summoning
    "boggart", "shadow demon", "guardian serpent", "ironbound convoker", "draconian stormcaller", "spriggan druid", "dryad",
    "worldbinder", "halazid warlock", "deep elf elementalist", "demonspawn corrupter", "elemental wellspring",
  --Dangerous abilities
    "swamp worm", "floating eye", "vault warden", "air elemental", "wendingo", "torpor snail", "dream sheep", "water nymph", 
    "shambling mangrove", "iron giant", "starflower", "merfolk aquamancer", "deep elf knight", "wretched star",
  --Dangerous clouds
    "catoblepas", "death drake", "apocalypse crab", "putrid mouth" }


------------------------------------------------------------------------------------------
------------------------------- Dynamic force_mores config -------------------------------
------------------------------------------------------------------------------------------
-- hp-specific force_mores() by gammafunk, willpower/int/resistance added by sockthot
local fm_patterns = {
  -- Fast, early game Dungeon problems for chars with low mhp.
  {name = "30hp", cond = "hp", cutoff = 30, pattern = "hound"},
  
  -- Monsters dangerous until a certain point
  {name = "xl_7", cond = "xl", cutoff = 7, pattern = "orc wizard"},
  {name = "xl_12", cond = "xl", cutoff = 12, pattern = "hydra|bloated husk"},
  
  
  -- Monsters that can hit for ~50% of hp from range with unbranded attacks
  {name = "40hp", cond = "hp", cutoff = 40, pattern = "orc priest" },
  {name = "50hp", cond = "hp", cutoff = 50, pattern = "orc high priest|manticore" },
  {name = "70hp", cond = "hp", cutoff = 70, pattern = "meliai|yaktaur(?! captain)|cyclops" },
  {name = "80hp", cond = "hp", cutoff = 80, pattern = "centaur(?! warrior)|gargoyle" },
  {name = "90hp", cond = "hp", cutoff = 90, pattern = "deep elf archer|tengu conjurer" },
  {name = "110hp", cond = "hp", cutoff = 110, pattern = {"centaur warrior|yaktaur captain|hellion|eye of devastation|sun moth",
              "deep elf high priest|deep troll earth mage|stone giant|cacodemon"} },
  {name = "120hp", cond = "hp", cutoff = 120, pattern = "quicksilver (dragon|elemental)|magenta draconian|thorn hunter" },
  {name = "160hp", cond = "hp", cutoff = 160, pattern = {"brimstone fiend|deep elf sorcerer",
              "hell sentinal|war gargoyle|draconian (knight|scorcher)"} },
  {name = "200hp", cond = "hp", cutoff = 200, pattern = "(draconian|deep elf) annihilator|iron (dragon|elemental)" },

  -- Monsters that can crowd-control you without sufficient willpower
  -- Cutoff ~10% for most spells; lower for more significant spells like banish
  {name = "willpower2", cond = "will", cutoff = 2, pattern = "basilisk|naga ritualist|vampire(?! bat)(?! mage)(?! mosquito)" },
  {name = "willpower3", cond = "will", cutoff = 3, pattern = {"deep elf (demonologist|sorcerer|archer)|(?<!orc )wizard", 
              "merfolk siren|fenstrider witch|great orb of eyes|cacodemon|imperial myrmidon|sphinx|nagaraja|draconian shifter",
			  "orange crystal statue|glowing orange brain|orc sorcerer|ogre mage|satyr|vault sentinel",
			  "iron elemental|golden eye|death knight|vampire knight" } },
  {name = "willpower4", cond = "will", cutoff = 4, pattern = "merfolk avatar|tainted leviathan|nargun" },
   
  -- Malmutate without rMut
  {name = "malmutate", cond = "mut", cutoff = 1, pattern = "cacodemon|neqoxec|shining eye" },
	
  -- Brain feed with low int
  {name = "brainfeed", cond = "int", cutoff = 6, pattern = "glowing orange brain|neqoxec|orange crystal statue" },
	
  -- Alert if no resist and HP below cutoff
  {name = "pois_30", cond = "pois", cutoff = 30, pattern = "adder"},
  {name = "pois_80", cond = "pois", cutoff = 80, pattern = "golden dragon|green draconian|swamp dragon" },
  {name = "pois_120", cond = "pois", cutoff = 120, pattern = "green death|naga mage|nagaraja|fenstrider witch" },
  {name = "pois_140", cond = "pois", cutoff = 140, pattern = "tengu reaver" },
   
  {name = "elec_40", cond = "elec", cutoff = 40, pattern = "electric eel" },
  {name = "elec_80", cond = "elec", cutoff = 80, pattern = "shock serpent|raiju|spark wasp" },
  {name = "elec_120", cond = "elec", cutoff = 120, pattern = "black draconian|blizzard demon|deep elf zephyrmancer|storm dragon|tengu conjurer" },
  {name = "elec_140", cond = "elec", cutoff = 140, pattern = "electric golem|titan|servants? of whisper|spriggan air mage|ball lightning|tengu reaver" },
   
  {name = "corr_60", cond = "corr", cutoff = 60, pattern = "acid dragon" },
  {name = "corr_140", cond = "corr", cutoff = 140, pattern = "tengu reaver|entropy weaver|demonspawn corrupter|moon troll" },
   
  {name = "fire_60", cond = "fire", cutoff = 60, pattern = "steam dragon|lindwurm|fire crab|lava snake" },
  {name = "fire_100", cond = "fire", cutoff = 100, pattern = "efreet|deep elf pyromancer|smoke demon|sun moth" },
  {name = "fire_120", cond = "fire", cutoff = 120, pattern = "orc sorcerer|hell hound|demonspawn blood saint|red draconian|ogre mage|molten gargoyle|hell knight" },
  {name = "fire_140", cond = "fire", cutoff = 140, pattern = "balrug" },
  {name = "fire_160", cond = "fire", cutoff = 160, pattern = "will-o-the-wisp|ophan|fire giant|golden dragon|fire dragon|salamander tyrant|tengu reaver" },
  {name = "fire_240", cond = "fire", cutoff = 240, pattern = "hellephant|crystal (guardian|echidna)|draconian scorcher" },
   
  {name = "cold_80", cond = "cold", cutoff = 80, pattern = "rime drake" },
  {name = "cold_120", cond = "cold", cutoff = 120, pattern = "blizzard demon|bog body|ironbound frostheart|demonspawn blood saint|white draconian" },
  {name = "cold_160", cond = "cold", cutoff = 160, pattern = "golden dragon|draconian knight|frost giant|ice dragon|tengu reaver" },
  {name = "cold_180", cond = "cold", cutoff = 180, pattern = "(?>!dread)(?>!ancient) lich" },
  {name = "cold_240", cond = "cold", cutoff = 240, pattern = "crystal (guardian|echidna)" },
   
  {name = "drain_100", cond = "drain", cutoff = 100, pattern = "orc sorcerer" },
  {name = "drain_120", cond = "drain", cutoff = 120, pattern = "necromancer" },
  {name = "drain_150", cond = "drain", cutoff = 150, pattern = "revenant|demonspawn blood saint" },
  {name = "drain_190", cond = "drain", cutoff = 190, pattern = "shadow dragon" },
   
} -- end fm_patterns

----------------------------------------------------------------------------------
------------------------------- End config section -------------------------------
----------------------------------------------------------------------------------



-- Add the non-dynamic force_mores()  (moved code down here for easier configuration)
local fm_mon_str = nil
for _, v in ipairs(force_more_monsters) do
  if fm_mon_str == nil then
    fm_mon_str = "monster_warning:(?<!spectral )("..v
  else
    fm_mon_str = fm_mon_str.."|"..v
  end
end
fm_mon_str = fm_mon_str..")(?! (zombie|skeleton|simulacrum).*comes into view"
crawl.setopt("force_more_message += "..fm_mon_str)




-- Set to true to get a message when the fm change
local notify_fm = false

-- Keep track of active force_mores()
local active_fm = {}
for i,v in ipairs(fm_patterns) do
  active_fm[#active_fm + 1] = false
end

-- Util for checks against resistance and hp
local function get_three_pip_action(active, hp, cutoff, res)
  if active then
	if hp >= cutoff then return "-" end
	if res == 1 and hp >= cutoff/2 then return "-" end
	if res == 2 and hp >= cutoff/3 then return "-" end
	if res == 3 and hp >= cutoff/5 then return "-" end
  else
	if res == 0 and hp < cutoff then return "+" end
	if res == 1 and hp > cutoff/2 then return "+" end
	if res == 2 and hp > cutoff/3 then return "+" end
	if res == 3 and hp > cutoff/5 then return "+" end
  end
end



--------------------------------------------
------------------- Hook -------------------
--------------------------------------------
function ready_force_mores()
  local activated = {}
  local deactivated = {}
  
  local hp, maxhp = you.hp()
  local willpower = you.willpower()
  local res_mut = you.res_mutation()
  local res_pois = you.res_poison()
  local res_elec = you.res_shock()
  local res_corr = you.res_corr()
  local res_fire = you.res_fire()
  local res_cold = you.res_cold()
  local res_drain = you.res_draining()
  local int, maxint = you.intelligence()
  
  for i,v in ipairs(fm_patterns) do
    local msg = nil
    if type(v.pattern) == "table" then
      for j, p in ipairs(v.pattern) do
        if not msg then
          msg = p
        else
          msg = msg .. "|" .. p
        end
      end
    else
      msg = v.pattern
    end
	
    msg = "monster_warning:(?<!spectral )(" .. msg .. ")(?! (skeleton|zombie|simulacrum)).*comes into view"
    
	local action = nil
    local fm_name = v.pattern
    if v.name then fm_name = v.name end
	
    if not v.cond and not active_fm[i] then
      action = "+"
    elseif v.cond == "xl" then
      if active_fm[i] and you.xl() >= v.cutoff then action = "-"
      elseif not active_fm[i] and you.xl() < v.cutoff then action = "+"
      end
    elseif v.cond == "maxhp" then
      if active_fm[i] and maxhp >= v.cutoff then action = "-"
      elseif not active_fm[i] and maxhp < v.cutoff then action = "+"
      end
    elseif v.cond == "hp" then
      if active_fm[i] and hp >= v.cutoff then action = "-"
      elseif not active_fm[i] and hp < v.cutoff then action = "+"
      end
	elseif v.cond == "int" then
	  if active_fm[i] and int >= v.cutoff then action = "-"
      elseif not active_fm[i] and int < v.cutoff then action = "+"
      end
	elseif v.cond == "will" then
	  if active_fm[i] and willpower >= v.cutoff then action = "-"
      elseif not active_fm[i] and willpower < v.cutoff then action = "+"
      end
	elseif v.cond == "mut" then
	  if active_fm[i] and res_mut > 0 then action = "-"
      elseif not active_fm[i] and res_mut == 0 then action = "+"
      end
	elseif v.cond == "pois" then
	  if active_fm[i] and (res_pois > 0 or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and res_pois == 0 and hp < v.cutoff then action = "+"
      end
	elseif v.cond == "elec" then
	  if active_fm[i] and (res_elec > 0 or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and res_elec == 0 and hp < v.cutoff then action = "+"
      end
	elseif v.cond == "corr" then
	  if active_fm[i] and (res_corr or hp >= v.cutoff) then action = "-"
      elseif not active_fm[i] and not res_corr and hp < v.cutoff then action = "+"
      end
	elseif v.cond == "fire" then
	  action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_fire)
	elseif v.cond == "cold" then
	  action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_cold)
	elseif v.cond == "drain" then
	  action = get_three_pip_action(active_fm[i], hp, v.cutoff, res_drain)
    end
	
	
    if action == "+" then
      activated[#activated + 1] = fm_name
    elseif action == "-" then
      deactivated[#deactivated + 1] = fm_name
    end
    if action then
      local opt = "force_more_message " .. action .. "= " .. msg
      crawl.setopt(opt)
      active_fm[i] = not active_fm[i]
    end
  end
  if #activated > 0 and notify_fm then
    crawl.mpr("Activating force_mores: " .. table.concat(activated, ", "), "plain")
  end
  if #deactivated > 0 and notify_fm then
    crawl.mpr("Deactivating force_mores: " .. table.concat(deactivated, ", "), "plain")
  end
end
}

########dynamic-options.rc########

{
----------------------
---- race-specific ----
----------------------
if you.race() == "Demonspawn" then
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
elseif you.race() == "Formicid" then
  crawl.setopt("more -= monster_warning:curare")
elseif you.race() == "Gargoyle" then
  crawl.setopt("more -= monster_warning:curare")
elseif you.race() == "Ghoul" then
  crawl.setopt("more -= monster_warning:curare")
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
elseif you.race() == "Gnoll" then
  crawl.setopt("message_colour ^= mute:intrinsic_gain:skill increases to level")
elseif you.race() == "Mummy" then
  crawl.setopt("more -= monster_warning:curare")
  crawl.setopt("more += monster_warning:wielding.*of holy wrath")
end


----------------------
---- god-specific ----
----------------------
local cur_god = "No God"
local function set_god_options()
  if you.god() ~= cur_god then
    cur_god = you.god()
  
	if cur_god == "Beogh" then
	  crawl.setopt("autopickup_exceptions ^= >scrolls? of immolation")
      crawl.setopt("runrest_ignore_message += no longer looks unusually strong")
      crawl.setopt("force_more_message += Your orc.*dies")
	  crawl.setopt("macros += M 1 tf")
	  crawl.setopt("macros += M 2 ta")
	  crawl.setopt("macros += M 3 tr")
	  crawl.setopt("macros += M 4 tg")
	  crawl.setopt("macros += M 6 ab")
	elseif cur_god == "Dithmenos" then
	  crawl.setopt("force_more_message += god:You are shrouded in an aura of darkness")
	  crawl.setopt("force_more_message += god:You now sometimes bleed smoke")
	  crawl.setopt("force_more_message += god:You.*no longer.*bleed smoke")
	  crawl.setopt("force_more_message += god:Your shadow no longer tangibly mimics your actions")
	  crawl.setopt("force_more_message += god:Your shadow now sometimes tangibly mimics your actions")
	elseif cur_god == "Fedhas" then
      crawl.setopt("force_more_message += god:Fedhas invokes the elements against you")
    elseif cur_god == "Hepliaklqana" then
      crawl.setopt("runrest_ignore_message ^= emerges from the mists of memory")
	elseif cur_god == "Jiyva" then
      crawl.setopt("force_more_message += god:will now unseal the treasures of the Slime Pits")
	  crawl.setopt("force_more_message += god:Jiyva alters your body")
	  crawl.setopt("force_more_message += god:splits in two")
	  crawl.setopt("force_more_message += god:Your prayer is over.")
	elseif cur_god == "Kikubaaqudgha" then
      crawl.setopt("force_more_message += god:Kikubaaqudgha will grant you")
	elseif cur_god == "Lugonu" then
      crawl.setopt("force_more_message += god:Lugonu will now corrupt your weapon")
      crawl.setopt("force_more_message += god:Lugonu sends minions to punish you")
	elseif cur_god == "Okawaru" then
      crawl.setopt("force_more_message += god:Okawaru sends forces against you")
	elseif cur_god == "Qazlal" then
      crawl.setopt("force_more_message += god:resistances upon receiving elemental damage")
      crawl.setopt("force_more_message += god:You are surrounded by a storm which can block enemy attacks")
	elseif cur_god == "The Shining One" then
      crawl.setopt("force_more_message += god:Your divine shield starts to fade.")
      crawl.setopt("force_more_message += god:Your divine shield fades away.")
	elseif cur_god == "Trog" then
      crawl.setopt("force_more_message += god:You feel the effects of Trog's Hand fading")
      crawl.setopt("force_more_message += god:You feel less resistant to hostile enchantments")
	elseif cur_god == "Uskayaw" then
      crawl.setopt("force_more_message += god:You can no longer pass through a line of other dancers.")
	elseif cur_god == "Wu Jian Council" then
      crawl.setopt("runrest_ignore_message += heavenly storm settles")
	elseif cur_god == "Xom" then
      crawl.setopt("force_more_message += god:")
      crawl.setopt("force_more_message += staircase.*moves")
      crawl.setopt("force_more_message += Some monsters swap places")
	elseif cur_god == "Yredelemnul" then
      crawl.setopt("force_more_message += god:soul is now ripe for the taking")
      crawl.setopt("force_more_message += god:soul is no longer ripe for the taking")
      crawl.setopt("force_more_message += god:dark mirror aura disappears")
	elseif cur_god == "Zin" then
      crawl.setopt("force_more_message += god:will now cure all your mutations")
	end
  end
end



---------------------
---- xl-specific ----
---------------------
local warn_early_levels = false
local warn_mid_levels = false
local function set_xl_options()
  if not warn_early_levels and you.xl() <= 5 then
    warn_early_levels = true
	crawl.setopt("force_more_message += wielding.*(vorpal|(?<!armour)(?<!mail)(?<!scales) of)")
  elseif warn_early_levels and you.xl() > 5 then
	warn_early_levels = false
	crawl.setopt("force_more_message -= wielding.*(vorpal|(?<!armour)(?<!mail)(?<!scales) of)")
  end
  
  if not warn_mid_levels and you.xl() <= 10 then
    warn_mid_levels = true
	crawl.setopt("force_more_message += wielding.*of electrocution")
  elseif warn_mid_levels and you.xl() > 10 then
	warn_mid_levels = false
	crawl.setopt("force_more_message -= wielding.*of electrocution")
  end
end


------------------------
---- skill-specific ----
------------------------
local ignoring_spellcasting = false
local function set_skill_options()
  -- Ignore spellcaster items if you have no spellcasting skill, and wearing some armour without much armour skill
  local arm = items.equipped_at("body armour")
  if not ignoring_spellcasting and you.skill("Spellcasting") == 0 and arm and arm.encumbrance > 2*you.skill("Armour") then
    ignoring_spellcasting = true
    crawl.setopt("explore_stop_pickup_ignore += spellbooks")
    crawl.setopt("autopickup_exceptions ^= >scrolls? of amnesia, >potions? of brilliance, >ring of wizardry")
    crawl.setopt("runrest_ignore_message += You add the spell")
  elseif ignoring_spellcasting and not (you.skill("Spellcasting") == 0 and arm and arm.encumbrance > 2*you.skill("Armour")) then
    ignoring_spellcasting = false
    crawl.setopt("explore_stop_pickup_ignore -= spellbooks")
    crawl.setopt("autopickup_exceptions -= >scrolls? of amnesia, >potions? of brilliance, >ring of wizardry")
    crawl.setopt("runrest_ignore_message -= You add the spell")
  end
end



------------------------------------------
------------------ Hook ------------------
------------------------------------------
function ready_dynamic_options()
  set_god_options()
  set_xl_options()
  set_skill_options()
end

}

########startup.rc########

{
-------------------------------------------------
---- Start with travel speed to slowest ally ----
-------------------------------------------------
-- Make sure this comes before Skill menu on startup, since they both use crawl.sendkeys()
local need_toggle_travel_speed = true
if you.turns() == 0 and need_toggle_travel_speed then
  need_toggle_travel_speed = false
  crawl.sendkeys(20)
end


---------------------------------------------
---- Skill menu on startup (by rwbarton) ----
---------------------------------------------
local need_skills_opened = true
if you.turns() == 0 and need_skills_opened then
  need_skills_opened = false
  crawl.sendkeys("m!!")
end

}

### Pickup and alert ###


########pickup-alert/pa-util.rc########

{
-- Add an item name to a table, along with all less enchanted versions
-- e.g. "+3 flail" will add: "+3 flail", "+2 flail", "+1 flail", "+0 flail"
function insert_item_and_less_enchanted(table_name, item_name)
  if util.contains(table_name, item_name) then return end
  table.insert(table_name, item_name)

  -- Add less enchanted items too
  local plus = tonumber(item_name:sub(2,2))
  if not plus then return end
	
  if plus > 0 then
    if tonumber(item_name:sub(3,3)) then
      plus = 10 * plus + tonumber(item_name:sub(3,3))
    end

    for i=plus,1,-1 do
      item_name = item_name:gsub("+"..i, "+"..(i-1))
      table.insert(table_name, item_name)
	end
  end
end


function has_ego(it)
  if it.class(true) == "weapon" then return it.branded end
  
  if it.artefact then return true end
  if it.branded then return true end
  local qualname = it.name("qual")
  if qualname:find("troll leather") then return true end
  if qualname:find("dragon scales") then return true end
  return false
end


function get_size_factor()
  local race = you.race()
  if race == "Spriggan" then return 4
  elseif race == "Kobold" then return 2
  elseif race == "Formicid" or race == "Armataur" or race == "Naga" or race == "Ogre" or race == "Troll" then return -2
  else return 0
  end
end

local summon_gods = { "Beogh", "Jiyva", "Yredelemnul" }
function you_have_summons()
  return you.skill("Summonings") + you.skill("Necromancy") > 0 or util.contains(summon_gods, you.god())
end

--------------------------------------------------
--------------------- Armour ---------------------
--------------------------------------------------
function get_armour_ac(it)
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end
  
  if it.artefact and it.fully_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end
  
  return it.ac * (you.skill("Armour") / 22 + 1) + it_plus 
end


function get_armour_ev(it)
  -- This function computes the armour-based component to standard EV (not paralysed, etc)
  -- Factors in stat changes for this armour and currently worn
  local race = you.race()
  local str = you.strength()
  local dex = you.dexterity()
  local it_plus = 0
  
  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local worn = items.equipped_at("body armour")
	if worn.artefact then
	  if worn.artprops["Str"] then str = str - worn.artprops["Str"] end
	  if worn.artprops["Dex"] then dex = dex - worn.artprops["Dex"] end
	  if worn.artprops["EV"] then it_plus = it_plus - worn.artprops["EV"] end
	end
	
	if it.artefact then
	  if it.artprops["Str"] then str = str + it.artprops["Str"] end
	  if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
	  if it.artprops["EV"] then it_plus = it_plus + it.artprops["EV"] end
	end
  end
  
  local size_factor = get_size_factor()
  
  local dodge_bonus = (7 + you.skill("Dodging") * dex) / (20 - size_factor)
  armor_penalty = it.encumbrance - 3

  local modifier = 0
  if armor_penalty < 0 then modifier = 1
  elseif armor_penalty > 0 then
    if armor_penalty >= str then modifier = str / (armor_penalty * 2)
    else modifier = 1 - armor_penalty / (str * 2)
	end
  end

  local final_dodge_bonus = dodge_bonus * modifier
  local aevp = 2 * it.encumbrance * it.encumbrance * (45 - you.skill("Armour")) / (5 * (str + 3) * 45)

  return final_dodge_bonus - aevp + it_plus
end


---------------------------------------------------
--------------------- Weapons ---------------------
---------------------------------------------------
function get_hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  st, _ = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end


function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Intended only to be used to prevent skill from reducing too far in get_weap_delay()
  local basename = it.name("base")
  local st, _ = it.subtype()
  local base_delay = it.delay
  
  local min_delay = base_delay / 2
  if it.weap_skill == "Short Blades" and min_delay > 5 then min_delay = 5 end
  if min_delay > 7 then min_delay = 7 end
  
  if basename:find("longbow") then min_delay = 6
  elseif (basename:find("crossbow") or basename:find("arbalest")) and min_delay < 10 then min_delay = 10 end
  
  return min_delay
end


function get_weap_delay(it)
  local delay = it.delay - you.skill(it.weap_skill)/2
  local min_delay = get_weap_min_delay(it)
  if delay < min_delay then delay = min_delay end
  
  if it.ego() == "Speed" then delay = delay * 2 / 3 end
  
  if delay < 3 then delay = 3 end
  
  local sh = items.equipped_at("shield")
  if sh then
    local sh_penalty = 2/5 * sh.encumbrance * sh.encumbrance / (20 - 3 * get_size_factor()) * (27 - you.skill("shields")) / 27
    delay = delay + sh_penalty
  end
  
  return delay / 10
end


function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaik
  for i = 0,20 do
    it = items.equipped_at(i)
    if it then
	  if it.name("base") == "ring" then
	    if it.artefact then
		  local name = it.name()
	      local idx = name:find("Slay+")
	      if idx then
	        local slay = tonumber(name:sub(idx+5, idx+5))
		    if slay == 1 then
		      local next_digit = tonumber(name:sub(idx+6, idx+6))
		      if next_digit then slay = 10 + next_digit end
		    end
		    sum = sum + slay
		  end
		elseif it.ego(true) == "Slay" then 
	      sum = sum + it.plus 
		end
	  elseif it.artefact and (it.class(true) == "armour" or it.name("base") == amulet) then
	      local slay = it.artprops["Slay"]
	      if slay then sum = sum + slay end
	  end
	end
  end
  
  if you.race() == "Demonspawn" then
    sum = sum + 3 * you.get_base_mutation_level("augmentation", true, false, true)
    sum = sum + you.get_base_mutation_level("sharp scales", true, false, true)
  end

  return sum
end


function get_staff_bonus_dmg(it, no_brand_dmg)
  if no_brand_dmg and basename ~= "staff of earth" and basename ~= "staff of conjuration" then return 0 end
  
  local evo_skill = you.skill("Evocations")
  local basename = it.name("base")
  local school
  if basename == "staff of fire" then school = "Fire Magic"
  elseif basename == "staff of cold" then school = "Ice Magic"
  elseif basename == "staff of earth" then school = "Earth Magic"
  elseif basename == "staff of air" then school = "Air Magic"
  elseif basename == "staff of poison" then school = "Poison Magic"
  elseif basename == "staff of death" then school = "Necromancy"
  elseif basename == "staff of conjuration" then school = "Conjurations"
  else
    crawl.mpr("ERROR:UNRECOGNIZED STAFF:"..it.name("base"), error)
	return 0
  end
  
  local spell_skill = you.skill(school)
  local chance = (evo_skill + spell_skill/2) / 15
  if chance > 1 then chance = 1 end
  -- 0.625 is an acceptable approximation
  -- Earth magic does more, but reduced by armour. Poison/draining bonus effects are ignored.
  local avg_dmg = 0.625 * (evo_skill/2 + spell_skill)
  return avg_dmg*chance
end


function get_weap_dps(it, no_brand_dmg)
  -- Returns an adjusted weapon damage = damage * speed
  -- Includes stat/slay changes between weapon and the one currently wielded
  -- Aux attacks not included
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end

  -- Adjust str/dex/slay from artefacts
  local str = you.strength()
  local dex = you.dexterity()
  
  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local wielded = items.equipped_at("weapon")
	if wielded and wielded.artefact then
	  if wielded.artprops["Str"] then str = str - wielded.artprops["Str"] end
	  if wielded.artprops["Dex"] then dex = dex - wielded.artprops["Dex"] end
	  if wielded.artprops["Slay"] then it_plus = it_plus - wielded.artprops["Slay"] end
	end
	
	if it.artefact and it.fully_identified then
	  if it.artprops["Str"] then str = str + it.artprops["Str"] end
	  if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
	  if it.artprops["Slay"] then it_plus = it_plus + it.artprops["Slay"] end
	end
  end
  
  if it.is_ranged or it.weap_skill:find("Blades") then stat = dex
  else stat = str end

  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + you.skill(it.weap_skill)/25/2) * (1 + you.skill("Fighting")/30/2)
  
  local pre_brand_dmg = it.damage * stat_mod * skill_mod + it_plus + get_slay_bonuses()
  
  
  if it.class(true) == "magical staff" then 
	return (pre_brand_dmg + get_staff_bonus_dmg(it, no_brand_dmg)) / get_weap_delay(it)
  end
  
  local ego = it.ego()
  if not ego then return pre_brand_dmg / get_weap_delay(it) end

  if ego == "spectralizing" then return 2 * pre_brand_dmg / get_weap_delay(it) end
  if ego == "vorpality" then
    if it.is_ranged then return 1.2 * pre_brand_dmg / get_weap_delay(it) end
	return 7/6 * pre_brand_dmg / get_weap_delay(it)
  end
  
  if not no_brand_dmg then
    if ego == "flaming" or ego == "freezing" then return 1.25 * pre_brand_dmg  / get_weap_delay(it) end
    if ego == "draining" then return (1.25 * pre_brand_dmg + 2) / get_weap_delay(it) end 
    if ego == "electrocution" then return (pre_brand_dmg + 3.5) / get_weap_delay(it) end
    -- Ballparking venom as 5 dmg since it totally breaks the paradigm
    if ego == "venom" then return (pre_brand_dmg + 5) / get_weap_delay(it) end
    if ego == "pain" then return (pre_brand_dmg + you.skill("Necromancy")/2) / get_weap_delay(it) end
    -- Distortion does 5.025 extra dmg, + 5% chance to banish
    if ego == "distortion" then return (pre_brand_dmg + 6) / get_weap_delay(it) end
    -- Weighted average of all the easily computed brands was ~ 1.17*dmg + 2.13
    if ego == "chaos" then return (1.25 * pre_brand_dmg + 2) / get_weap_delay(it) end
  end
  
  return pre_brand_dmg / get_weap_delay(it)
end


function inscribe_stats(it, skip_inscription)
  local dps = get_weap_dps(it)
  local dps_str = string.format("%.2f", dps)
	  
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end
  local acc = it.accuracy + it_plus
  if acc >= 0 then acc = "+"..acc end
  
  local new_inscr = "DPS="..dps_str
  if dps < 10 then new_inscr = new_inscr.." " end
  new_inscr = new_inscr.."(Acc"..acc..")"
	  
  local idx = it.inscription:find("DPS=")
  if not idx then
    if not skip_inscription then it.inscribe(new_inscr, false) end
	return new_inscr
  end

  if idx + #new_inscr <= #it.inscription then
    new_inscr = new_inscr..it.inscription:sub(idx + #new_inscr, #it.inscription)
  end
  if idx > 1 then new_inscr = it.inscription:sub(1, idx-1)..new_inscr end

  if not skip_inscription then it.inscribe(new_inscr, false) end
  return new_inscr
end

}

########pickup-alert/pa-data.rc########

{

-------------------------------------------------------------------------------
---------------------------- Begin persistant data ----------------------------
-------------------------------------------------------------------------------
-- Lists of items previously alerted/picked up; and other values relevant to the decisions

if not rare_items or you.turns() == 0 then
  rare_items = {"broad axe", "executioner's axe", "eveningstar", "demon whip", "sacred scourge",
				"lajatang", "bardiche", "demon trident", "trishula",
				"quick blade", "demon blade", "double sword", "triple sword", "eudemon blade",
				"crystal plate armour", "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales", 
				"triple crossbow", "hand crossbow", "buckler", "kite shield", "tower shield" }
end

local function persist_rare_items()
  local cmd = "rare_items = {"
  local len = 0
  for _,v in ipairs(rare_items) do
    if v ~= "" then
	  cmd = cmd .. "\"" .. v .. "\", "
	  len = len+1
	end
  end
  
  return cmd .. "\"\"}" .. string.char(10)
end

if not added_rare_items_hook then
  table.insert(chk_lua_save, persist_rare_items)
  added_rare_items_hook = true
end


if not items_picked or you.turns() == 0 then
  items_picked = { "" }
end

local function persist_items_picked()
  local cmd = "items_picked = {"
  local len = 0
  for _,v in ipairs(items_picked) do
    if v ~= "" then
	  cmd = cmd .. "\"" .. v .. "\", "
	  len = len+1
	end
  end
  
  return cmd .. "\"\"}" .. string.char(10)
end

if not added_items_picked_hook then
  table.insert(chk_lua_save, persist_items_picked)
  added_items_picked_hook = true
end


if not items_alerted or you.turns() == 0 then
  items_alerted = { "" }
end

local function persist_items_alerted()
  local cmd = "items_alerted = {"
  local len = 0
  for _,v in ipairs(items_alerted) do
    if v ~= "" then
	  cmd = cmd .. "\"" .. v .. "\", "
	  len = len+1
	end
  end
  
  return cmd .. "\"\"}" .. string.char(10)
end

if not added_items_alerted_hook then
  table.insert(chk_lua_save, persist_items_alerted)
  added_items_alerted_hook = true
end


if not armour_high_score or you.turns() == 0 then
  armour_high_score = 0
  local eq = items.equipped_at("body armour")
  if eq then armour_high_score = get_armour_ac(eq) end
end

local function persist_armour_high_score()
  local cmd = "armour_high_score = " .. armour_high_score .. string.char(10)
  return cmd
end

if not added_armour_high_score_hook then
  table.insert(chk_lua_save, persist_armour_high_score)
  added_armour_high_score_hook = true
end


if not alerted_first_ranged_one_handed or you.turns() == 0 then
  alerted_first_ranged_one_handed = 0
  local eq = items.equipped_at("weapon")
  if eq and eq.is_ranged and get_hands(eq) == 1 then alerted_first_ranged_one_handed = 1 end
end

local function persist_alerted_first_ranged_one_handed()
  local cmd = "alerted_first_ranged_one_handed = " .. alerted_first_ranged_one_handed .. string.char(10)
  return cmd
end

if not added_first_ranged_one_handed_hook then
  table.insert(chk_lua_save, persist_alerted_first_ranged_one_handed)
  added_first_ranged_one_handed_hook = true
end

if not alerted_first_ranged_two_handed or you.turns() == 0 then
  alerted_first_ranged_two_handed = 0
  local eq = items.equipped_at("weapon")
  if eq and eq.is_ranged and get_hands(eq) == 2 then alerted_first_ranged_two_handed = 1 end
end

local function persist_alerted_first_ranged_two_handed()
  local cmd = "alerted_first_ranged_two_handed = " .. alerted_first_ranged_two_handed .. string.char(10)
  return cmd
end

if not added_first_ranged_two_handed_hook then
  table.insert(chk_lua_save, persist_alerted_first_ranged_two_handed)
  added_first_ranged_two_handed_hook = true
end

if not polearm_high_score or you.turns() == 0 then
  polearm_high_score = 0
  local eq = items.equipped_at("weapon")
  if eq and eq.weap_skill == "Polearms" then polearm_high_score = get_weap_dps(eq) + eq.accuracy + eq.plus end
end

local function persist_polearm_high_score()
  local cmd = "polearm_high_score = " .. polearm_high_score .. string.char(10)
  return cmd
end

if not added_polearm_high_score_hook then
  table.insert(chk_lua_save, persist_polearm_high_score)
  added_polearm_high_score_hook = true
end


if not unbranded_high_score or you.turns() == 0 then
  unbranded_high_score = 0
  local eq = items.equipped_at("weapon")
  if eq then unbranded_high_score = get_weap_dps(eq, true) + eq.accuracy + eq.plus end
end

local function persist_unbranded_high_score()
  local cmd = "unbranded_high_score = " .. unbranded_high_score .. string.char(10)
  return cmd
end

if not added_unbranded_high_score_hook then
  table.insert(chk_lua_save, persist_unbranded_high_score)
  added_unbranded_high_score_hook = true
end

if not weapon_high_score or you.turns() == 0 then
  weapon_high_score = 0
  local eq = items.equipped_at("weapon")
  if eq then weapon_high_score = get_weap_dps(eq) + eq.accuracy + eq.plus end
end

local function persist_weapon_high_score()
  local cmd = "weapon_high_score = " .. weapon_high_score .. string.char(10)
  return cmd
end

if not added_weapon_high_score_hook then
  table.insert(chk_lua_save, persist_weapon_high_score)
  added_weapon_high_score_hook = true
end


----------------------------------------
---- Accessors into persistant data ----
----------------------------------------
function pickup_item(it)
  local ret_val = false
  local name = it.name("plain")
  if not it.fully_identified then
    name = "+0 " .. name
  end

  if it.artefact then
    ret_val = true
  elseif not util.contains(items_picked, name) then
    -- Add to the table on pickup, in c_assign_invletter() hook function
	ret_val = true
  end
  
  -- Remove from rare_items if it's there
  for i,v in ipairs(rare_items) do
    if v ~= "" and name:find(v) then
	  rare_items[i] = ""
	  return true
	end
  end
  
  -- Returns true if we haven't picked up this item previously
  return ret_val
end


function c_assign_invletter_item_alerts(it)
  if it.class(true) == "weapon" or it.class(true) == "magical staff" or it.class(true) == "armour" then
    local name = it.name("plain")
    if not util.contains(items_picked, name) then
	  insert_item_and_less_enchanted(items_picked, name)
	  insert_item_and_less_enchanted(items_alerted, name)
	  
	  for i, v in ipairs(rare_items) do
	    if name:find(v) then rare_items[i] = "" end
	  end
	  
	  -- Update high scores
	  if it.class(true) == "armour" then
 	    local ac = get_armour_ac(it)
		if ac > armour_high_score then armour_high_score = ac end
	  elseif it.class(true) == "weapon" then
	    if it.weap_skill == "Polearms" then
	      local score = get_weap_dps(it) + it.accuracy + it.plus
	      if score > polearm_high_score then
	        polearm_high_score = score
		    alert_item(it, "Strongest polearm")
	      end
		end

        local score = get_weap_dps(it, false) + it.accuracy + it.plus
	    if score > unbranded_high_score then unbranded_high_score = score end
	
	    score = get_weap_dps(it) + it.accuracy + it.plus
	    if score > weapon_high_score then weapon_high_score = score end
      end
	end
  end
end


function alert_item(it, alert_type)
  local name = it.name("plain")
  
  if (it.artefact or it.branded) and not it.fully_identified then
    if util.contains(items_alerted, name) then return end
	table.insert(items_alerted, name)
    crawl.mpr("<magenta>----Item alert, " .. alert_type .. ": " .. name .. "----</magenta>", "item")
	return
  end
  
  -- Prefix unidentified items with "+0"
  if not it.fully_identified then
    name = "+0 " .. name
  end

  if not util.contains(items_alerted, name) then
	if it.class(true) == "weapon" or it.class(true) == "magical staff" then
      local dps = string.format("%.2f", get_weap_dps(it))
	  local acc = it.accuracy
	  if it.plus then acc = acc + it.plus end
      if acc == 0 then acc = "+0" end
	  crawl.mpr("<magenta>----Item alert, " .. alert_type .. ": " .. name .. " {"..inscribe_stats(it, true).."}----</magenta>", "item")
	else
	  crawl.mpr("<magenta>----Item alert, " .. alert_type .. ": " .. name .. "----</magenta>", "item")
	end
    
	insert_item_and_less_enchanted(items_alerted, name)
  end
  
  -- Returns true to make other code more concise; indicates that we tried to alert this item
  return true
end
crawl.setopt("runrest_stop_message += Item alert, ")


function get_rare_item_index(it)
  local qualname = it.name("qual")
  for i,v in ipairs(rare_items) do
    if v ~= "" and qualname:find(v) then 
	return i end
  end
  return -1
end

-----------------------------------------------------------------------------
---------------------------- End persistant data ----------------------------
-----------------------------------------------------------------------------
}

########pickup-alert/pa-main.rc########


{

------------------------------------
---- Autopickup and alerts hook ----
------------------------------------
local function autopickup_master(it, name)
  local class = it.class(true)
  
  -- Check for pickup
  local retVal = false
  if class == "armour" and loaded_pa_armour then retVal = pickup_armour(it)
  elseif class == "weapon" and loaded_pa_weapons then retVal = pickup_weapons(it)
  elseif class == "magical staff" and loaded_pa_misc then retVal = pickup_staves(it)
  end
  
  if retVal == true then return pickup_item(it) end

  
  -- Not picking up this item. Check for alerts
  if it.name("base") == "orb" and loaded_pa_misc then alert_orbs(it)
  elseif class == "armour" and loaded_pa_armour then alert_armour(it)
  elseif class == "weapon" and loaded_pa_weapons then alert_weapons(it)
  end
  if loaded_pa_misc then
    alert_rare_items(it)
    if class == "magical staff" then alert_staves(it) end
  end
end

add_autopickup_func(autopickup_master)
-------------------------------
---- End autopickup master ----
-------------------------------
}

########pickup-alert/pa-armour.rc########


{
loaded_pa_armour = true



---------------------------------------
---- Begin alert_armour_upgrades() ----
---------------------------------------
-- If training armour in early/mid game, alert user to any armour that is the strongest found so far

local function alert_armour_upgrades(it)
  if you.skill("Armour") == 0 then return false end
  if you.xl() > 12 then return false end
  if (it.artefact or it.branded) and not it.fully_identified then return false end

  local st, _ = it.subtype()
  if st ~= "body" then return false end

  if armour_high_score == 0 then
    local cur = items.equipped_at("body armour")
    if not cur then return false end
    armour_high_score = get_armour_ac(cur)
  else
    local itAC = get_armour_ac(it)
    if itAC > armour_high_score+0.3 then
	  armour_high_score = itAC
	  return alert_item(it, "Stronger armour")
	end
  end
  
  return false
end
-------------------------------------
---- End alert_armour_upgrades() ----
-------------------------------------

-------------------------------
---- Begin pickup_armour() ----
-------------------------------
-- Equipment autopickup (by Medar, gammafunk, sockthot, and various others)
function pickup_armour(it)
  if it.is_useless then return false end
  
  local st, _ = it.subtype()
 
  if st == "body" then
    -- Body armour: AC upgrades, new egos that don't lose AC, and artefacts that don't lose 5+ AC
	local cur = items.equipped_at("body armour")
    if not cur then return false end
	if not it.fully_identified and it.branded then return false end
	
    if it.encumbrance <= cur.encumbrance then
	  local ac_delta = get_armour_ac(it) - get_armour_ac(cur)
	  
	  if it.artefact and ac_delta > -5 then return pickup_item(it) end
	  if cur.artefact then return false end
	  
	  if it.ego() == cur.ego() and (has_ego(it) or not has_ego(cur)) then
	    if ac_delta > 0 then return pickup_item(it) end
		return false
	  elseif has_ego(it) and not (cur.artefact or has_ego(cur)) then
		if ac_delta >= 0 then return pickup_item(it) end
	  end
	end
  elseif st == "shield" then
    -- Shields
	if not it.fully_identified or it.name("base") == "orb" then return false end
	
	local cur = items.equipped_at("shield")
	if not cur then return false end
	if cur.name("base") ~= it.name("base") then return false end
	if it.artefact then return pickup_item(it) end
	if cur.artefact then return false end
	if cur.branded then
	  if cur.ego() == it.ego() then return it.plus > cur.plus end
	  return false
	end
	if it.branded then return pickup_item(it) end
	return it.plus > cur.plus
  else
    -- Aux armour: Pickup artefacts, AC upgrades, and new egos
	
	-- No pickup if mutation interference
    if st == "gloves" then
	  -- Ignore demonic touch if you're wearing a shield
	  if not items.equipped_at("shield") then
	    if you.get_base_mutation_level("demonic touch", true, false, true) > 0 then return false end
	  end
	  
	  -- Ignore claws if you're wielding a weapon
	  if not items.equipped_at("weapon") then
	    if you.get_base_mutation_level("claws", true, false, true) > 0 then return false end
	  end
	elseif st == "boots" then
	  if you.get_base_mutation_level("hooves", true, false, true) > 0 then return false end
	  if you.get_base_mutation_level("talons", true, false, true) > 0 then return false end
	elseif it.name("base"):find("helmet") then
	  if you.get_base_mutation_level("horns", true, false, true) > 0 then return false end
	  if you.get_base_mutation_level("beak", true, false, true) > 0 then return false end
	  if you.get_base_mutation_level("antennae", true, false, true) > 0 then return false end
	end

    if it.artefact then return pickup_item(it) end

    local cur = items.equipped_at(st)
    if not cur then return pickup_item(it) end
	if not it.fully_identified then return false end

	if it.branded then
	  if it.ego() ~= cur.ego() then return pickup_item(it) end
	  if get_armour_ac(it) > get_armour_ac(cur) then return pickup_item(it) end
    else
	  if cur.branded or cur.artefact then return false end
	  if get_armour_ac(it) > get_armour_ac(cur) then return pickup_item(it) end
	end
  end

  return false
end
-----------------------------
---- End pickup_armour() ----
-----------------------------


--------------------------------------------
---- Begin alert_armour_while_mutated() ----
--------------------------------------------
-- Special cases where you have temporary or innate mutations that interfere with armour
local function alert_armour_while_mutated(it, type)
  -- Alerts usable ego items if there are mutations
  -- Returns before alerting if innate mutations make item unusable
  -- Returns true iff there are mutations
  if type == "gloves" then
    local claws_lvl_innate = you.get_base_mutation_level("claws", true, false, false)
    if claws_lvl_innate >= 3 then return true end
  
    local touch_lvl_innate = you.get_base_mutation_level("demonic touch", true, false, false)
	if touch_lvl_innate >= 3 then return true end

	local claws_lvl = you.get_base_mutation_level("claws", true, false, true)
	local touch_lvl = you.get_base_mutation_level("demonic touch", true, false, true)
	
    if claws_lvl + touch_lvl > 0 then
      if it.artefact or it.branded then return alert_item(it, "Branded gloves") end
	  return true
    end
  elseif type == "boots" then
    local hooves_lvl_innate = you.get_base_mutation_level("hooves", true, false, false)
    if hooves_lvl_innate >= 3 then return true end
  
    local talons_lvl_innate = you.get_base_mutation_level("talons", true, false, false)
    if talons_lvl_innate >= 3 then return true end
  
    local hooves_lvl = you.get_base_mutation_level("hooves", true, false, true)
    local talons_lvl = you.get_base_mutation_level("talons", true, false, true)

    if hooves_lvl + talons_lvl > 0 then
      if it.artefact or it.branded then return alert_item(it, "Branded boots") end
	  return true
    end
  elseif type == "helmet" then
    local horns_lvl_innate = you.get_base_mutation_level("horns", true, false, false)
    local antennae_lvl_innate = you.get_base_mutation_level("antennae", true, false, false)

    if it.name("base"):find("helmet") then
      if horns_lvl_innate > 0 then return true end
      if antennae_lvl_innate > 0 then return true end
      if you.get_base_mutation_level("beak", true, false, false) > 0 then return true end
    else
	  -- hat/crown/etc
      if horns_lvl_innate >= 3 then return true end
      if antennae_lvl_innate >= 3 then return true end
    end
  
    local horns_lvl = you.get_base_mutation_level("horns", true, false, true)
    local antennae_lvl = you.get_base_mutation_level("antennae", true, false, true)
    local beak_lvl = you.get_base_mutation_level("beak", true, false, true)
    if horns_lvl + antennae_lvl + beak_lvl > 0 then
      if it.artefact or it.branded then return alert_item(it, "Branded headgear") end
	  return true
	end
  end
  
  return false
end
--------------------------------------------
---- End alert_armour_while_mutated() ----
--------------------------------------------

------------------------------------------
---- Begin alert_interesting_armour() ----
------------------------------------------
local function alert_interesting_armour(it)
  if it.artefact then 
    if not it.fully_identified then return false end
	return alert_item(it, "Artefact armour")
  end
  local st, _ = it.subtype()

  if st == "body" then
	local cur = items.equipped_at("body armour")
    if not cur then return false end
	
	if it.encumbrance == cur.encumbrance then
	  if has_ego(it) then
	    if not has_ego(cur) then return alert_item(it, "Added ego") end
		if it.ego() ~= cur.ego() then return alert_item(it, "New ego") end
	  end
	  if get_armour_ac(it) > get_armour_ac(cur) then return alert_item(it, "Stronger armour1") end
	
	elseif it.encumbrance < cur.encumbrance then
      -- Lighter armour
	  local ev_gain = get_armour_ev(it) - get_armour_ev(cur)
	  local ac_lost = get_armour_ac(cur) - get_armour_ac(it)
	  
	  if has_ego(it) then
	    if not cur.artefact and not has_ego(cur) then
		  if ev_gain >= 0.6 * ac_lost or ac_lost <= 6 then return alert_item(it, "Added ego1") end
		elseif it.ego() ~= cur.ego() then
	      if ev_gain >= 0.8 * ac_lost or ac_lost <= 6 then return alert_item(it, "New ego1") end
		else
		  -- Same ego
		  if ev_gain >= 1.2 * ac_lost then return alert_item(it, "Lighter armour1") end
		end
	  else
	    if cur.artefact or has_ego(cur) then
		  -- Lost ego
		  if ev_gain >= 2 * ac_lost then return alert_item(it, "Lighter armour2") end
		else
		  -- Neither has ego
		  if ev_gain >= 1.2 * ac_lost then return alert_item(it, "Lighter armour3") end
		end
	  end
    else
	  -- Heavier armour
	  local ac_gain = get_armour_ac(it) - get_armour_ac(cur)
	  local ev_lost = get_armour_ev(cur) - get_armour_ev(it)
	  local encumb_penalty = 0
	  if you.skill("Spellcasting") > 1 then encumb_penalty = (it.encumbrance - cur.encumbrance)/2 end
	  
	  
	  if has_ego(it) then
	    if not cur.artefact and not has_ego(cur) then
		  if ac_gain >= 0.4 * ev_lost or ev_lost <= 8 then return alert_item(it, "Added ego2") end
		elseif it.ego() ~= cur.ego() then
	      if ac_gain >= 0.6 * ev_lost or ev_lost <= 8 then return alert_item(it, "New ego2") end
		else
		  -- Same ego
		  if ac_gain >= 0.8 * ev_lost + encumb_penalty then return alert_item(it, "Stronger armour2") end
		end
	  else
	    if cur.artefact or has_ego(cur) then
		  -- Lost ego
		  if ac_gain >= 1 * ev_lost + encumb_penalty then return alert_item(it, "Stronger armour3") end
		else
		  -- Neither has ego
		  if ac_gain >= 0.8 * ev_lost + encumb_penalty then return alert_item(it, "Stronger armour4") end
		end
	  end
	end
  elseif st == "shield" then
    local cur = items.equipped_at("shield")
	if not cur then return false end
    if it.branded and it.ego() ~= cur.ego() then
	  for slot = 0,51 do
	    local inv = items.inslot(slot)
		if inv and inv.name() == it.name() then return false end
	  end
	  return alert_item(it, "New egoS")
	end
  else
    -- Aux armour
    local cur = items.equipped_at(st)
	if cur and not it.is_useless and get_armour_ac(it) > get_armour_ac(cur) then return alert_item(it, "Stronger armour5") end
    return alert_armour_while_mutated(it, st)
  end
end
----------------------------------------
---- End alert_interesting_armour() ----
----------------------------------------

function alert_armour(it)
  if not it.is_useless then alert_armour_upgrades(it) end
  if it.fully_identified or not it.branded then alert_interesting_armour(it) end
end

}

########pickup-alert/pa-weapons.rc########


{
loaded_pa_weapons = true

--------------------------
---- Begin inv arrays ----
--------------------------
-- Use these arrays to compare potential upgrades against entire inventory
local top_school = "unarmed combat"
local all_schools = { "axes", "maces & flails", "long blades", "short blades", "staves", "unarmed combat", "ranged weapon" }
local function set_top_school()
  local max = 0
  
  for _, v in ipairs(all_schools) do
    if you.skill(v) > max then
	  max = you.skill(v)
	  top_school = v
	end
  end
end


local inv_max_dmg = { melee = 0, melee_b = 0, twohands = 0, twohands_b = 0, ranged = 0, ranged_b = 0 }
local inv_max_dmg_acc = { melee = 0, melee_b = 0, twohands = 0, twohands_b = 0, ranged = 0, ranged_b = 0 }
local egos = { }

local function get_weap_type(it)
  if it.is_ranged then
	if it.branded then return "ranged_b"
	else return "ranged" end
  else
	if get_hands(it) == 2 then
	  if it.branded then return "twohands_b"
	  else return "twohands" end
	else
	  if it.branded then return "melee_b"
	  else return "melee" end
	end
  end
end

local function enforce_dmg_floor(target, floor)
  if inv_max_dmg[target] < inv_max_dmg[floor] then
    inv_max_dmg[target] = inv_max_dmg[floor]
	inv_max_dmg_acc[target] = inv_max_dmg_acc[floor]
  end
end

local function generate_inv_weap_arrays()
  set_top_school()
  
  for slot=0,51 do
    local cur
	cur = items.inslot(slot)
    if cur and cur.class(true) == "weapon" then
	  if cur.ego() then table.insert(egos, cur.ego()) end
	  
	  local dmg = get_weap_dps(cur)
	  local weap_type = get_weap_type(cur)
	  if dmg > inv_max_dmg[weap_type] then
	    inv_max_dmg[weap_type] = dmg
		inv_max_dmg_acc[weap_type] = cur.accuracy + cur.plus
      end
	end
  end
  
  enforce_dmg_floor("melee", "melee_b")
  enforce_dmg_floor("twohands_b", "melee_b")
  enforce_dmg_floor("twohands", "twohands_b")
  enforce_dmg_floor("twohands", "melee")
  enforce_dmg_floor("ranged", "ranged_b")
end
------------------------
---- End inv arrays ----
------------------------



-------------------------------
---- alert_early_weapons() ----
-------------------------------
-- Alert strong weapons early
local function alert_early_weapons(it)
  -- Alert really good usable ranged weapons
  if you.xl() <= 14 then
    if it.fully_identified and it.is_ranged then
	  if it.branded and it.plus >= 5 or it.plus >= 7 then
	    if get_hands(it) == 1 or not items.equipped_at("shield") or you.skill("shield") <= 8 then
		  return alert_item(it, "Ranged weapon9")
		end
	  end
	end
  end

  -- Skip items when we're clearly going another route
  if you.skill(top_school) - you.skill(it.weap_skill) > 1.5*you.xl()+3 then return end


  if you.xl() <= 8 then
	if it.branded or it.plus and it.plus >= 4 then
	  -- Make sure we don't alert a pure downgrade to something in inventory
	  for slot = 0,51 do
	    local inv = items.inslot(slot)
		if inv and inv.name("base") == it.name("base") then
		  if inv.plus >= it.plus then
		    if not it.branded then return end
		    if it.ego() == inv.ego() then return end
		  end
		end
	  end
	  
	  return alert_item(it, "Early weapon")
    end
  end
end


----------------------------
---- Alert first ranged ----
----------------------------
local function alert_first_ranged(it)
  if not it.is_ranged then return false end
  
  if get_hands(it) == 2 then
	if items.equipped_at("shield") then return false end
    if alerted_first_ranged_two_handed == 0 then
	  alerted_first_ranged_two_handed = 1
	  for slot=0,51 do
	    local inv = items.inslot(slot)
		if inv and inv.is_ranged and get_hands(inv) == 2 then return true end
      end
	  return alert_item(it, "Ranged weapon5")
	end
  else
    if alerted_first_ranged_one_handed == 0 then
	  alerted_first_ranged_one_handed = 1
	  for slot=0,51 do
	    local inv = items.inslot(slot)
		if inv and inv.is_ranged then return true end
      end
	  return alert_item(it, "Ranged weapon6")
	end
  end
  
  return false
end

--------------------------------
---- Begin pickup_weapons() ----
--------------------------------

local function pickup_weapon(it, cur)
  if cur.subtype() == it.subtype() then
    -- Exact weapon type match
    if it.artefact then return true end
    if cur.artefact then return false end
	if it.branded and it.fully_identified and not cur.branded then return true end
	if cur.branded and not it.branded then return false end
	return it.ego() == cur.ego() and get_weap_dps(it) > get_weap_dps(cur)
  elseif you.skill(it.weap_skill) >= 0.5 * you.skill(cur.weap_skill) then
	-- A usable weapon school
	-- Replace cur weapon if new one does more damage, unless there are potential benefits to cur
	if get_hands(it) > get_hands(cur) then return false end
	if it.is_ranged ~= cur.is_ranged then return false end
	if cur.weap_skill == "Polearms" and it.weap_skill ~= "Polearms" then return false end
	
	if it.artefact then return true end
	if cur.artefact then return false end
	if it.branded and not it.fully_identified then return false end
    if cur.branded and not it.branded then return false end

    local dmg_delta
    if get_weap_dps(cur) > inv_max_dmg[get_weap_type(it)] then 
	  dmg_delta = get_weap_dps(it) - get_weap_dps(cur)
	else
	  dmg_delta = get_weap_dps(it) - inv_max_dmg[get_weap_type(it)]
	end
	
	if dmg_delta > 0 then return true end
	local it_plus = it.plus
	if not it_plus then it_plus = 0 end
	return dmg_delta == 0 and (it.accuracy+it_plus) > inv_max_dmg_acc[get_weap_type(it)]
  end
  
  return false
end



function pickup_weapons(it)
  if it.is_useless then return false end
  
  generate_inv_weap_arrays()
  local unarmed = true

  for slot=0,51 do
    local cur
	cur = items.inslot(slot)
    if cur and cur.class(true) == "weapon" then
	  if pickup_weapon(it, cur) then
	    return pickup_item(it)
	  end
	  if not cur.is_ranged then
	    unarmed = false
	  end
	end
  end
  
  -- Return false unless you need a weapon but don't have one yet
  if not unarmed or you.skill("Unarmed Combat") > 0 then return false end
  if you.get_base_mutation_level("claws", true, false, true) > 0 then return false end
  if you.get_base_mutation_level("demonic touch", true, false, true) > 0 then return false end
  
  return true
end

------------------------------
---- End pickup_weapons() ----
------------------------------

-------------------------------------------
---- Begin alert_interesting_weapons() ----
-------------------------------------------
local function alert_interesting_weapon(it, cur)
  -- Try to avoid auto-replacing stat sticks
  if cur.artefact and you.skill(it.weap_skill) < 2 and you.xl() > 6 then return false end
	
  if cur.subtype() == it.subtype() then
    -- Exact weapon type match
	if it.branded and it.ego() ~= cur.ego() then return alert_item(it, "New ego1") end
	if get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then return alert_item(it, "Stronger weapon0") end
  elseif you.skill(it.weap_skill) >= 0.5 * you.skill(cur.weap_skill) then
	-- A usable weapon school
	if it.is_ranged ~= cur.is_ranged then return false end
	--local penalty = 1
	--if it.weap_skill == top_school then penalty = 0.5 end
	local penalty = 0.5 * you.skill(cur.weap_skill) / you.skill(it.weap_skill)
	if get_hands(it) == 2 and get_hands(cur) == 1 then
	  -- Item requires an extra hand
	  if it.artefact then return alert_item(it, "2-handed artefact") end
	  if it.branded and not cur.artefact and not cur.branded then
	    if get_weap_dps(it) > 0.8*get_weap_dps(cur) then return alert_item(it, "2-handed weapon1") end
	  end
	  
	  if not items.equipped_at("shield") then 
		if it.branded and it.ego() ~= cur.ego() then return alert_item(it, "New ego") end
		if not (cur.branded or cur.artefact) and get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then return alert_item(it, "2-handed weapon2") end
		if (cur.branded or cur.artefact) and not it.branded and get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then return alert_item(it, "2-handed weapon3") end
	  elseif you.skill("shields") <= 4 then
	    -- Not really training shields; may be interested in big upgrades
		if get_weap_dps(it) >= penalty*2*inv_max_dmg["melee"] then return alert_item(it, "2-handed weapon4") end
	  end
	else
	  -- Item uses same number of hands or fewer
	  if cur.artefact then return false end
	  if it.branded then
	    local dmg_delta = get_weap_dps(it) - inv_max_dmg[get_weap_type(it)]
	    if not cur.branded then
		  if dmg_delta >= -4/penalty then return alert_item(it, "New ego2") end
		elseif it.ego() == cur.ego() then
		  if dmg_delta >= 0 then return alert_item(it, "Stronger weapon1") end
		elseif not util.contains(egos, it.ego()) then
		  if dmg_delta >= -4/penalty then return alert_item(it, "New ego3") end
		end
	  else
	    -- Not branded
	    if cur.branded then
		  if get_weap_dps(it) > inv_max_dmg[get_weap_type(it)] then
		  	return alert_item(it, "Stronger weapon2")
		  end
		else
		  local dmg_delta, other_acc
          if get_weap_dps(cur) > inv_max_dmg[get_weap_type(it)] then 
	        dmg_delta = get_weap_dps(it) - get_weap_dps(cur)
			other_acc = cur.accuracy + cur.plus
	      else
	        dmg_delta = get_weap_dps(it) - inv_max_dmg[get_weap_type(it)]
			other_acc = inv_max_dmg_acc[get_weap_type(it)]
	      end
		  
		  if dmg_delta > 0 then return alert_item(it, "Stronger weapon3") end
		  local it_plus = it.plus
	      if not it_plus then it_plus = 0 end
		  if dmg_delta == 0 and (it.accuracy+it_plus) > other_acc then return alert_item(it, "Higher accuracy") end
		end
      end	  
	end
  end
end


local function alert_interesting_weapons(it)
  generate_inv_weap_arrays()
  
  local ranged_weap_in_inv = false
  for slot=0,51 do
    cur = items.inslot(slot)
	if cur and cur.class(true) == "weapon" then
      if alert_interesting_weapon(it, cur) then return true end
	  if cur.is_ranged then ranged_weap_in_inv = true end
	end
  end
  
  -- Alert for the first ranged weapon found (for 1 and 2 handed separately)
  if it.is_ranged and not ranged_weap_in_inv then
	if it.artefact or it.branded and it.plus >= 4 then
	  if items.equipped_at("shield") then
	    local qualname = it.name("qual")
	    if qualname:find("hand crossbow") or qualname:find("sling") then
		  return alert_item(it, "Ranged Weapon1")
		end
	  else
	    return alert_item(it, "Ranged Weapon2")
	  end
	end
  end
  
  return false
end
-----------------------------------------
---- End alert_interesting_weapons() ----
-----------------------------------------

local function alert_high_scores(it)
  local it_plus = it.plus
  if not it_plus then it_plus = 0 end

  score = get_weap_dps(it) + it.accuracy + it_plus
  if score > weapon_high_score then
    weapon_high_score = score
    alert_item(it, "Strongest weapon")
  end
  
  local score = get_weap_dps(it, false) + it.accuracy + it_plus
  if score > unbranded_high_score then
    unbranded_high_score = score
    alert_item(it, "Strongest pure damage")
  end
  
  if it.weap_skill == "Polearms" and you_have_summons() then
    if get_hands(it) == 1 or not items.equipped_at("shield") then
	  local score = get_weap_dps(it) + it.accuracy + it_plus
	  if score > polearm_high_score then
	    polearm_high_score = score
		alert_item(it, "Strongest polearm")
	  end
	end
  end
end

function alert_weapons(it)
  if (it.artefact or it.branded) and not it.fully_identified then return end
  
  alert_interesting_weapons(it)
  alert_first_ranged(it)
  alert_early_weapons(it)
  alert_high_scores(it)
end
}

########pickup-alert/pa-misc.rc########


{
loaded_pa_misc = true


--------------------------
---- Alert rare items ----
--------------------------
function alert_rare_items(it)
  local index = get_rare_item_index(it)
  if index == -1 then return end
  
  local do_alert = true
  -- Don't alert if already wearing a larger shield
  if rare_items[index] == "buckler" then
    local sh = items.equipped_at("shield")
	if sh and sh.name("base") ~= "orb" then do_alert = false end
  elseif rare_items[index] == "kite shield" then
    local sh = items.equipped_at("shield")
    if sh and sh.name("base"):find("tower shield") then do_alert = false end
  end
	
  if do_alert then
    -- Found a new rare item! We may already have one if it was auto-picked up
    crawl.mpr("<magenta>----It's your first " .. rare_items[index] .. "!----</magenta>", "item")
    crawl.more()
  end

  rare_items[index] = ""
  
  return
end
crawl.setopt("runrest_stop_message += It's your first.*!")


--------------------
---- Alert orbs ----
--------------------
function alert_orbs(it)
  if items.equipped_at("shield") then return false end
  if not it.fully_identified then return false end
  alert_item(it, "New orb")
  return false
end



----------------------------
---- Smart staff pickup ----
----------------------------
function pickup_staves(it)
  if it.is_useless or not it.fully_identified then return false end

  local basename = it.name("base")
  local good_staff = false
  if basename == "staff of fire" then good_staff = you.skill("Fire Magic") > 0
  elseif basename == "staff of cold" then good_staff = you.skill("Ice Magic") > 0
  elseif basename == "staff of earth" then good_staff = you.skill("Earth Magic") > 0
  elseif basename == "staff of air" then good_staff = you.skill("Air Magic") > 0
  elseif basename == "staff of poison" then good_staff = you.skill("Poison Magic") > 0
  elseif basename == "staff of death" then good_staff = you.skill("Necromancy") > 0
  elseif basename == "staff of conjuration" then good_staff = you.skill("Conjurations") > 0
  else crawl.mpr("Unrecognized staff: " .. basename, "error")
  end
  
  if good_staff == true then
    return pickup_item(it)
  end
  
  return false
end


------------------------
---- alert_staves() ----
------------------------
function alert_staves(it)
  if not it.fully_identified then return false end
  local needRes = false
  local basename = it.name("base")
  
  if basename == "staff of fire" then needRes = you.res_fire() == 0
  elseif basename == "staff of cold" then needRes = you.res_cold() == 0
  elseif basename == "staff of air" then needRes = you.res_shock() == 0
  elseif basename == "staff of poison" then needRes = you.res_poison() == 0
  elseif basename == "staff of death" then needRes = you.res_draining() == 0
  end
  
  if needRes == true then
    return alert_item(it, "Staff resistance")
  end
  
  return false
end

}

### Features ###


########features/inscribe-dps.rc########

{

------------------------------------------
------------------ Hook ------------------
------------------------------------------
function ready_inscribe_dps()
  for slot = 0,51 do
    local it = items.inslot(slot)
	if it and (it.class(true) == "weapon" or it.class(true) == "magical staff") then
	  inscribe_stats(it)
	end
  end
end
}

########features/remind-id.rc########

{
-------------------------------------
---- Unidentified items reminder ----
-------------------------------------
local function remind_unidentified_items(have_unidentified)
  for i=0,51 do
    if not have_unidentified then
      local it = items.inslot(i)
      if it and not it.fully_identified then have_unidentified = true end
	end

    if have_unidentified then
      for slot=0,51 do
        local s = items.inslot(slot)
        if s and s.name("qual"):find("scroll of identify") then
	      crawl.mpr("<magenta>----You have something to identify.----</magenta>", "plain")
		  return
		end
	  end
	  
	  return
    end
  end
  
end
crawl.setopt("runrest_stop_message += You have something to identify")



---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_message_remind_identify(text, channel)
  if channel ~= "plain" then return end

  if text:find(" of identify") and not text:find("drop") and not text:find("read") then
	remind_unidentified_items(false)
  end
end

function c_assign_invletter_remind_identify(it)
  if not it.fully_identified then remind_unidentified_items(true) end
end
}

########features/weapon-slots.rc########

{
------------------------------
---- Cleanup weapon slots ----
------------------------------
-- Assigns weapons/staves to slots a and b.
-- Assigns ranged weapon to w (if not already in slot a or b).

--------------
---- Util ----
--------------
local function get_first_empty_slot()
  for slot=1,52 do
    if not items.inslot(slot) then return slot end
  end
end


local function is_early_slot_wpn(it)
  if not it then return false end
  local class = it.class(true)
  if class == "magical staff" then return true end
  if class == "weapon" then
    if it.is_ranged then return you.skill("Ranged Weapons") >= 4 end
	return true
  end
  
  return false
end

--------------
---- main ----
--------------
local do_cleanup_weapon_slots = false
local function cleanup_weapon_slots()
  local slot_w = items.letter_to_index("w")
  
  -- Move non-ranged, non-polearm weapons to slots a & b
  for i=0,1 do
    local inv = items.inslot(i)
    if not is_early_slot_wpn(inv) then
	  for replacement=1,51 do
	    -- Adjust replacement to prioritize moving slot w last
	    local adj_replacement
		if replacement == 51 then adj_replacement = slot_w
		elseif replacement >= slot_w then adj_replacement = replacement + 1
	    else adj_replacement = replacement
		end
		
		local it = items.inslot(adj_replacement)
		if is_early_slot_wpn(it) and it.weap_skill ~= "Polearms" then
		  items.swap_slots(adj_replacement, i)
		  if i == 0 then cleanup_weapon_slots() end
		  break
		end
	  end
	end
  end
  
  -- Move polearms slots a & b
  for i=0,1 do
    local inv = items.inslot(i)
    if not is_early_slot_wpn(inv) then
	  for replacement=1,51 do
	    -- Adjust replacement to prioritize moving slot w last
	    local adj_replacement
		if replacement == 51 then adj_replacement = slot_w
		elseif replacement >= slot_w then adj_replacement = replacement + 1
	    else adj_replacement = replacement
		end
		
		local it = items.inslot(adj_replacement)
		if it and it.weap_skill ~= "Polearms" then
		  items.swap_slots(adj_replacement, i)
		  if i == 0 then cleanup_weapon_slots() end
		  break
		end
	  end
	end
  end
  
  -- Move any polearm or ranged to slot w
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if not inv or not (inv.is_ranged or inv.weap_skill == "Polearms") then
    for replacement = 2,51 do
	  local it = items.inslot(replacement)
	  if it and (it.is_ranged or it.weap_skill == "Polearms") then
		items.swap_slots(replacement, slot_w)
		return
	  end
	end
  end
  
  -- Move any 3rd weapon to slot w
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if not inv or inv.class(true) ~= "weapon" then
    for replacement = 2,51 do
	  local it = items.inslot(replacement)
	  if it and it.class(true) == "weapon" then
		items.swap_slots(replacement, slot_w)
		return
	  end
	end
  end
end



---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_assign_invletter_weapon_slots(it)
  if it.class(true) ~= "weapon" and it.class(true) ~= "magical staff" then return end
  
  if is_early_slot_wpn(it) then
    for i=0,1 do
	  local inv = items.inslot(i)
	  if not inv then return i end
	  if not is_early_slot_wpn(inv) then
		items.swap_slots(i, get_first_empty_slot())
		return i
	  end
	end
  end
  
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if not inv then return slot_w end
  if inv.class(true) ~= "weapon" then
	items.swap_slots(slot_w, get_first_empty_slot())
	return slot_w
  end
  
  -- Bump a regular weapon out of slot w for a polearm or ranged weapon
  if (it.is_ranged or it.weap_skill == "Polearms")
      and not (inv.is_ranged or inv.weap_skill == "Polearms") then
    items.swap_slots(slot_w, get_first_empty_slot())
    return slot_w
  end
end



function c_message_weapon_slots(text, channel)
  if channel ~= "plain" then return end
  if not text:find("You drop ") then return end
  do_cleanup_weapon_slots = true
end



function ready_weapon_slots()
  if do_cleanup_weapon_slots then
    cleanup_weapon_slots()
    do_cleanup_weapon_slots = false
  end
end

}

########features/exclude-dropped.rc########

{
-- Add autopickup exclusion for any jewellery or missile that is dropped
-- Exclusion is removed when you pick the item back up
-- No hooks required

-----------------------------------
---- Exclude dropped jewellery ----
-----------------------------------
if not jewellery_exclusions or you.turns() == 0 then
  jewellery_exclusions = ""
end

local function persist_jewellery_exclusions()
  return "jewellery_exclusions = \""..jewellery_exclusions.."\""..string.char(10)
end

if not added_jewellery_exclusion_hook then
  table.insert(chk_lua_save, persist_jewellery_exclusions)
  added_jewellery_exclusion_hook = true
end

local function c_message_exclude_dropped_jewellery(text, channel)
  if channel ~= "plain" then return end
  
  local exclude
  if text:find("You drop ") then
    exclude = true
  elseif text:find(" %- ") then
    exclude = false
  else
    return
  end
  
  local idx = text:find("ring of ")
  if not idx then idx = text:find("amulet of ") end
  if not idx then return end
  
  text = text:gsub(" {.*}", "")
  text = text:gsub("[.]", "")
  item_name = text:sub(idx,#text)
	
  if exclude then
    crawl.setopt("autopickup_exceptions ^= >"..item_name)
    -- Add persistant exclusion
	if jewellery_exclusions ~= "" then jewellery_exclusions = jewellery_exclusions.."," end
    jewellery_exclusions = jewellery_exclusions..">"..item_name
  else
	crawl.setopt("autopickup_exceptions -= >"..item_name)
	-- Remove persistant exclusion (try 3 times to make sure we capture comma)
    jewellery_exclusions = jewellery_exclusions:gsub(",>"..item_name, "")
	jewellery_exclusions = jewellery_exclusions:gsub(">"..item_name..",", "")
	jewellery_exclusions = jewellery_exclusions:gsub(">"..item_name, "")
  end
end
if jewellery_exclusions ~= "" then crawl.setopt("autopickup_exceptions ^= "..jewellery_exclusions) end


----------------------------------
---- Exclude dropped missiles ----
----------------------------------
if not missile_exclusions or you.turns() == 0 then
  missile_exclusions = ""
end

local function persist_missile_exclusions()
  return "missile_exclusions = \""..missile_exclusions.."\""..string.char(10)
end

if not added_missle_exclusion_hook then
  table.insert(chk_lua_save, persist_missile_exclusions)
  added_missle_exclusion_hook = true
end

local function c_message_exclude_dropped_missiles(text, channel)
  if channel ~= "plain" then return end
  
  local exclude
  if text:find("You drop ") then
    exclude = true
  elseif text:find(" %- ") then
    exclude = false
  else
    return
  end
  
  local all_missiles = { " stone", "poisoned dart", "curare", "atropa", "datura", "boomerang", "javelin" }
  local item_name
  for _, v in ipairs(all_missiles) do
    if text:find(v) then
	  item_name = v
	  if item_name == "boomerang" or item_name == "javelin" then
	    if text:find("silver") then
		  item_name = "silver "..item_name
		elseif text:find("dispersal") then
		  item_name = item_name.."s? of dispersal"
		else
		  item_name = "(?<!silver )"..item_name.."(?!(s? of dispersal))"
		end
	  end
	  
	  if exclude then
        crawl.setopt("autopickup_exceptions ^= >"..item_name)
        -- Add persistant exclusion
	    if missile_exclusions ~= "" then missile_exclusions = missile_exclusions.."," end
        missile_exclusions = missile_exclusions..">"..item_name
      else
	    crawl.setopt("autopickup_exceptions -= >"..item_name)
	    -- Remove persistant exclusion (try 3 times to make sure we capture comma)
        missile_exclusions = missile_exclusions:gsub(",>"..item_name, "")
	    missile_exclusions = missile_exclusions:gsub(">"..item_name..",", "")
	    missile_exclusions = missile_exclusions:gsub(">"..item_name, "")
      end
	  
	  return
	end
  end
end
crawl.setopt("autopickup_exceptions ^= < stone, <dart, <boomerang, <javelin")
if missile_exclusions ~= "" then crawl.setopt("autopickup_exceptions ^= "..missile_exclusions) end

}

########features/safe-consumables.rc########

###############################
####### Auto-inscribe #########
# Unidentified consumables
autoinscribe += potions?(?!.*of ):!q
autoinscribe += scrolls?(?!.*of ):!r

# Add a warning for everything that doesn't have one built-in
autoinscribe += potions? of(?!.*(attraction|lignification|mutation)):!q
autoinscribe += scrolls? of(butterflies|fear|fog|magic mapping|posion|silence|summoning|teleportation|torment|vulnerability):!r


{
--------------------------------------------
---- Protective consumable inscriptions ----
--------------------------------------------
-- Initialize to true to fix inscriptions on init (starting items don't get default inscriptions)
local no_inscriptions = {"acquirement", "amnesia", "blinking", "brand weapon", "enchant armour", "enchant weapon", 
		                 "identify", "immolation", "noise", "poison", "vulnerability", "attraction", "lignification", "mutation" }

local function fix_inscriptions()
  -- Remove the default "!r" and "!q" inscriptions after identify
  local keystring = ""
  for slot=0,51 do
    local it = items.inslot(slot)
	
    if it and it.fully_identified then
      local it_class = it.class(true)
      if it_class == "potion" or it_class == "scroll" then
        local qualname = it.name("qual")
        local st, _ = it.subtype()
		
        if util.contains(no_inscriptions, st) then
          if it.inscription:find("%!r") then it.inscribe(it.inscription:gsub("%!r", ""), false) end
		  if it.inscription:find("%!q") then it.inscribe(it.inscription:gsub("%!q", ""), false) end
	    elseif it_class == "scroll" and not util.contains(no_inscriptions, st) and not qualname:find("!r") then
	      it.inscribe("!r")
	    elseif it_class == "potion" and not util.contains(no_inscriptions, st) and not qualname:find("!q") then
	      it.inscribe("!q")
		end
	  end
	end
  end
end


local do_fix_inscriptions = true

---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function ready_safe_consumables()
  if do_fix_inscriptions then
    fix_inscriptions()
	do_fix_inscriptions = false
  end
end


function c_message_safe_consumables(text, channel)
  if channel ~= "plain" then return end
  local triggers = { "Thank you for shopping at", "s a scroll of ", "s a potion of ", "read the scroll of identify" }
  for _, v in ipairs(triggers) do
    if text:find(v) then
	  fix_inscriptions()
      do_fix_inscriptions = true
	  return
	end
  end
end

}

########features/drop-inferior.rc########

-- Auto-drop items that are strictly worse than another
-- On item pickup, inscribes inferior items with "~drop"
drop_filter += ~drop

{
------------------------------------------
------------------ Hook ------------------
------------------------------------------
function c_assign_invletter_drop_inferior(it)
  -- Skip brands that are potentially harmful
  local it_ego = it.ego()
  if it_ego == "distortion" or it_ego == "chaos" or it_ego == "infusion" then return end
  
  local it_class = it.class(true)
  if it_class ~= "weapon" and it_class ~= "armour" then return end
  
  local risky_artefact = false
  if it.artefact then
    local qualname = it.name("qual")
    if qualname:find("%-") or qualname:find("Harm") or qualname:find("Infuse") then
      risky_artefact = true
    end
  end

  if risky_artefact then return end

  local st = it.subtype()
  local basename = it.name("base")

  for slot=0,51 do
    local inv = items.inslot(slot)
	if inv then
	  local item_match = false
	  if inv.subtype() == st then
	    if st == "body" then
	      if inv.encumbrance >= it.encumbrance then item_match = true end
		else
		  if inv.name("base") == basename then item_match = true end
		end
	  end

      if not inv.artefact and item_match and (not has_ego(inv) or inv.ego() == it.ego()) then
        if it_class == "weapon" then
          if inv.plus <= it.plus then inv.inscribe("~drop") end
        else
          if inv.ac <= it.ac then inv.inscribe("~drop") end
	    end
	  end
	end
  end -- end for slot=0,51
end
}

########features/runrest-stop.rc########

{
-------------------------------------
---- Hooks (All functions below) ----
-------------------------------------
-- You can add/remove these hooks a-la-carte if you don't like any


-----------------------
---- Ignore altars ----
-----------------------
local stop_on_altars = true

function ready_ignore_altars()
  if stop_on_altars and (you.god() ~= "No God" or you.branch() == "Temple") then
    stop_on_altars = false
	crawl.setopt("explore_stop -= altars")
  elseif not stop_on_altars and you.god() == "No God" and you.branch() ~= "Temple" then
    stop_on_altars = true
	crawl.setopt("explore_stop += altars")
  end
end


-----------------------------------------------
---- Search altars in temple after explore ----
-----------------------------------------------
function c_message_search_altars_in_temple(text, channel)
  if you.branch() == "Temple" and text:find("explor") then
    crawl.sendkeys({ 6, "altar\r" })
  end
end


-----------------------------
---- Ignore exit portals ----
-----------------------------
local ignore_exit_brances = { "Bailey", "Bazaar", "Ice Cave", "Ossuary", "Sewer", "Trove", "Volcano", "Ziggurat" }
local stop_on_portals = true

function ready_ignore_exits()
  local branch = you.branch()
  if stop_on_portals and util.contains(ignore_exit_brances, branch) then
    stop_on_portals = false
	crawl.setopt("explore_stop -= portals")
  elseif not stop_on_portals and not util.contains(ignore_exit_brances, branch) then
    stop_on_portals = true
	crawl.setopt("explore_stop += portals")
  end
end


-------------------------------------
---- Ignore summons disappearing ----
-------------------------------------
function ch_stop_running_ignore_summons(kind)
  local runrest_ignore_summons = { "crumbles into dust", "fades into mist", "returns to the shadows", 
                                   "Your foxfire dissipates", "Your.*simulacrum vaporises", "Your crimson imp blinks" }
  local text = crawl.messages(1)
  for _, v in ipairs(runrest_ignore_summons) do
    if text:find(v) then
      if kind:find("explore") then crawl.sendkeys("o") end
	  if kind == "" then crawl.sendkeys("5") end
	end
  end
end


------------------------------
---- Ignore sense monster ----
------------------------------
function ch_stop_running_ignore_sense_monsters(kind)
  if crawl.messages(1):find("You sense a monster nearby") then
    if kind:find("explore") then crawl.sendkeys("o") end
	if kind == "" then crawl.sendkeys("5") end
  end
end


-----------------------
---- Ignore mimics ----
-----------------------
function ch_stop_running_ignore_mimics(kind)
  if crawl.messages(1):find("mimic.*vanishes") then
    if kind:find("explore") then crawl.sendkeys("o") end
  end
end


----------------------------------------
---- Stop on recovery if full hp/mp ----
----------------------------------------
function c_message_stop_wait_on_recovery(text, channel)
  if text:find("You start waiting.") then
    crawl.setopt("runrest_ignore_message -= recovery:.*")
    crawl.setopt("runrest_ignore_message -= duration:.*")
  elseif text:find("Done waiting.") then
	crawl.setopt("runrest_ignore_message += recovery:.*")
    crawl.setopt("runrest_ignore_message += duration:.*")
  end
end
}

########features/mute-swaps.rc########

{
-- When an item is moved to its assigned slot, mute the messages for the item that was previously in that slot
-- If we cared what slot the item was in, it'd already be assigned somewhere
-- This mostly matters when reading scroll of ID, where 5-6 lines of inventory items can be confusing

--------------
---- Util ----
--------------
local function cleanup_message(text)
  local tags_removed = {}
  
  local keep_going = true
  while keep_going do
    local opening = text:find("<")
	local closing = text:find(">")	
	
	if opening and closing and opening < closing then
	  local new_text = ""
      if opening > 1 then new_text = text:sub(1, opening-1) end
	  if closing < #text then new_text = new_text..text:sub(closing+1, #text) end
	  text = new_text
	else
	  keep_going = false
	end
  end
  
  text = text:gsub("\n", "")
  return text
end

local muted_items = {}


---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function ready_mute_swaps()
  for _, v in ipairs(muted_items) do
    crawl.setopt("message_colour -= mute: - "..v)
  end
end


function c_message_mute_swaps(text, channel)
  -- Mute subsequent item re-assignments in a single turn, for everything after the first item.
  -- Multiple slots for the same item will still be shown
  if channel == "plain" then 
    text = cleanup_message(text)
    if text:sub(2,4) == " - " then
      local item = text:sub(5, #text)
      local mute_str = "(?!.*"..item..")"
      table.insert(muted_items, mute_str)
      crawl.setopt("message_colour ^= mute: - "..mute_str)
	  return
	end
  end

  ready_mute_slot_swaps()
end
}

########features/after-shaft.rc########

{
------------------------------------
---- Stop on stairs after shaft ----
------------------------------------
if not shaft_depth or you.turns() == 0 then
  shaft_depth = 0
  shaft_branch = "NA"
end

function persist_shaft_values()
  local cmd = "shaft_depth = "..shaft_depth..string.char(10) .."shaft_branch = \""..shaft_branch.."\""..string.char(10)
  return cmd
end

if not added_shaft_stairs_hook then
  table.insert(chk_lua_save, persist_shaft_values)
  added_shaft_stairs_hook = true
end


---------------------------------------------
------------------- Hooks -------------------
---------------------------------------------
function c_message_after_shaft(text, channel)
  if shaft_depth ~= 0 then return end
  if text:find("fall into a shaft") then
	shaft_depth = you.depth()
	shaft_branch = you.branch()
	crawl.setopt("explore_stop += stairs")
  end
end

function ready_after_shaft()
  if shaft_depth ~= 0 then
	if you.depth() == shaft_depth and you.branch() == shaft_branch then
	  crawl.setopt("explore_stop -= stairs")
	  shaft_depth = 0
	  shaft_branch = "NA"
	end
  end
end

}


####################################################################
######################## Lua Hook Functions ########################
####################################################################
{
----------------------------------
---------- c_message() -----------
----------------------------------
function c_message(text, channel)

  if c_message_remind_identify then c_message_remind_identify(text, channel) end
  if c_message_weapon_slots then c_message_weapon_slots(text, channel) end
  if c_message_exclude_dropped_jewellery then c_message_exclude_dropped_jewellery(text, channel) end
  if c_message_exclude_dropped_missiles then c_message_exclude_dropped_missiles(text, channel) end
  if c_message_safe_consumables then c_message_safe_consumables(text, channel) end
  if c_message_search_altars_in_temple then c_message_search_altars_in_temple(text, channel) end
  if c_message_stop_wait_on_recovery then c_message_stop_wait_on_recovery(text, channel) end
  if c_message_mute_swaps then c_message_mute_swaps(text, channel) end
  if c_message_after_shaft then c_message_after_shaft(text, channel) end

end


-------------------------------------------
---------- c_assign_inv_letter() ----------
-------------------------------------------
function c_assign_invletter(it)
  -- Calls with no return values; just triggering on new item pickup
  if c_assign_invletter_item_alerts then c_assign_invletter_item_alerts(it) end
  if c_assign_invletter_remind_identify then c_assign_invletter_remind_identify(it) end
  if c_assign_invletter_drop_inferior then c_assign_invletter_drop_inferior(it) end
    
  -- Calls with possible return values
  local ret_val = nil
  if c_assign_invletter_weapon_slots then ret_val = c_assign_invletter_weapon_slots(it) end
  if ret_val then return ret_val end
end


---------------------------
---- ch_stop_running() ----
---------------------------
function ch_stop_running(kind)
  if ch_stop_running_ignore_summons then ch_stop_running_ignore_summons(kind) end
  if ch_stop_running_ignore_sense_monsters then ch_stop_running_ignore_sense_monsters(kind) end
  if ch_stop_running_ignore_mimics then ch_stop_running_ignore_mimics(kind) end
end

---------------------------
--------- ready() ---------
---------------------------
local last_turn = -1
function ready()
  if you.turns() == last_turn then return end
  last_turn = you.turns()
 
  if ready_force_mores then ready_force_mores() end
  if ready_dynamic_options then ready_dynamic_options() end
  if ready_inscribe_dps then ready_inscribe_dps() end
  if ready_weapon_slots then ready_weapon_slots() end
  if ready_safe_consumables then ready_safe_consumables() end
  if ready_mute_swaps then ready_mute_swaps() end
  if ready_ignore_altars then ready_ignore_altars() end
  if ready_ignore_exits then ready_ignore_exits() end
  if ready_after_shaft then ready_after_shaft() end
  
end



-----------------------------
---- Prompt auto-answers ----
-----------------------------
function c_answer_prompt(prompt)
  if prompt:find("cheaper one?") then
    crawl.mpr("Replacing shopping list items", "plain")
    return true end
  if prompt == "Die?" then return false end  
end

--Avoid weird effects after save/restart
if you.turns() > 0 then ready() end

}