## Config at start of file

################################### Begin lua/core/config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Configuration - All user-configurable settings
Author: buehler
Dependencies: (None)
--]]

-- Initialize
BRC = BRC or {}
BRC.Config = {}

BRC.Config.emojis = false -- Use emojis in alerts and announcements

-- after-shaft.lua
BRC.Config.stop_on_stairs_after_shaft = true -- Stop explore on stairs after shaft, until back to original level

-- alert-monsters.lua: Dynamically set force mores based on hp/xl/willpower/resistance/etc
BRC.Config.fm_on_uniques = true -- Stop on all Uniques & Pan lords
BRC.Config.pack_timeout = 10 -- # turns to wait before repeating an alert for a pack of monsters. 0 to disable
BRC.Config.disable_alert_monsters_in_zigs = true -- Disable dynamic force_mores in Ziggurats
BRC.Config.debug_alert_monsters = false -- Get a message when alerts toggle off/on

-- announce-hp-mp.lua: Announce HP/MP changes
BRC.Config.dmg_flash_threshold = 0.20 -- Flash screen when losing this % of max HP
BRC.Config.dmg_fm_threshold = 0.30 -- Force more for losing this % of max HP
BRC.Config.announce = {
  hp_loss_limit = 1, -- Announce when HP loss >= this
  hp_gain_limit = 4, -- Announce when HP gain >= this
  mp_loss_limit = 1, -- Announce when MP loss >= this
  mp_gain_limit = 2, -- Announce when MP gain >= this
  hp_first = true, -- Show HP first in the message
  same_line = true, -- Show HP/MP on the same line
  always_both = true, -- If showing one, show both
  very_low_hp = 0.10, -- At this % of max HP, show all HP changes and mute % HP alerts
} -- BRC.Config.announce (do not remove this comment)

-- An alternative announce setup: Displays meters after every turn. Uncomment the following block to try it.
--[[
BRC.Config.announce = {
  hp_loss_limit = 0,
  hp_gain_limit = 0,
  mp_loss_limit = 0,
  mp_gain_limit = 0,
  hp_first = true,
  same_line = true,
  always_both = true
} -- BRC.Config.announce (do not remove this comment)
--]]

-- color-inscribe.lua
BRC.Config.colorize_inscriptions = true -- Add color to any inscription on pickup (e.g. resistance, stat changes, etc)

-- drop-inferior.lua
BRC.Config.drop_inferior = true -- Mark items for drop when a strictly better item is picked up
BRC.Config.msg_on_inscribe = true -- Show a message when an item is marked for drop

-- exclude-dropped.lua: Disables auto-pickup for whatever you drop
BRC.Config.exclude_dropped = true -- Exclude items from future autopickup when dropped
BRC.Config.ignore_stashed_weapon_scrolls = true -- Don't exclude enchant/brand scrolls if holding an enchantable weapon

-- fully-recover.lua: Keep resting until these statuses are gone.
-- Special cases exist for "slowed" and "corroded". If you include them, use those exact strings only.
BRC.Config.rest_off_statuses = {
  "berserk", "confused", "corroded", "marked", "short of breath",
  "slowed", "sluggish", "tree%-form", "vulnerable", "weakened",
} -- BRC.Config.rest_off_statuses (do not remove this comment)

-- inscribe-stats.lua: Inscribe stats on pickup and adjust each turn
BRC.Config.inscribe_weapons = true
BRC.Config.inscribe_armour = true
BRC.Config.inscribe_dps_type = "plain" -- How to calc dmg for weapon inscriptions (See BRC.DMG_TYPE in constants.lua)

-- misc-alerts.lua
BRC.Config.alert_low_hp_threshold = 0.35 -- % max HP to alert; 0 to disable
BRC.Config.alert_remove_faith = true -- Reminder to remove amulet at max piety
BRC.Config.alert_spell_level_changes = true -- Alert when you gain additional spell levels
BRC.Config.save_with_msg = true -- Shift-S to save and leave yourself a message

-- remind-id.lua: Before finding scroll of ID, stop travel when increasing largest stack size, starting at:
BRC.Config.stop_on_scrolls_count = 2 -- Stop on a stack of this many un-ID'd scrolls
BRC.Config.stop_on_pots_count = 3 -- Stop on a stack of this many un-ID'd potions

-- runrest-features.lua: Runrest features
BRC.Config.ignore_altars = true -- when you have a god already
BRC.Config.ignore_portal_exits = true -- don't stop explore on portal exits
BRC.Config.stop_on_hell_stairs = true -- stop explore on hell stairs
BRC.Config.stop_on_pan_gates = true -- stop explore on pan gates
BRC.Config.temple_macros = true -- auto-search altars; run to exit after worship
BRC.Config.gauntlet_macros = true -- auto-search with filters

-- safe-consumables.lua
BRC.Config.safe_consumables = true -- Maintain !r and !q on all consumables without a built-in prompt

-- safe-stairs.lua: Detect/warn for accidental stair usage
BRC.Config.warn_v5 = true -- Prompt before entering Vaults:5
BRC.Config.warn_stairs_threshold = 5 -- Warn if taking stairs back within # turns; 0 to disable

-- startup.lua: Startup features
BRC.Config.show_skills_on_startup = true
BRC.Config.auto_set_skill_targets = {
  { "Stealth", 2.0 }, -- First, focus stealth to 2.0
  { "Fighting", 2.0 }, -- If already have stealth, focus fighting to 2.0
} -- auto_set_skill_targets (do not remove this comment)

-- weapon-slots.lua: Always use a/b/w slots for weapons
BRC.Config.do_auto_weapon_slots_abw = true -- Auto-move weapons to a/b/w slots

--[[
  Pickup/Alert system
  This does not affect other autopickup settings; just the BRC Pickup/Alert system
  Choose which items are auto-picked up, alerted, and when force-more is applied.
--]]
BRC.Config.pickup = {
  armour = true,
  weapons = true,
  staves = true,
} -- BRC.Config.pickup (do not remove this comment)

-- Which alerts are enabled
BRC.Config.alert = {
  system_enabled = true, -- If false, no alerts are generated
  armour = true,
  weapons = true,
  orbs = true,
  staff_resists = true,
  talismans = true,

  -- Only alert a plain talisman if its min_skill <= Shapeshifting + talisman_lvl_diff
  talisman_lvl_diff = you.class() == "Shapeshifter" and 27 or 6, -- 27 for Shapeshifter, 6 for everyone else

  -- Each non-useless item is alerted once.
  one_time = {
    "wand of digging", "buckler", "kite shield", "tower shield",
    "crystal plate armour", "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales",
    "quick blade", "demon blade", "eudemon blade", "double sword", "triple sword",
    "broad axe", "executioner's axe",
    "demon whip", "eveningstar", "giant spiked club", "morningstar", "sacred scourge",
    "lajatang", "bardiche", "demon trident", "partisan", "trishula", "hand cannon", "triple crossbow",
  }, -- BRC.Config.alert.one_time (do not remove this comment)

  -- Only do one-time alerts if your skill >= this value, in weap_school/armour/shield
  OTA_require_skill = { weapon = 3, armour = 2.5, shield = 0 },
} -- BRC.Config.alert (do not remove this comment)

-- Which alerts generate a force_more
BRC.Config.fm_alert = {
  early_weap = false, -- Good weapons found early
  upgrade_weap = false, -- Better DPS / weapon_score
  weap_ego = false, -- New or diff egos
  body_armour = false,
  shields = true,
  aux_armour = false,
  armour_ego = true, -- New or diff egos
  high_score_weap = false, -- Highest damage found
  high_score_armour = true, -- Highest AC found
  one_time_alerts = true,
  artefact = false, -- Any artefact
  trained_artefacts = true, -- Only for artefacts where you have corresponding skill > 0
  orbs = false,
  talismans = you.class() == "Shapeshifter", -- True for shapeshifter, false for everyone else
  staff_resists = false,
} -- BRC.Config.fm_alert (do not remove this comment)

-- Debugging
BRC.Config.show_debug_messages = false
BRC.Config.offer_debug_notes_on_char_dump = true -- Won't add to char dump unless told to
BRC.Config.debug_alert_monsters = BRC.Config.debug_alert_monsters or false -- Can also be turned on in feature config

---- Heuristics for tuning the pickup/alert system. Advanced behavior customization.
BRC.Tuning = {}

--[[
  BRC.Tuning.armour: Magic numbers for the armour pickup/alert system.
  For armour with different encumbrance, alert when ratio of gain/loss (AC|EV) is > value
  Lower values mean more alerts. gain/diff/same/lose refers to egos.
  min_gain/max_loss check against the AC or EV delta when ego changes; skip alerts if delta outside limits
  ignore_small: separate from AC/EV ratios, if absolute AC+EV loss is <= this, alert any gain/diff ego
--]]
BRC.Tuning.armour = {
  lighter = {
    gain_ego = 0.6,
    diff_ego = 0.8,
    same_ego = 1.2,
    lost_ego = 2.0,
    min_gain = 3.0,
    max_loss = 4.0,
    ignore_small = 3.5,
  },
  heavier = {
    gain_ego = 0.4,
    diff_ego = 0.5,
    same_ego = 0.7,
    lost_ego = 2.0,
    min_gain = 3.0,
    max_loss = 8.0,
    ignore_small = 5,
  },
  encumb_penalty_weight = 0.7, -- Penalizes heavier armour when training spellcasting/ranged. 0 to disable
  early_xl = 6, -- Alert all usable runed body armour if XL <= `early_xl`
} -- BRC.Tuning.armour (do not remove this comment)

--[[
  BRC.Tuning.weap: Magic numbers for the weapon pickup/alert system. Two common types of values:
    1. Cutoffs for pickup/alert weapons (when DPS ratio exceeds a value)
    2. Cutoffs for when alerts are active (XL, skill_level)
  Pickup/alert system will try to upgrade ANY weapon in your inventory.
  "DPS ratio" is (new_weapon_score / inventory_weapon_score). Score considers DPS, brand, and accuracy.
--]]
BRC.Tuning.weap = {}
BRC.Tuning.weap.pickup = {
  add_ego = 1.0, -- Pickup weapon that gains a brand if DPS ratio > `add_ego`
  same_type_melee = 1.2, -- Pickup melee weap of same school if DPS ratio > `same_type_melee`
  same_type_ranged = 1.1, -- Pickup ranged weap if DPS ratio > `same_type_ranged`
  accuracy_weight = 0.25, -- Treat +1 Accuracy as +`accuracy_weight` DPS
} -- BRC.Tuning.weap.pickup (do not remove this comment)

BRC.Tuning.weap.alert = {
  -- Alerts for weapons not requiring an extra hand
  pure_dps = 1.0, -- Alert if DPS ratio > `pure_dps`
  gain_ego = 0.8, -- Gaining ego; Alert if DPS ratio > `gain_ego`
  new_ego = 0.8, -- Get ego not in inventory; Alert if DPS ratio > `new_ego`
  low_skill_penalty_damping = 8, -- Increase to penalize low-trained schools. Penalty = (skill+damp) / (top_skill+damp)

  -- Alerts for 2-handed weapons, when carrying 1-handed
  add_hand = {
    ignore_sh_lvl = 4.0, -- Treat offhand as empty if shield_skill < `ignore_sh_lvl`
    add_ego_lose_sh = 0.8, -- Alert 1h -> 2h (using shield) if DPS ratio > `add_ego_lose_sh`
    not_using = 1.0, --  Alert 1h -> 2h (not using 2nd hand) if DPS ratio > `not_using`
  },

  -- Alerts for good early weapons of all types
  early = {
    xl = 7, -- Alert early weapons if XL <= `xl`
    skill = { factor = 1.5, offset = 2.0 }, -- Skip weapons with skill diff > XL * factor + offset
    branded_min_plus = 4, -- Alert branded weapons with plus >= `branded_min_plus`
  },

  -- Alerts for particularly strong ranged weapons
  early_ranged = {
    xl = 14, -- Alert strong ranged weapons if XL <= `xl`
    min_plus = 7, -- Alert ranged weapons with plus >= `min_plus`
    branded_min_plus = 4, -- Alert branded ranged weapons with plus >= `branded_min_plus`
    max_shields = 8.0, -- Alert 2h ranged, despite shield, if shield_skill <= `max_shields`
  }, -- BRC.Tuning.weap.alert.early_ranged (do not remove this comment)
} -- BRC.Tuning.weap.alert (do not remove this comment)

---- BRC.BrandBonus: Tune the impact of brands on DPS calculations
-- This applies to weapon inscriptions, and item comparisons in the pickup-alert system.
-- Uses "terse" ego names, e.g. "spect" instead of "spectralizing"
BRC.BrandBonus = {
  chaos = { factor = 1.15, offset = 2.0 }, -- Approximate weighted average
  distort = { factor = 1.0, offset = 6.0 },
  drain = { factor = 1.25, offset = 2.0 },
  elec = { factor = 1.0, offset = 4.5 }, -- technically 3.5 on avg; fudged up for AC pen
  flame = { factor = 1.25, offset = 0 },
  freeze = { factor = 1.25, offset = 0 },
  heavy = { factor = 1.8, offset = 0 }, -- Speed is accounted for elsewhere
  pain = { factor = 1.0, offset = you.skill("Necromancy") / 2 },
  spect = { factor = 1.7, offset = 0 }, -- Fudged down for increased incoming damage
  venom = { factor = 1.0, offset = 5.0 }, -- estimated 5 dmg per poisoning

  subtle = { -- Completely made up values in attempt to compare weapons fairly
    antimagic = { factor = 1.1, offset = 0 },
    holy = { factor = 1.15, offset = 0 },
    penet = { factor = 1.3, offset = 0 },
    protect = { factor = 1.15, offset = 0 },
    reap = { factor = 1.3, offset = 0 },
    vamp = { factor = 1.2, offset = 0 },
  }, -- BRC.BrandBonus.subtle (do not remove this comment)
} -- BRC.BrandBonus (do not remove this comment)

---- Cosmetic settings
BRC.AlertColor = {
  weapon = {
    desc = "magenta",
    item = "yellow",
    stats = "lightgrey",
  },
  body_arm = {
    desc = "lightblue",
    item = "lightcyan",
    stats = "lightgrey",
  },
  aux_arm = { desc = "lightblue", item = "yellow" },
  orb = { desc = "green", item = "lightgreen" },
  talisman = { desc = "green", item = "lightgreen" },
  misc = { desc = "brown", item = "white" },
} -- BRC.AlertColor (do not remove this comment)

BRC.LogColor = {
  error = "lightred",
  warning = "yellow",
  info = "lightgrey",
  debug = "lightblue",
} -- BRC.LogColor (do not remove this comment)

BRC.Emoji = {}
if BRC.Config.emojis then
  BRC.Emoji.RARE_ITEM = "ðŸ’Ž"
  BRC.Emoji.ORB = "ðŸ”®"
  BRC.Emoji.TALISMAN = "ðŸ§¬"

  BRC.Emoji.WEAPON = "âš”ï¸"
  BRC.Emoji.RANGED = "ðŸ¹"
  BRC.Emoji.POLEARM = "ðŸ”±"
  BRC.Emoji.TWO_HAND = "âœ‹ðŸ¤š"
  BRC.Emoji.CAUTION = "âš ï¸"

  BRC.Emoji.STAFF_RESISTANCE = "ðŸ”¥"

  BRC.Emoji.ACCURACY = "ðŸŽ¯"
  BRC.Emoji.STRONGER = "ðŸ’ª"
  BRC.Emoji.STRONGEST = "ðŸ’ªðŸ’ª"
  BRC.Emoji.EGO = "âœ¨"
  BRC.Emoji.LIGHTER = "â¬"
  BRC.Emoji.HEAVIER = "â«"
  BRC.Emoji.ARTEFACT = "ðŸ’ "

  BRC.Emoji.REMIND_ID = "ðŸŽ"
  BRC.Emoji.EXCLAMATION = "â—"
  BRC.Emoji.EXCLAMATION_2 = "â€¼ï¸"

  BRC.Emoji.HP_METER = { FULL = "â¤ï¸", PART = "â¤ï¸â€ðŸ©¹", EMPTY = "ðŸ¤" }
  BRC.Emoji.MP_METER = { FULL = "ðŸŸ¦", PART = "ðŸ”¹", EMPTY = "âž–" }

  BRC.Emoji.SUCCESS = "âœ…"
else
  BRC.Emoji.REMIND_ID = "<magenta>?</magenta>"
  BRC.Emoji.EXCLAMATION = "<magenta>!</magenta>"
  BRC.Emoji.EXCLAMATION_2 = "<lightmagenta>!!</lightmagenta>"

  BRC.Emoji.HP_METER = {
    BORDER = "<white>|</white>",
    FULL = "<lightgreen>+</lightgreen>",
    PART = "<lightgrey>+</lightgrey>",
    EMPTY = "<darkgrey>-</darkgrey>",
  } -- BRC.Emoji.HP_METER (do not remove this comment)

  BRC.Emoji.MP_METER = {
    BORDER = "<white>|</white>",
    FULL = "<lightblue>+</lightblue>",
    PART = "<lightgrey>+</lightgrey>",
    EMPTY = "<darkgrey>-</darkgrey>",
  } -- BRC.Emoji.MP_METER (do not remove this comment)
end

}
############################### End lua/core/config.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

####### Main options #######
easy_confirm = all
show_more = false
small_more = true
mouse_input = false
tile_web_mouse_control = false
default_manual_training = true
autofight_caught = true
rest_wait_both = true
rest_wait_ancestor = true

autofight_stop = 40
hp_warning = 20
item_stack_summary_minimum = 8
fail_severity_to_confirm = 4

sort_menus = true:equipped,art,ego,basename,identified,qualname,>qty
drop_filter += useless_item, forbidden
fire_order = silver javelin, javelin, silver boomerang, boomerang, curare-tipped dart, poisoned dart, dart, stone


####### Explore options #######
explore_delay = -1
travel_delay = -1
rest_delay = -1
view_delay = 100
show_travel_trail = true

explore_stop = altars,branches,portals,runed_doors,greedy_pickup_smart
explore_stop_pickup_ignore += scroll, potion, misc, wand, stone, dart, boomerang, javelin


### Mostly normal RC options ###

################################### Begin rc/autoinscribe.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
# See safe-consumables.lua for consumable inscriptions

ai := autoinscribe

# General
ai += of cold resistance:rC+
ai += of fire resistance:rF+
ai += of poison resistance:rPois
ai += of corrosion resistance:rCorr
ai += of invulnerability:rInv
ai += of magic regeneration:MRegen+
ai += of positive energy:rN+
ai += of regeneration:Regen+
ai += of resistance:rF+, rC+
ai += of willpower:Will+

# Armour
ai += fire dragon scale:rF++, rC-
ai += gold dragon scale:rC+, rF+, rPois
ai += ice dragon scale:rC++, rF-
ai += pearl dragon scale:rN+
ai += storm dragon scale:rElec
ai += swamp dragon scale:rPois
ai += quicksilver dragon scale:Will+
ai += shadow dragon scale:Stlth+
ai += (?<!moon) troll leather:Regen+


# Amulets
ai += amulet of faith:Faith, !P

# Rings
ai += ring of fire:rF+, rC-
ai += ring of flight:+Fly
ai += ring of ice:rC+, rF-
ai += ring of magical power:MP+9
ai += ring of protection from cold:rC+
ai += ring of protection from fire:rF+
ai += ring of resist corrosion:rCorr
ai += ring of see invisible:sInv
ai += ring of wizardry:Wiz+

# Staves
ai += staff of air:rElec
ai += staff of cold:rC+
ai += staff of death:rN+
ai += staff of fire:rF+
ai += staff of poison:rPois

############################### End rc/autoinscribe.rc ###############################
##########################################################################################

################################### Begin rc/autopickup.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
####### Autopickup exceptions #######
ae := autopickup_exceptions
ae ^= <potions? of attraction, <potions? of lignification, <potions? of mutation
ae ^= <scrolls? of immolation, <scrolls? of poison
ae ^= <missile, <misc
ae ^= >staff of.*, >useless_item

############################### End rc/autopickup.rc ###############################
##########################################################################################

################################### Begin rc/display.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
show_resist_percent = false
stat_colour = 3:red, 6:yellow

hp_colour = 100:green, 99:lightgrey, 75:yellow, 50:lightred, 25:red
mp_colour = 100:green, 99:lightgrey, 75:yellow, 50:lightred, 25:red

####### Menu Colors #######
# Set Alias & clear defaults
menu := menu_colour
menu =

## Item colours
$i_boring := darkgrey
$i_normal := lightgrey
$i_warning := red
$i_useful := lightblue
$i_heal := green
$i_emergency := lightcyan
$i_rare := yellow

# First, color uselessness everywhere
menu += $i_boring:(melded|useless_item)
menu += $i_warning:forbidden

# Overrides: pickup menu (Affects Cntl-F)
#   (why don't these work when they come after inventory overrides?)
menu += pickup:lightmagenta:artefact.*jewellery
menu += pickup:lightgreen:artefact.*weapon
menu += pickup:lightcyan:artefact.*armour
menu += pickup:yellow:artefact
menu += pickup:magenta:jewellery
menu += pickup:lightblue:(ego|(unidentified.*(glowing|runed|shiny|embroidered)))
menu += pickup:magenta:(wand|cui_rare|disjunction|throwing net)
menu += pickup:$i_normal:(missile|weapon|armour)
menu += brown:spellbook

# Overrides: inventory menu
menu += inventory:lightgreen:.*equipped.*(weapon|armour|jewellery)
menu += inventory:$i_boring:inert
menu += inventory:lightmagenta:artefact.*amulet
menu += inventory:magenta:amulet
menu += inventory:cyan:artefact
menu += inventory:white:ego
menu += inventory:$i_normal:(weapon|armour|jewellery)

# Overrides: use_item menu
menu += use_item:lightgreen:.*equipped.*(weapon|armour|jewellery)
menu += use_item:lightmagenta:artefact.*amulet
menu += use_item:magenta:amulet
menu += use_item:white:artefact
menu += use_item:lightgrey:ego
menu += use_item:$i_normal:(weapon|armour|jewellery)

## General settings; used for whatever isn't explicitly set above
# Artefact / Ego / Vanilla (For equipment)
menu += $i_emergency:artefact
menu += $i_useful:ego
menu += $i_normal:(weapon|armour|jewellery)

# Decks
menu += $i_emergency:deck of escape
menu += $i_useful:deck of summoning
menu += $i_warning:deck of destruction

# Misc
menu += blue:(talisman|bauble)
menu += lightmagenta:evoker

# Missiles
menu += $i_emergency:(cui_rare|disjunction|throwing net)
menu += $i_normal:missile

# Potions
menu += $i_emergency:potions? of (cancellation|haste|resistance)
menu += $i_heal:potions? of (ambrosia|curing|i_heal wounds|magic)
menu += $i_rare:potions? of experience
menu += $i_useful:potions? of (brilliance|enlightenment|invisibility|might)
menu += $i_warning:potions? of (attraction|berserk|lignification|mutation)

# Scrolls
menu += $i_normal:scrolls? of (amnesia|enchant|identify)
menu += $i_emergency:scrolls? of (blinking|butterflies|fear|fog|teleportation|summoning)
menu += $i_rare:scrolls? of (acquirement|brand)
menu += $i_useful:scrolls? of (revelation)
menu += $i_warning:scrolls? of (immolation|noise|poison|silence|torment|vulnerability)

# Wands
menu += $i_emergency:wand of digging
menu += $i_normal:wand of (flame|paralysis|charming|mindburst|polymorph)
menu += $i_useful:wand of (acid|iceblast|light|quicksilver|roots|warping)

# Weapons
menu += brown:staff of


####### Message Channels #######
# (Main changes are god, timed_portal, mutation, and several mute/boring)
$m_boring := darkgrey
$m_normal := lightgrey
$m_interesting := white
$m_interface := cyan
$m_info := blue
$m_attention := lightmagenta
$m_danger  := red
$m_warning := lightred
$m_alert := yellow
$m_gain := green
$m_restore := lightblue

channel.plain = $m_normal
channel.prompt = $m_interface
channel.god = $m_alert
channel.duration = $m_restore
channel.danger = $m_danger
channel.warning = $m_warning
channel.recovery = $m_gain
channel.talk = mute
channel.talk_visual = mute
channel.timed_portal = $m_alert
channel.sound = $m_normal
channel.intrinsic_gain = $m_gain
channel.mutation = $m_attention
channel.monster_spell = $m_interesting
channel.monster_enchant = $m_interesting
channel.monster_warning = $m_warning
channel.friend_spell = $m_boring
channel.friend_enchant = $m_boring
channel.friend_action = $m_boring
channel.monster_damage = mute
channel.monster_target = mute
channel.banishment = $m_alert
channel.equipment = $m_normal
channel.floor = $m_boring
channel.multiturn = $m_boring
channel.examine = $m_normal
channel.examine_filter = $m_boring
channel.diagnostic = $m_info
channel.error = $m_attention
channel.tutorial = $m_info
channel.orb = $m_attention
channel.hell_effect = $m_warning
channel.dgl_message = $m_attention

####### Message-specific colors
msc := message_colour

# Travel / Exploring
msc ^= $m_alert:You now have enough gold to buy 
msc ^= $m_alert:You have identified the last 
msc ^= $m_boring:You .*(open|close) the door
msc ^= $m_boring:You climb (upwards|downwards)
msc ^= $m_interesting:Done exploring
msc ^= $m_interesting:Found a faded altar
msc ^= $m_interesting:You disentangle yourself
msc ^= $m_warning:You are caught in .* web

# Combat
msc ^= $m_boring:does no damage
msc ^= $m_boring:No (reachable )?target in view
msc ^= $m_boring:struggles against the net
msc ^= $m_boring:You furiously retaliate
msc ^= $m_boring:You swing at nothing
msc ^= $m_interesting:flickers and vanishes
msc ^= $m_interesting:is touched by paradox
msc ^= $m_interesting:seems to slow down
msc ^= $m_interesting:Your unstable footing causes you to 
msc ^= $m_interesting:You become entangled in the net
msc ^= $m_interesting:You feel a bit more experienced
msc ^= $m_interesting:You .*miss something
msc ^= $m_interesting:You are blasted

# Equipment
msc ^= $m_boring:You unwield your 

# Bad things
msc ^= $m_danger: delaying your translocation

#############################################################################################################
####### MUTES Be careful with these! They come last and use ^= (prepend), to override everything else #######
# Replaced by fully-rest.lua
msc ^= mute:(Ancestor )?HP restored
msc ^= mute:Magic restored

# Unnecessary
msc ^= mute:You now have .* runes
msc ^= mute:to see all the runes you have collected
msc ^= mute:A chill wind blows around you
msc ^= mute:An electric hum fills the air

# Wielding weapons
msc ^= mute:Your .* exudes an aura of protection
msc ^= mute:Your .* glows with a cold blue light

# Monsters /Allies / Neutrals
msc ^= mute:evades? a web
msc ^= mute:is (lightly|moderately|heavily|severely) (damaged|wounded)
msc ^= mute:is almost (dead|destroyed)
msc ^= mute:The (bush|fungus|plant) (looks sick|begins to die|is engulfed|is struck)
msc ^= mute:dissolves into shadows
msc ^= mute:You swap places
msc ^= mute:Your spectral weapon disappears

# Interface
msc ^= mute:Use which ability\?
msc ^= mute:Evoke which item\?$
msc ^= mute:for a list of commands and other information
msc ^= mute:Marking area around
msc ^= mute:(Reduced|Removed|Placed new) exclusion
msc ^= mute:Shift\-Dir \- straight line
msc ^= mute:You can access your shopping list by pressing '\$'

# Books
msc ^= mute:You pick up (?!a manual).*and begin reading
msc ^= mute:Unfortunately\, you learn nothing new

# Spells
msc ^= mute:Your foxfire dissipates

# Religion
msc ^= mute:accepts your kill
msc ^= mute:is honoured by your kill
msc ^= mute:Your shadow attacks

# Ground items / features
msc ^= mute:There is a.*(door|gate|staircase|web).*here
msc ^= mute:You see here .*(corpse|skeleton)
msc ^= mute:You now have .* gold piece
msc ^= mute:You enter the shallow water
msc ^= mute:Moving in this stuff is going to be slow

############################### End rc/display.rc ###############################
##########################################################################################

################################### Begin rc/fm-messages.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
more := force_more_message
flash := flash_screen_message

# Remove annoying defaults
more -= You have reached level
more -= Marking area around .* as unsafe
more -= welcomes you( back)?!
more -= upon you is lifted
more -= You pick up the .* gem and feel its .* weight
more -= You pick up the .* rune and feel its power
more -= The lock glows eerily
more -= Heavy smoke blows from the lock
more -= The gate opens wide
more -= With a soft hiss the gate opens wide
more -= grants you (a gift|throwing weapons|a weapon)
more += grants you (a gift|a weapon)
more -= You finish merging with the rock

# Almost worth removing
#force_more_message -= You bow before the missionary of Beogh
#force_more_message -= You .* the altar of


# Significant spells/effects ending
flash += You feel stable
more += is no longer charmed
more += You.*re starting to lose your buoyancy
# Death's Door
more += time is.*running out
more += life is in your own
# Death channel
more += unholy channel is weakening

# Monsters doing things
more += monster_warning:wielding.*of distortion
more += begins to recite a word of recall
more += There is.*feeling in your soul
more += wretched star pulses
more += Strange energies course through your body

flash += doors? slams? shut
flash += blows.*on a signal horn
flash += Deactivating autopickup
flash += Its appearance distorts for a moment
flash += The.*offers itself to Yredelemnul
flash += The forest starts to sway and rumble
flash += Your?.*suddenly stops? moving

# Crowd control
more += You.*(?<!( too|less)) confused
more += You .*(slow.*down|lose consciousness)
more += infuriates you
more += hits you .* distortion
more += Space .* around you
more += surroundings become eerily quiet
more += Your limbs are stiffening

flash += You .* (blown|knocked back|mesmerised|trampled|stumble backwards|encased)
flash += Your magical (effects|defenses) are (unraveling|stripped away)
flash += You stop (a|de)scending the stairs
flash += A sentinel's mark forms upon you
flash += The pull of.*song draws you forward
flash += engulfs you in water

# Clouds
more += danger:(calcify|mutagenic)
more += You.*re engulfed in.*miasma
flash += Miasma billows from the

# You Screwed Up
more += is no longer ready
more += You really shouldn't be using
more += You don't have enough magic to cast this spell
flash += Your body shudders with the violent release
flash += power of Zot

# Found something important
flash += You pick up the .* (gem|rune) and feel its 
more += Found.*the Ecumenical Temple
more += Found.*(treasure|bazaar|ziggurat)
more += .*resides here
more += You have a vision of.*gates?
more += Press the corresponding letter to learn more about a god
flash += timed_portal:.*

# Translocations
more += danger:sense of stasis
more += Your surroundings.*(different|flicker)
more += You.*re suddenly pulled into a different region
flash += You blink
flash += danger:You feel strangely .*stable
flash += delaying your translocation

# Big damage
more += your body is wracked
more += The poison in your body grows stronger
more += You.*re lethally poisoned
more += danger:You convulse
more += You feel a (horrible|terrible) chill
more += Your.*terribly
more += You are.*terribly

# Hit by something
more += Terrible wounds open
more += The air around.*erupts in flames
more += The air twists around and violently strikes you in flight
more += You shudder from the earth-shattering force
more += You feel.*(?<!less)( haunted| rot| vulnerable)
flash += danger:corrodes you
flash += Your damage is reflected back at you
flash += ^(?!Your? ).*reflects

# FYI
more += seems mollified
more += You have finished your manual

# Unexpected monsters
more += appears in a (shower|flash)
more += appears out of thin air
more += You sense the presence of something unfriendly
more += Wisps of shadow swirl around

# Misc
more += hell effect:.*
more += god:wrath finds you
more += The walls disappear

# Ashenzari
more += god:Ashenzari invites you to partake
# Dithmenos
more += god:You are shrouded in an aura of darkness
more += god:You.*bleed smoke
more += god:Your shadow.*tangibly mimics your actions
# Fedhas
more += god:Fedhas invokes the elements against you
# Jivya
more += god:will now unseal the treasures of the Slime Pits
more += god:Jiyva alters your body
# Kikubaaqudgha
more += god:Kikubaaqudgha will grant you
# Lugonu
more += god:Lugonu will now corrupt your weapon
more += god:Lugonu sends minions to punish you
# Okawaru
more += god:Okawaru sends forces against you
# Qazlal
flash += god:resistances upon receiving elemental damage
flash += god:You are surrounded by a storm which can block enemy attacks
# The Shining One
more += god:Your divine shield starts to fade
more += god:Your divine shield fades away
# Trog
more += god:You feel the effects of Trog's Hand fading
more += god:You feel less resistant to hostile enchantments
# Xom
more += staircase.*moves
more += Some monsters swap places
# Yredelemnul
more += god:soul is no.* ripe for the taking
more += god:dark mirror aura disappears
# Zin
more += god:will now cure all your mutations

############################### End rc/fm-messages.rc ###############################
##########################################################################################

################################### Begin rc/macros.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
bindkey = [~] CMD_LUA_CONSOLE

# Numpad keymaps
macros += K \{-1019} f
macros += K \{-1018} 3
macros += K \{-1016} \{9}
macros += K \{-1015} 2
macros += K \{-1012} 1
macros += K \{-1010} o
macros += K \{-1000} .
macros += K \{-247} 5
macros += K2 \{-1019} .

# Spellcasting macros
macros += M 1 za
macros += M 2 zb
macros += M 3 zc
macros += M 4 zd
macros += M 6 zf
macros += M 7 zg
macros += M 8 zh
macros += M 9 zi
macros += M 0 zj

# Confirm targeting with same keys as spellcasting
macros += K2 \{-1018} \{13}
macros += K2 \{-1015} \{13}
macros += K2 \{-1012} \{13}
macros += K2 1 \{13}
macros += K2 2 \{13}
macros += K2 3 \{13}
macros += K2 4 \{13}
macros += K2 6 \{13}
macros += K2 7 \{13}
macros += K2 8 \{13}
macros += K2 9 \{13}
macros += K2 0 \{13}

############################### End rc/macros.rc ###############################
##########################################################################################

################################### Begin rc/runrest.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
# Aliases
stop := runrest_stop_message
ignore := runrest_ignore_message

# Ignore these stops
interrupt_travel -= sense_monster
interrupt_travel -= mimic
ignore ^= "sense a monster nearby"
ignore ^= recovery:.*
ignore ^= duration:.*

# Monsters to ignore at a distance
runrest_ignore_monster += fire vortex:1

# Stop for consumables you want to use immediately
stop += potions? of experience
stop += scrolls? of acquirement

# Don't stop for noisy doors unless someone shouts back
stop -= it creaks loudly
stop -= flies open with a bang
stop += You hear

# Ignore some stops for ally actions, then stop on the rest
ignore -= friend_action:
ignore -= friend_spell:
ignore -= friend_enchant:
ignore ^= butterfly disappears
ignore ^= friend_action:(a|the) web
ignore ^= friend_action:(seems|blinks)
stop += friend_action:
stop += friend_spell:
stop += friend_enchant:
stop += appears from out of your range of vision
stop += hits your
stop += our.*is destroyed

# Expiring effects; Turn on transmutation|flight|swiftness ending and ignore the rest
ignore -= transformation is almost over\.
ignore -= transformation has ended\.
ignore -= revert to.*form\.
ignore -= You feel yourself come back to life
ignore ^= unholy channel is weakening
ignore ^= magical contamination.*faded
ignore ^= our foxfire dissipates
stop ^= unholy channel expires
stop ^= are starting to lose your buoyancy
stop ^= You feel.*sluggish
# Expiring effects for friends too
stop ^= no longer petrified
ignore ^= no longer.*(covered in acid|unusually strong)
ignore ^= looks more healthy

# Misc
stop -= You now have enough gold to
stop ^= timed_portal:.*
ignore ^= nearby plant withers and dies
ignore ^= disentangle yourself
ignore ^= You swap places.

# Summonings
ignore ^= our.*crimson imp blinks
ignore ^= our.*simulacrum vaporises
ignore ^= our.*returns to the shadows of the Dungeon
ignore ^= our.*skeleton crumbles into dust
ignore ^= our.*fades into mist
ignore ^= our.*looks more healthy
ignore ^= our.*is no longer (corroded|moving slowly)
ignore ^= our.*dissolves into a puddle of slime

# Ashenzari
stop += god:Ashenzari invites you to partake
# Ru
stop += god:Ru believes you are ready to make a new sacrifice
# Hepliaklqana
ignore ^= emerges from the mists of memory
# Wu Jian Council
ignore += heavenly storm settles
# Yredelemnul
ignore += offer up the Black Torch's flame
ignore += mindless puppets stay behind to rot

############################### End rc/runrest.rc ###############################
##########################################################################################

################################### Begin rc/slot-defaults.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
####### Item Slots #########
# Rings to P/p for easy swapping
item_slot += ring of:Pp

# ignored: moonshine, noise
# unassigned slots: d, e, F
item_slot ^= scroll of acquirement:q
item_slot ^= scroll of amnesia:E
item_slot ^= scroll of blinking:B
item_slot ^= scroll of brand weapon:D
item_slot ^= scroll of butterflies:s
item_slot ^= scroll of enchant armour:u
item_slot ^= scroll of enchant weapon:W
item_slot ^= scroll of fear:f
item_slot ^= scroll of fog:F
item_slot ^= scroll of identify:i
item_slot ^= scroll of immolation:o
item_slot ^= scroll of revelation:j
item_slot ^= scroll of poison:y
item_slot ^= scroll of silence:S
item_slot ^= scroll of summoning:s
item_slot ^= scroll of teleportation:t
item_slot ^= scroll of torment:k
item_slot ^= scroll of vulnerability:v

item_slot ^= potion of ambrosia:A
item_slot ^= potion of attraction:n
item_slot ^= potion of berserk rage:z
item_slot ^= potion of brilliance:R
item_slot ^= potion of cancellation:C
item_slot ^= potion of curing:c
item_slot ^= potion of experience:x
item_slot ^= potion of enlightenment:g
item_slot ^= potion of haste:H
item_slot ^= potion of heal wounds:h
item_slot ^= potion of invisibility:I
item_slot ^= potion of lignification:l
item_slot ^= potion of magic:M
item_slot ^= potion of might:m
item_slot ^= potion of resistance:r
item_slot ^= potion of mutation:U

item_slot ^= condenser vane:V
item_slot ^= phial of floods:O
item_slot ^= phantom mirror:N
item_slot ^= box of beasts:X
item_slot ^= tin of tremorstones:T
item_slot ^= lightning rod:L

item_slot ^= wand of digging:K
item_slot ^= wand of flame:Q
item_slot ^= wand of mindburst:Y
item_slot ^= wand of acid:G
item_slot ^= wand of light:G
item_slot ^= wand of quicksilver:G
item_slot ^= wand of iceblast:Z
item_slot ^= wand of roots:Z
item_slot ^= wand of charming:J
item_slot ^= wand of paralysis:J



######## Spell Slots #########
spell_slot ^= Alistair's Intoxication:AITX
spell_slot ^= Alistairâ€™s Walking Alembic:AWKLMBSTEI
spell_slot ^= Anguish:ANGUISH
spell_slot ^= Animate Armour:ANMT
spell_slot ^= Animate Dead:ADNMT
spell_slot ^= Arcjolt:AJCOLT
spell_slot ^= Blink:BLNK
spell_slot ^= Borgnjor's Revivification:BRVF
spell_slot ^= Call Canine Familiar:CFN
spell_slot ^= Call Imp:ICMP
spell_slot ^= Cause Fear:CFSUR
spell_slot ^= Chain Lightning:LCHGNT
spell_slot ^= Cigotuvi's Dreadful Rot:CDRVT
spell_slot ^= Confusing Touch:CTF
spell_slot ^= Conjure Ball Lightning:BLCTN
spell_slot ^= Construct Spike Launcher:CSLPKNRAUE
spell_slot ^= Corpse Rot:CRPS
spell_slot ^= Death Channel:DCNL
spell_slot ^= Death's Door:DROTHEA
spell_slot ^= Detonation Catalyst:DCTNYTSAEO
spell_slot ^= Diamond Sawblades:DSWBLNIAO
spell_slot ^= Discord:DISCORD
spell_slot ^= Disjunction:DJNIS
spell_slot ^= Dispersal:DPLIS
spell_slot ^= Dragon's Call:DCRGN
spell_slot ^= Forge Monarch Bomb:FMBONRCHGEA
spell_slot ^= Forge Phalanx Beetle:FPBENXORG
spell_slot ^= Fortress Blast:FBRTSLA
spell_slot ^= Foxfire:FXOIRE
spell_slot ^= Fugue of the Fallen:FUGALNE
spell_slot ^= Fulsome Fusillade:FLSOMADE
spell_slot ^= Gloom:GLOM
spell_slot ^= Hoarfrost Cannonade:HCORFND
spell_slot ^= Ice Form:IFORM
spell_slot ^= Ignite Poison:IPOSN
spell_slot ^= Ignition:IGNTO
spell_slot ^= Infestation:INFESTAON
spell_slot ^= Irradiate:IRADTE
spell_slot ^= Iskenderun's Battlespehere:BSI
spell_slot ^= Iskenderun's Mystic Blast:IMB
spell_slot ^= Jinxbite:JNXBITE
spell_slot ^= Leda's Liquefaction:LQFND
spell_slot ^= Malign Gateway:MGWTN
spell_slot ^= Manifold Assault:MANFT
spell_slot ^= Martyr's Knell:MKNARTYEL
spell_slot ^= Maxwell's Capacitive Coupling:MCXW
spell_slot ^= Metabolic Englaciation:MENC
spell_slot ^= Monstrous Menagerie:MNGR
spell_slot ^= Nazjaâ€™s Percussive Tempering:NPTZJACUE
spell_slot ^= Olgreb's Toxic Radiance:TOR
spell_slot ^= Ozocubu's Armour:OAMR
spell_slot ^= Ozocubu's Refrigeration:ROZFG
spell_slot ^= Permafrost Eruption:PERUTFMAOSTIN
spell_slot ^= Platinum Paragon:PLTGNMAO
spell_slot ^= Polar Vortex:PVXT
spell_slot ^= Rending Blade:RBENDALG
spell_slot ^= Scorch:SCORH
spell_slot ^= Shatter:SHTR
spell_slot ^= Sigil of Binding:SBGILDNG
spell_slot ^= Silence:SICL
spell_slot ^= Spellspark Servitor:SVFR
spell_slot ^= Sphinx Sisters:SPHINXR
spell_slot ^= Starburst:SBUT
spell_slot ^= Static Discharge:DSCGT
spell_slot ^= Sublimation of Blood:SBLM
spell_slot ^= Summon Blazeheart Golem:SBGLZOM
spell_slot ^= Summon Cactus Giant:CGS
spell_slot ^= Summon Forest:FSRTM
spell_slot ^= Summon Horrible Things:HST
spell_slot ^= Summon Hydra:HYDRA
spell_slot ^= Summon Ice Beast:ISB
spell_slot ^= Summon Lightning Spire:SMLIRNG
spell_slot ^= Summon Mana Viper:MSV
spell_slot ^= Summon Seismosaurus Egg:EGSMIEOAU
spell_slot ^= Summon Small Mammal:SMLAUON
spell_slot ^= Swiftness:SWIFT
spell_slot ^= Volatile Blastmotes:VBOLMASTE
:if you.class() == "Summoner" then
  spell_slot ^= (summon|call):abcdefgh
:end

############################### End rc/slot-defaults.rc ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

### buehler.rc core files ###

################################### Begin lua/core/constants.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Constants - All constant definitions
Author: buehler
Dependencies: (none, but indirectly references core/constants.lua)
--]]

-- Initialize
BRC = BRC or {}

---- Items ----
BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine", "horn of Geryon",
  "lightning rod", "phantom mirror", "phial of floods", "sack of spiders", "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

-- This is checked against the full text of the pickup message, so use patterns to match
BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)

-- Could be removed after https://github.com/crawl/crawl/issues/4606 is addressed
BRC.SPELLBOOKS = {
  "parchment of", "book of", "Necronomicon", "Grand Grimoire", "tome of obsoleteness",
  "Everburning Encyclopedia", "Ozocubu's Autobiography", "Maxwell's Memoranda",
  "Young Poisoner's Handbook", "Fen Folio", "Inescapable Atlas", "There-And-Back Book",
  "Great Wizards, Vol. II", "Great Wizards, Vol. VII", "Trismegistus Codex",
  "the Unrestrained Analects", "Compendium of Siegecraft", "Codex of Conductivity",
  "Handbook of Applied Construction", "Treatise on Traps", "My Sojourn through Swampland",
  "Akashic Record",
  -- Include prefixes for randart books
  "Almanac", "Anthology", "Atlas", "Book", "Catalogue", "Codex", "Compendium",
  "Compilation", "Cyclopedia", "Directory", "Elucidation", "Encyclopedia", "Folio",
  "Grimoire", "Handbook", "Incunable", "Incunabulum", "Octavo", "Omnibus", "Papyrus",
  "Parchment", "Precepts", "Quarto", "Secrets", "Spellbook", "Tome", "Vellum", "Volume",
} -- BRC.SPELLBOOKS (do not remove this comment)

---- Races ----
BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant", }
BRC.NONLIVING_RACES = { "Djinni", "Gargoyle", }
BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant", }
BRC.LITTLE_RACES = { "Spriggan", }
BRC.SMALL_RACES = { "Kobold", }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll", }

---- Skills ----
BRC.STAFF_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", death = "Necromancy",
  earth = "Earth Magic", fire = "Fire Magic", conjuration = "Conjurations",
} -- BRC.STAFF_SCHOOLS (do not remove this comment)

BRC.TRAINING_SKILLS = {
  "Air Magic", "Alchemy", "Armour", "Axes", "Conjurations", "Dodging", "Earth Magic", "Evocations", "Fighting",
  "Fire Magic", "Forgecraft", "Hexes", "Ice Magic", "Invocations", "Long Blades", "Maces & Flails", "Necromancy",
  "Polearms", "Ranged Weapons", "Shapeshifting", "Shields", "Short Blades", "Spellcasting", "Staves", "Stealth",
  "Summonings", "Translocations", "Unarmed Combat", "Throwing",
} -- BRC.TRAINING_SKILLS (do not remove this comment)

BRC.WEAP_SCHOOLS = {
  "axes", "maces & flails", "polearms", "long blades", "short blades", "staves", "unarmed combat", "ranged weapons",
} -- BRC.WEAP_SCHOOLS (do not remove this comment)

---- Branches ----
BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar", }
BRC.PORTAL_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "Ice Cave", "Necropolis",
  "Ossuary", "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_NAMES (do not remove this comment)

---- Egos + artefact properties ----
BRC.BAD_ART_PROPS = { "Bane", "*Corrode", "*Noise", "*Rage", "*Silence", "*Slow", "*Tele", "-Cast", "-Move", "-Tele", }
BRC.RISKY_EGOS = { "antimagic", "chaos", "distort", "harm", "heavy", "Infuse", "Ponderous", }
BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect", }

---- Other ----
-- BRC.COLORS:Would prefer to use integer values, but they don't work in all menus
BRC.COLORS = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COLORS (do not remove this comment)

BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg with no associated damage type
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.KEYS = { LF = string.char(10), CR = string.char(13), }

BRC.MUTATIONS = {
  antennae = "antennae", augmentation = "augmentation", beak = "beak", claws = "claws", deformed = "deformed body",
  demonic_touch = "demonic touch", hooves = "hooves", horns = "horns", missing_hand = "missing a hand",
  pseudopods = "pseudopods", sharp_scales = "sharp scales", sturdy_frame = "sturdy frame", talons = "talons",
} -- BRC.MUTATIONS (do not remove this comment)

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2, }

}
############################### End lua/core/constants.lua ###############################
##########################################################################################

################################### Begin lua/core/data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC.data - Persistent data management module
Manages persistent data across games and saves
Author: buehler
Dependencies: (none)
--]]

-- Initialize
BRC = BRC or {}
BRC.data = {}

-- Local constants
local BRC_PREFIX = "brc_data_"
local TYPES = {
  string = "string",
  number = "number",
  boolean = "boolean",
  list = "list",
  dict = "dict",
  table = "table",
  unknown = "unknown",
} -- TYPES (do not remove this comment)

-- Values to detect when character is changed
local GAME_CHANGE_MONITORS = {}

-- Persistent variables - BRC.data defines these in init(), to come after all other persistent data

-- Private variables
local _persistent_var_names = {}
local _persistent_table_names = {}

-- Private functions (defined globally to allow access from chk_lua_save)
function BRC.data._brc_type_of(value)
  local t = type(value)
  if t == "table" then
    if #value > 0 then
      return TYPES.list
    else
      return TYPES.dict
    end
  elseif t == "string" then
    return TYPES.string
  elseif t == "number" then
    return TYPES.number
  elseif t == "boolean" then
    return TYPES.boolean
  else
    return TYPES.unknown
  end
end

function BRC.data.val2str(value, indent_count)
  if not value then return "nil" end
  indent_count = indent_count or 1
  local indent = string.rep("  ", indent_count)
  local parent_indent = string.rep("  ", indent_count - 1)
  local list_separator = ",\n" .. indent

  local type = BRC.data._brc_type_of(value)
  if type == TYPES.string then
    return string.format('"%s"', value:gsub('"', ""))
  elseif type == TYPES.number then
    return tostring(value)
  elseif type == TYPES.boolean then
    return tostring(value)
  elseif type == TYPES.list then
    local tokens = {}
    for _, v in ipairs(value) do
      tokens[#tokens + 1] = BRC.data.val2str(v, indent_count + 1)
    end
    if #tokens == 0 then return "{}" end
    if #tokens < 4 then return string.format("{ %s }", table.concat(tokens, ", ")) end
    return string.format("{\n%s%s\n%s}", indent, table.concat(tokens, list_separator), parent_indent)
  elseif type == TYPES.dict then
    local tokens = {}
    for k, v in pairs(value) do
      tokens[#tokens + 1] = string.format('["%s"] = %s', k, BRC.data.val2str(v, indent_count + 1))
    end
    if #tokens == 0 then return "{}" end
    return string.format("{\n%s%s\n%s}", indent, table.concat(tokens, list_separator), parent_indent)
  else
    local str = tostring(value) or "nil"
    BRC.log.error(string.format("Unknown data type for value (%s): %s", str, type))
    return "nil"
  end
end

-- Public API

--[[
BRC.data.persist() Creates a persistent global variable or table, initialized to the default value if it doesn't exist.
The variable/list/dict is automatically persisted across saves.
Returns the current value.
Usage: variable_name = BRC.data.persist("variable_name", default_value)
--]]
function BRC.data.persist(name, default_value)
  -- Reset persistent data on new game, or if not created yet
  if you.turns() == 0 or _G[name] == nil then _G[name] = default_value end
  local is_in_tables = util.contains(util.keys(_persistent_table_names), name)
  local is_in_vars = util.contains(_persistent_var_names, name)

  if not is_in_tables and not is_in_vars then
    table.insert(chk_lua_save, function()
      local var_type = BRC.data._brc_type_of(_G[name])
      if var_type == TYPES.unknown then return "" end
      return string.format("%s = %s%s", name, BRC.data.val2str(_G[name]), BRC.KEYS.LF)
    end)
  end

  local var_type = BRC.data._brc_type_of(_G[name])
  if var_type == TYPES.list or var_type == TYPES.dict then
    if not is_in_tables then _persistent_table_names[#_persistent_table_names + 1] = name end
  else
    if not is_in_vars then _persistent_var_names[#_persistent_var_names + 1] = name end
  end

  return _G[name]
end

function BRC.data.serialize()
  local tokens = { "\n---PERSISTENT TABLES---\n" }
  for _, name in ipairs(_persistent_table_names) do
    tokens[#tokens + 1] = string.format("%s = %s\n\n", name, BRC.data.val2str(_G[name]))
  end

  tokens[#tokens + 1] = "\n---PERSISTENT VARIABLES---\n"
  for _, name in ipairs(_persistent_var_names) do
    tokens[#tokens + 1] = string.format("%s = %s\n", name, BRC.data.val2str(_G[name]))
  end

  return table.concat(tokens)
end

function BRC.data.erase()
  if _persistent_var_names then
    for _, name in ipairs(_persistent_var_names) do
      _G[name] = nil
    end
  end

  if _persistent_table_names then
    for _, name in ipairs(_persistent_table_names) do
      _G[name] = nil
    end
  end

  _persistent_var_names = {}
  _persistent_table_names = {}
  BRC.active = false
  BRC.log.warning("Erased all persistent data and disabled BRC. Restart crawl to reload defaults.")
end

--[[
BRC.data.verify_reinit() Verifies data reinitialization and game state consistency
This should be called after all features have run init() to declare their data
--]]
function BRC.data.verify_reinit()
  local failed_reinit = false
  if you.turns() > 0 then
    for k, v in pairs(GAME_CHANGE_MONITORS) do
      local prev = _G[BRC_PREFIX .. k]
      if prev ~= v then
        failed_reinit = true
        local msg = string.format("Unexpected change to %s: %s -> %s", k, prev, v)
        _G[BRC_PREFIX .. k] = v
        BRC.mpr.lightred(msg)
      end
    end

    if not _G[BRC_PREFIX .. "successful_reload"] then
      failed_reinit = true
      BRC.log.error(string.format("Persistent data not loaded for buehler.rc v%s!", BRC.VERSION))
      BRC.mpr.darkgrey("Try restarting, or set BRC.Config.show_debug_messages=True for more info.")
    end
  end

  for k, v in pairs(GAME_CHANGE_MONITORS) do
    local var_name = BRC_PREFIX .. k
    _G[var_name] = BRC.data.persist(var_name, v)
  end
  _G[BRC_PREFIX .. "successful_reload"] = true

  if failed_reinit and BRC.mpr.yesno("Deactivate buehler.rc?", BRC.COLORS.yellow) then return false end
  return true
end

function BRC.data.init()
  GAME_CHANGE_MONITORS.buehler_rc_version = BRC.VERSION
  GAME_CHANGE_MONITORS.buehler_name = you.name()
  GAME_CHANGE_MONITORS.buehler_race = you.race()
  GAME_CHANGE_MONITORS.buehler_class = you.class()

  -- If monitors already are defined, they will keep their values
  for k, v in pairs(GAME_CHANGE_MONITORS) do
    BRC.data.persist(BRC_PREFIX .. k, v)
  end

  -- brc_data_successful_reload comes last, defaults to false. If true, confirms all data reloaded.
  BRC.data.persist(BRC_PREFIX .. "successful_reload", false)
  return BRC.data.verify_reinit()
end

}
############################### End lua/core/data.lua ###############################
##########################################################################################

################################### Begin lua/core/util.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Utility Functions - All utility functions organized into logical tables
Author: buehler
Dependencies: (none)
--]]

-- Initialize
BRC = BRC or {}
BRC.log = {}
BRC.text = {}
BRC.mpr = {}
BRC.get = {}
BRC.is = {}
BRC.you = {}
BRC.set = {}
BRC.util = {}
BRC.dump = {}

-- Local variables
local _mpr_queue = {}

-- Local constants
local SPECIAL_CHARS = table.concat({ "(", "[", "%", "^", "$", "(", ")", "%", ".", "[", "]", "*", "+", "-", "?", ")" })

-- Local functions
local function log_message(message, context, color)
  color = color or BRC.LogColor.info
  local msg = string.format("[BRC] %s", tostring(message))
  if context then msg = string.format("%s (%s)", msg, context) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

local function serialize_chk_lua_save()
  local tokens = { "\n---CHK_LUA_SAVE---" }
  for _, func in ipairs(chk_lua_save) do
    tokens[#tokens + 1] = util.trim(func())
  end

  return table.concat(tokens, "\n")
end

local function serialize_inventory()
  local tokens = { "\n---INVENTORY---\n" }
  for inv in iter.invent_iterator:new(items.inventory()) do
    tokens[#tokens + 1] = string.format("%s: (%s) Qual: %s", inv.slot, inv.quantity, inv.name("qual"))
    local base = inv.name("base") or "N/A"
    local cls = inv.class(true) or "N/A"
    local st = inv.subtype() or "N/A"
    tokens[#tokens + 1] = string.format("  Base: %s Class: %s, Subtype: %s\n", base, cls, st)
  end

  return table.concat(tokens)
end

local function serialize_config()
  local tokens = { "\n---CONFIG---\n" }
  tokens[#tokens + 1] = "\nConfig = " .. BRC.data.val2str(BRC.Config)
  tokens[#tokens + 1] = "\n\nTuning = " .. BRC.data.val2str(BRC.Tuning)
  tokens[#tokens + 1] = "\n\nBrandBonus = " .. BRC.data.val2str(BRC.BrandBonus)
  tokens[#tokens + 1] = "\n\nAlertColor = " .. BRC.data.val2str(BRC.AlertColor)
  tokens[#tokens + 1] = "\n\nLogColor = " .. BRC.data.val2str(BRC.LogColor)
  tokens[#tokens + 1] = "\n\nEmoji = " .. BRC.data.val2str(BRC.Emoji)
  return table.concat(tokens)
end

-- BRC.log - Logging methods
function BRC.log.error(message, context)
  log_message(message, context, BRC.LogColor.error)
end

function BRC.log.warning(message, context)
  log_message(message, context, BRC.LogColor.warning)
end

function BRC.log.info(message, context)
  log_message(message, context, BRC.LogColor.info)
end

function BRC.log.debug(message, context)
  if not BRC.Config.show_debug_messages then return end
  log_message(message, context, BRC.LogColor.debug)
end

---- BRC.text - Utility functions ----

-- Remove tags from text, and optionally escape special characters
function BRC.text.clean_text(text, escape_chars)
  text = text:gsub("\n", "")
  if escape_chars then text = text:gsub(SPECIAL_CHARS, "%%%1") end
  return text:gsub("<[^>]*>", "")
end

-- Wrap text in a color tag, Usage: BRC.text.blue("Hello"), or BRC.text["1"]("Hello")
for k, v in pairs(BRC.COLORS) do
  BRC.text[k] = function(text)
    return string.format("<%s>%s</%s>", v, tostring(text), v)
  end
  BRC.text[v] = BRC.text[k]
end

function BRC.text.color(color, text)
  return color and BRC.text[color](text) or tostring(text)
end

function BRC.text.get_pickup_info(text)
  local cleaned = BRC.text.clean_text(text, false)
  if cleaned:sub(2, 4) ~= " - " then return nil end
  return { slot = items.letter_to_index(cleaned:sub(1, 1)), item = cleaned:sub(5, #cleaned) }
end

--- BRC.mpr - Wrappers around crawl.mpr ---
-- Create a wrapper for each color. Usage: BRC.mpr.lightgreen("Hello"), or BRC.mpr["red"]("Hello")
for k, v in pairs(BRC.COLORS) do
  BRC.mpr[k] = function(text, channel)
    crawl.mpr(BRC.text.color(v, text), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.color(text, color, channel)
  if color then
    BRC.mpr[color](text, channel)
  else
    crawl.mpr(tostring(text), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.okay(suffix)
  BRC.mpr.darkgrey("Okay, then." .. (suffix and " " .. suffix or ""))
end

-- Message and stop travel/activity
function BRC.mpr.stop(text, color, channel)
  BRC.mpr.color(text, color, channel)
  you.stop_activity()
end

-- Message and a more prompt
function BRC.mpr.more(text, color, channel)
  BRC.mpr.color(text, color, channel)
  you.stop_activity()
  crawl.more()
  crawl.redraw_screen()
end

-- Conditionally display a more prompt
function BRC.mpr.optmore(show_more, text, color, channel)
  if show_more then
    BRC.mpr.more(text, color, channel)
  else
    BRC.mpr.color(text, color, channel)
  end
end

-- Queue a message, to dispay at start of next turn
function BRC.mpr.que(text, color, channel)
  for _, msg in ipairs(_mpr_queue) do
    if msg.text == text and msg.channel == channel then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { text = BRC.text.color(color, text), channel = channel, show_more = false }
end

-- Queue msg w/ conditional force-more prompt
function BRC.mpr.que_optmore(show_more, text, color, channel)
  for _, msg in ipairs(_mpr_queue) do
    if msg.text == text and msg.channel == channel and msg.show_more == show_more then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { text = BRC.text.color(color, text), channel = channel, show_more = show_more }
end

-- Display and consume the message queue
function BRC.mpr.consume_queue()
  local do_more = false
  for _, msg in ipairs(_mpr_queue) do
    crawl.mpr(tostring(msg.text), msg.channel)
    crawl.flush_prev_message()
    if msg.show_more then do_more = true end
  end

  if do_more then
    you.stop_activity()
    crawl.redraw_screen()
    crawl.more()
    crawl.redraw_screen()
  end

  _mpr_queue = {}
end

-- Get a yes/no response
function BRC.mpr.yesno(text, color, capital_only)
  local msg = string.format("%s (%s)", text, capital_only and "Y/N" or "y/n")
  local MAX_TRIES = 10

  for i = 1, MAX_TRIES do
    crawl.formatted_mpr(BRC.text.color(color, msg), "prompt")
    local res = crawl.getch()
    if res and res >= 0 and res <= 255 then
      if string.char(res) == "Y" or string.char(res) == "y" and not capital_only then return true end
      if string.char(res) == "N" or string.char(res) == "n" and not capital_only then return false end
    end
    if i == 1 and capital_only then msg = "[CAPS ONLY] " .. msg end
  end

  BRC.mpr.lightmagenta("Feels like a no.")
  return false
end

---- BRC.get - Functions to get non-boolean data ----

function BRC.get.command_key(cmd)
  local key = crawl.get_command(cmd)
  if not key then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  if key:find("Ctrl", 1, true) then return BRC.util.control_key(char_key) end
  return char_key
end

--[[
BRC.get.equipped_aux() - Returns 2 values:
  1. A list of equipped items of the type
  2. the num_slots (ie maximum size the list can ever be). This is usually a list of length 1, with num_slots==1.
  Poltergeists will get all worn aux armours and num_slots=6.
The length of the list <= num_slots.
--]]
function BRC.get.equipped_aux(aux_type)
  local all_aux = {}
  local num_slots = you.race() == "Poltergeist" and 6 or 1
  if aux_type == "gloves" and you.race() == "Formicid" then num_slots = 2 end
  for i = 1, num_slots do
    local it = items.equipped_at(aux_type, i)
    all_aux[#all_aux + 1] = it
  end
  return all_aux, num_slots
end

function BRC.get.mut(mutation, include_all)
  return you.get_base_mutation_level(mutation, true, include_all, include_all)
end

function BRC.get.skill(skill)
  if not skill:find(",", 1, true) then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local sum = 0
  local count = 0
  for _, s in ipairs(skills) do
    sum = sum + you.skill(s)
    count = count + 1
  end
  return sum / count
end

function BRC.get.skill_with(it)
  if BRC.is.magic_staff(it) then return math.max(BRC.get.skill(BRC.get.staff_school(it)), BRC.get.skill("Staves")) end
  if it.is_weapon then return BRC.get.skill(it.weap_skill) end
  if BRC.is.body_armour(it) then return BRC.get.skill("Armour") end
  if BRC.is.shield(it) then return BRC.get.skill("Shields") end
  if BRC.is.talisman(it) then return BRC.get.skill("Shapeshifting") end

  return 1 -- Fallback to 1
end

function BRC.get.staff_school(it)
  for k, v in pairs(BRC.STAFF_SCHOOLS) do
    if it.subtype() == k then return v end
  end
end

function BRC.get.talisman_min_level(it)
  -- Parse the item description
  local tokens = crawl.split(it.description, "\n")
  for _, v in ipairs(tokens) do
    if v:sub(1, 4) == "Min " then
      local start_pos = v:find("%d", 4)
      if start_pos then
        local end_pos = v:find("[^%d]", start_pos)
        return tonumber(v:sub(start_pos, end_pos - 1))
      end
    end
  end

  return 0 -- Fallback to 0, to surface any errors. Applies to Protean Talisman.
end

---- BRC.is - Boolean type checks of items ----

function BRC.is.amulet(it)
  return it and it.name("base") == "amulet"
end

function BRC.is.armour(it, include_orbs)
  -- exclude orbs by default
  if not it or it.class(true) ~= "armour" then return false end
  if not include_orbs and BRC.is.orb(it) then return false end
  return true
end

function BRC.is.aux_armour(it)
  return BRC.is.armour(it) and not (BRC.is.body_armour(it) or BRC.is.shield(it))
end

function BRC.is.body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.is.jewellery(it)
  return it and it.class(true) == "jewellery"
end

function BRC.is.magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

function BRC.is.ring(it)
  return it and it.name("base") == "ring"
end

function BRC.is.scarf(it)
  return it and it.class(true) == "armour" and it.subtype() == "cloak" and it.name():find("scarf", 1, true)
end

function BRC.is.shield(it)
  return it and it.is_shield()
end

function BRC.is.talisman(it)
  if not it then return false end
  local c = it.class(true)
  return c and (c == "talisman" or c == "bauble")
end

function BRC.is.orb(it)
  return it and it.class(true) == "armour" and it.subtype() == "offhand" and not it.is_shield()
end

function BRC.is.polearm(it)
  return it and it.weap_skill:find("Polearms", 1, true)
end

---- BRC.you - Boolean attributes of the character ----

function BRC.you.free_offhand()
  if BRC.get.mut(BRC.MUTATIONS.missing_hand, true) > 0 then return true end
  return not items.equipped_at("offhand")
end

function BRC.you.have_shield()
  return BRC.is.shield(items.equipped_at("offhand"))
end

function BRC.you.in_hell(exclude_vestibule)
  local branch = you.branch()
  if exclude_vestibule and branch == "Hell" then return false end
  return util.contains(BRC.HELL_BRANCHES, branch)
end

function BRC.you.by_slimy_wall()
  for x = -1, 1 do
    for y = -1, 1 do
      if view.feature_at(x, y) == "slimy_wall" then return true end
    end
  end
  return false
end

function BRC.you.miasma_immune()
  if util.contains(BRC.UNDEAD_RACES, you.race()) then return true end
  if util.contains(BRC.NONLIVING_RACES, you.race()) then return true end
  return false
end

function BRC.you.mutation_immune()
  return util.contains(BRC.UNDEAD_RACES, you.race())
end

function BRC.you.zero_stat()
  return you.strength() <= 0 or you.dexterity() <= 0 or you.intelligence() <= 0
end

---- BRC.set - Simple helper functions wrapping crawl.setopt() ----
function BRC.set.autopickup_exceptions(pattern, add_pattern)
  local op = add_pattern and "^=" or "-="
  crawl.setopt(string.format("autopickup_exceptions %s %s", op, pattern))
end

function BRC.set.explore_stop(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop %s %s", op, pattern))
end

function BRC.set.explore_stop_pickup_ignore(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop_pickup_ignore %s %s", op, pattern))
end

function BRC.set.flash_screen_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("flash_screen_message %s %s", op, pattern))
end

function BRC.set.force_more_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("force_more_message %s %s", op, pattern))
end

-- Sets a macro. Function must be global and not a member of a module.
function BRC.set.macro(key, function_name)
  BRC.log.debug(string.format(
    "Assigning macro: %s to key: %s",
    BRC.text.magenta(function_name.."()"),
    BRC.text.lightred("<<< '" .. key .. "' >>")
  ))
  crawl.setopt(string.format("macros += M %s ===%s", key, function_name))
end

function BRC.set.message_mute(pattern, mute_pattern)
  local op = mute_pattern and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.set.runrest_ignore_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_ignore_message %s %s", op, pattern))
end

function BRC.set.runrest_stop_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_stop_message %s %s", op, pattern))
end

--- BRC.dump - Debugging utils called from in-game lua interpreter ---

function BRC.dump.all(verbose, skip_mpr)
  local tokens = {}

  tokens[#tokens + 1] = BRC.data.serialize()
  if verbose then
    tokens[#tokens + 1] = serialize_config()
    tokens[#tokens + 1] = serialize_inventory()
    tokens[#tokens + 1] = _weapon_cache.serialize()
    tokens[#tokens + 1] = serialize_chk_lua_save()
  end

  local text = table.concat(tokens, "\n")
  if not skip_mpr then BRC.mpr.white(text) end

  return text
end

function BRC.dump.char(add_debug_info)
  if add_debug_info then
    crawl.take_note(BRC.dump.all(true, true))
    BRC.mpr.lightgrey("BRC debug info added to character dump.")
  else
    BRC.mpr.darkgrey("No debug info added.")
  end
  BRC.util.do_cmd("CMD_CHARACTER_DUMP")
end

function macro_brc_dump_character()
  if not BRC.active then BRC.util.do_cmd("CMD_CHARACTER_DUMP") end
  BRC.dump.char(BRC.mpr.yesno("Add BRC debug info to character dump?", BRC.COLORS.lightcyan))
end

--- BRC.util - Utility functions ----
-- BRC.util.do_cmd(): Tries via keypress first, fallback to crawl.do_commands()
-- crawl.do_commands() isn't always immediate; might wait for a keypress before doing the command
function BRC.util.control_key(c)
  return string.byte(c:upper()) - 64
end

function BRC.util.do_cmd(cmd)
  local key = BRC.get.command_key(cmd)
  if key then
    crawl.sendkeys({ key })
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.int2char(num)
  return string.char(string.byte("a") + num)
end

--[[
The functions above are general purpose: They should apply to any crawl RC file.
The functions below contain design choices or logic that are somewhat specific to BRC.
Examples: Weapon DPS calculation, treating dragon scales as branded, or defining what a "risky item" is.
--]]

-- Local functions; Often mirroring calculations that live in crawl.
-- Each mirrored function is commented with the last dcss version it was compared against.

local function format_dmg(dmg)
  -- Always return a string of length 4
  if dmg < 10 then return string.format("%.2f", dmg) end
  if dmg > 99.9 then return ">100" end
  return string.format("%.1f", dmg)
end

local function format_stat(abbr, val, is_worn)
  local stat_str = string.format("%.1f", val)
  if val < 0 then
    return string.format("%s%s", abbr, stat_str)
  elseif is_worn then
    return string.format("%s:%s", abbr, stat_str)
  else
    return string.format("%s+%s", abbr, stat_str)
  end
end

local function get_size_penalty()
  if util.contains(BRC.LITTLE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LITTLE
  elseif util.contains(BRC.SMALL_RACES, you.race()) then
    return BRC.SIZE_PENALTY.SMALL
  elseif util.contains(BRC.LARGE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LARGE
  end
  return BRC.SIZE_PENALTY.NORMAL
end

local function get_unadjusted_armour_pen(encumb)
  -- dcss v0.33.1
  local pen = encumb - 2 * BRC.get.mut(BRC.MUTATIONS.sturdy_frame, true)
  if pen > 0 then return pen end
  return 0
end

local function get_adjusted_armour_pen(encumb, str)
  -- dcss v0.33.1
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_adjusted_dodge_bonus(encumb, str, dex)
  -- dcss v0.33.1
  local size_factor = -2 * get_size_penalty()
  local dodge_bonus = 8 * (10 + you.skill("Dodging") * dex) / (20 - size_factor) / 10
  local armour_dodge_penalty = get_unadjusted_armour_pen(encumb) - 3
  if armour_dodge_penalty <= 0 then return dodge_bonus end

  if armour_dodge_penalty >= str then return dodge_bonus * str / (armour_dodge_penalty * 2) end
  return dodge_bonus - dodge_bonus * armour_dodge_penalty / (str * 2)
end

local function get_shield_penalty(sh)
  -- dcss v0.33.1
  return 2 * sh.encumbrance * sh.encumbrance * (27 - you.skill("Shields")) / 27 / (25 + 5 * you.strength())
end

local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_weap_min_delay(it)
  -- dcss v0.33.1
  -- This is an abbreviated version of the actual calculation.
  -- Skips brand and >=3 checks, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):find("woodcutter's axe", 1, true) then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:find("crossbow", 1, true) or basename:find("arbalest", 1, true)
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

local function get_weap_delay(it)
  -- dcss v0.33.1
  local delay = it.delay - BRC.get.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.get.ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.is.shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

local function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaict
  for i = 0, 20 do
    local inv = items.equipped_at(i)
    if inv then
      if BRC.is.ring(inv) then
        if inv.artefact then
          local name = inv.name()
          local idx = name:find("Slay", 1, true)
          if idx then
            local slay = tonumber(name:sub(idx + 5, idx + 5))
            if slay == 1 then
              local next_digit = tonumber(name:sub(idx + 6, idx + 6))
              if next_digit then slay = 10 + next_digit end
            end

            if name:sub(idx + 4, idx + 4) == "+" then
              sum = sum + slay
            else
              sum = sum - slay
            end
          end
        elseif BRC.get.ego(inv) == "Slay" then
          sum = sum + inv.plus
        end
      elseif inv.artefact and (BRC.is.armour(inv, true) or BRC.is.amulet(inv)) then
        local slay = inv.artprops["Slay"]
        if slay then sum = sum + slay end
      end
    end
  end

  if you.race() == "Demonspawn" then
    sum = sum + 3 * BRC.get.mut(BRC.MUTATIONS.augmentation, true)
    sum = sum + BRC.get.mut(BRC.MUTATIONS.sharp_scales, true)
  end

  return sum
end

local function get_staff_bonus_dmg(it, dmg_type)
  -- dcss v0.33.1
  if dmg_type == BRC.DMG_TYPE.unbranded then return 0 end
  if dmg_type == BRC.DMG_TYPE.plain then
    local basename = it.name("base")
    if basename ~= "staff of earth" and basename ~= "staff of conjuration" then return 0 end
  end

  local spell_skill = BRC.get.skill(BRC.get.staff_school(it))
  local evo_skill = you.skill("Evocations")

  local chance = (2 * evo_skill + spell_skill) / 30
  if chance > 1 then chance = 1 end
  -- 0.75 is an acceptable approximation; most commonly 63/80
  -- Varies by staff type in sometimes complex ways
  local avg_dmg = 3 / 4 * (evo_skill / 2 + spell_skill)
  return avg_dmg * chance
end

-- Formatting for stat inscriptions & alerts
function BRC.get.armour_stats(it)
  if not BRC.is.armour(it) then return "", "" end

  local cur = items.equipped_at(it.equip_type)
  local is_worn = it.equipped or (it.ininventory and cur and cur.slot == it.slot)
  local cur_ac = 0
  local cur_sh = 0
  local cur_ev = 0
  -- Never show deltas for poltergeist
  if cur and not is_worn and you.race() ~= "Poltergeist" then
    -- Show deltas if not worn, else compare against 0
    if BRC.is.shield(cur) then
      cur_sh = BRC.get.shield_sh(cur)
      cur_ev = -get_shield_penalty(cur)
    else
      cur_ac = BRC.get.armour_ac(cur)
      cur_ev = BRC.get.armour_ev(cur)
    end
  end

  if BRC.is.shield(it) then
    local sh_str = format_stat("SH", BRC.get.shield_sh(it) - cur_sh, is_worn)
    local ev_str = format_stat("EV", -get_shield_penalty(it) - cur_ev, is_worn)
    return sh_str, ev_str
  else
    local ac_str = format_stat("AC", BRC.get.armour_ac(it) - cur_ac, is_worn)
    if not BRC.is.body_armour(it) then return ac_str end
    local ev_str = format_stat("EV", BRC.get.armour_ev(it) - cur_ev, is_worn)
    return ac_str, ev_str
  end
end

function BRC.get.weapon_stats(it, dmg_type)
  if not it.is_weapon then return end
  dmg_type = dmg_type or BRC.DMG_TYPE[BRC.Config.inscribe_dps_type] or BRC.DMG_TYPE.plain
  local dmg = format_dmg(BRC.get.weap_damage(it, dmg_type))
  local delay = get_weap_delay(it)
  local delay_str = string.format("%.1f", delay)
  if delay < 1 then
    delay_str = string.format("%.2f", delay)
    delay_str = delay_str:sub(2, #delay_str)
  end

  local dps = format_dmg(dmg / delay)
  local acc = it.accuracy + (it.plus or 0)
  if acc >= 0 then acc = string.format("+%s", acc) end

  --TODO: This would be nice if it worked in all UIs
  --return string.format("DPS:<w>%s</w> (%s/%s), Acc<w>%s</w>", dps, dmg, delay_str, acc)
  return string.format("DPS: %s (%s/%s), Acc%s", dps, dmg, delay_str, acc)
end

-- BRC.get.ego() - Weapon + Armour egos, with custom logic:
-- Treats unusable egos as no ego. Consistently lowercases non-artefacts.
-- Includes: artefacts, armours with innate egos (except steam dragon scales)
-- If an artefact has a normal brand, it returns just that. (ie a return value of "flame" could be an artefact or not)
function BRC.get.ego(it, exclude_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    if BRC.is.unusable_ego(ego) or (exclude_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.is.body_armour(it) then
    local qualname = it.name("qual")
    if qualname:find("dragon scales", 1, true) and not qualname:find("steam", 1, true)
      or qualname:find("troll leather", 1, true) then
        return qualname
    end
  end

  return it.artefact and it.name() or nil
end

function BRC.get.hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  local st = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end

function BRC.get.items_in_slot(slot)
  local inv_items = {}
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.slot == slot then inv_items[#inv_items + 1] = inv end
  end
  return inv_items
end

function BRC.is.risky_item(it)
  if it.artefact then
    for k, v in pairs(it.artprops) do
      if util.contains(BRC.BAD_ART_PROPS, k) or v < 0 then return true end
    end
  end

  local ego_name = BRC.get.ego(it)
  return ego_name and util.contains(BRC.RISKY_EGOS, ego_name)
end

function BRC.is.unusable_ego(ego)
  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
    or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
    or ego == "pain" and you.skill("Necromancy") == 0
end

-- Armour stats
function BRC.get.armour_ac(it)
  -- dcss v0.33.1
  local it_plus = it.plus or 0

  if it.artefact and it.is_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end

  local ac = it.ac * (1 + you.skill("Armour") / 22) + it_plus
  if not BRC.is.body_armour(it) then return ac end

  local deformed = BRC.get.mut(BRC.MUTATIONS.deformed, true) > 0
  local pseudopods = BRC.get.mut(BRC.MUTATIONS.pseudopods, true) > 0
  if pseudopods or deformed then return ac * 6 / 10 end

  return ac
end

function BRC.get.armour_ev(it)
  -- dcss v0.33.1
  -- This function computes the armour-based component to standard EV (not paralysed, etc)
  -- Factors in stat changes from this armour and removing current one
  local str = you.strength()
  local dex = you.dexterity()
  local no_art_str = str
  local no_art_dex = dex
  local art_ev = 0

  -- Adjust str/dex/EV for artefact stat changes
  local worn = items.equipped_at("armour")
  if worn and worn.artefact then
    if worn.artprops["Str"] then str = str - worn.artprops["Str"] end
    if worn.artprops["Dex"] then dex = dex - worn.artprops["Dex"] end
    if worn.artprops["EV"] then art_ev = art_ev - worn.artprops["EV"] end
  end

  if it.artefact then
    if it.artprops["Str"] then str = str + it.artprops["Str"] end
    if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
    if it.artprops["EV"] then art_ev = art_ev + it.artprops["EV"] end
  end

  if str <= 0 then str = 1 end

  local dodge_bonus = get_adjusted_dodge_bonus(it.encumbrance, str, dex)
  local naked_dodge_bonus = get_adjusted_dodge_bonus(0, no_art_str, no_art_dex)
  return (dodge_bonus - naked_dodge_bonus) + art_ev - get_adjusted_armour_pen(it.encumbrance, str)
end

function BRC.get.shield_sh(it)
  -- dcss v0.33.1
  local dex = you.dexterity()
  if it.artefact and it.is_identified then
    local art_dex = it.artprops["Dex"]
    if art_dex then dex = dex + art_dex end
  end

  local cur = items.equipped_at("offhand")
  if BRC.is.shield(cur) and cur.artefact and cur.slot ~= it.slot then
    local art_dex = cur.artprops["Dex"]
    if art_dex then dex = dex - art_dex end
  end

  local it_plus = it.plus or 0

  local base_sh = it.ac * 2
  local shield = base_sh * (50 + you.skill("Shields") * 5 / 2)
  shield = shield + 200 * it_plus
  shield = shield + 38 * (you.skill("Shields") + 3 + dex * (base_sh + 13) / 26)
  return shield / 200
end

-- Weapon stats
function BRC.get.weap_dps(it, dmg_type)
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  return BRC.get.weap_damage(it, dmg_type) / get_weap_delay(it)
end

function BRC.get.weap_damage(it, dmg_type)
  -- Returns an adjusted weapon damage = damage * speed
  -- Includes stat/slay changes between weapon and the one currently wielded
  -- Aux attacks not included
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  local it_plus = it.plus or 0
  -- Adjust str/dex/slay from artefacts
  local str = you.strength()
  local dex = you.dexterity()

  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local wielded = items.equipped_at("weapon")
    if wielded and wielded.artefact then
      if wielded.artprops["Str"] then str = str - wielded.artprops["Str"] end
      if wielded.artprops["Dex"] then dex = dex - wielded.artprops["Dex"] end
      if wielded.artprops["Slay"] then it_plus = it_plus - wielded.artprops["Slay"] end
    end

    if it.artefact and it.is_identified then
      if it.artprops["Str"] then str = str + it.artprops["Str"] end
      if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
      if it.artprops["Slay"] then it_plus = it_plus + it.artprops["Slay"] end
    end
  end

  local stat = str
  if it.is_ranged or it.weap_skill:find("Blades", 1, true) then stat = dex end

  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + BRC.get.skill(it.weap_skill) / 25 / 2) * (1 + you.skill("Fighting") / 30 / 2)

  it_plus = it_plus + get_slay_bonuses()

  local pre_brand_dmg_no_plus = it.damage * stat_mod * skill_mod
  local pre_brand_dmg = pre_brand_dmg_no_plus + it_plus

  if BRC.is.magic_staff(it) then return (pre_brand_dmg + get_staff_bonus_dmg(it, dmg_type)) end

  if dmg_type == BRC.DMG_TYPE.plain then
    local ego = BRC.get.ego(it)
    if ego and util.contains(BRC.NON_ELEMENTAL_DMG_EGOS, ego) then
      local bonus = BRC.BrandBonus[ego] or BRC.BrandBonus.subtle[ego]
      return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset
    end
  elseif dmg_type >= BRC.DMG_TYPE.branded then
    local ego = BRC.get.ego(it)
    if ego then
      local bonus = BRC.BrandBonus[ego]
      if not bonus and dmg_type == BRC.DMG_TYPE.scoring then bonus = BRC.BrandBonus.subtle[ego] end
      if bonus then return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset end
    end
  end

  return pre_brand_dmg
end

function BRC.get.weap_score(it, no_brand_bonus)
  if it.dps and it.acc then
    -- Handle cached /  high-score tuples in _weapon_cache
    return it.dps + it.acc * BRC.Tuning.weap.pickup.accuracy_weight
  end
  local it_plus = it.plus or 0
  local dmg_type = no_brand_bonus and BRC.DMG_TYPE.unbranded or BRC.DMG_TYPE.scoring
  return BRC.get.weap_dps(it, dmg_type) + (it.accuracy + it_plus) * BRC.Tuning.weap.pickup.accuracy_weight
end

}
############################### End lua/core/util.lua ###############################
##########################################################################################

################################### Begin lua/core/brc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC (Buehler RC) Core Module
This module serves as the central coordinator for all feature modules
It automatically loads any global module/table that defines `BRC_FEATURE_NAME`
It then manages the feature's lifecycle and hook dispatching
Author: buehler
Dependencies: core/data.lua, core/util.lua
--]]

-- Initialize
BRC = BRC or {}
BRC.VERSION = "1.1.0"
BRC.active = false

-- Local constants
local HOOK_FUNCTIONS = {
  autopickup = "autopickup",
  c_answer_prompt = "c_answer_prompt",
  c_assign_invletter = "c_assign_invletter",
  c_message = "c_message",
  init = "init",
  ready = "ready",
} -- HOOK_FUNCTIONS (do not remove this comment)

-- Local variables
local _features = {}
local _hooks = {}
local prev_turn

-- Local functions
local function is_feature_module(maybe_feature_module)
  return maybe_feature_module
    and type(maybe_feature_module) == "table"
    and maybe_feature_module.BRC_FEATURE_NAME
    and type(maybe_feature_module.BRC_FEATURE_NAME) == "string"
    and #maybe_feature_module.BRC_FEATURE_NAME > 0
end

local function handle_feature_error(feature_name, hook_name, result)
  BRC.log.error(string.format("Failure in %s.%s", feature_name, hook_name), result)
  if BRC.mpr.yesno(string.format("Deactivate %s?", feature_name), BRC.COLORS.yellow) then
    BRC.unregister_feature(feature_name)
  else
    BRC.mpr.okay()
  end
end

-- Hook dispatching
local function call_all_hooks(hook_name, ...)
  local last_return_value = nil
  local returning_feature = nil

  for i = #_hooks[hook_name], 1, -1 do
    local hook_info = _hooks[hook_name][i]
    local success, result = pcall(hook_info.func, ...)
    if not success then
      handle_feature_error(hook_info.feature_name, hook_name, result)
    else
      if last_return_value and result and last_return_value ~= result then
        BRC.log.warning(string.format(
            "Return value mismatch in %s:\n  (first) %s -> %s\n  (final) %s -> %s",
            hook_name,
            returning_feature, BRC.data.BRC.data.val2str(last_return_value),
            hook_info.feature_name, BRC.data.BRC.data.val2str(result)
          ))
      end

      last_return_value = result
      returning_feature = hook_info.feature_name
    end
  end

  return last_return_value
end

local function handle_core_error(hook_name, result, ...)
  local params = {}
  for i = 1, select("#", ...) do
    local param = select(i, ...)
    if param and param.name and type(param.name) == "function" then
      params[#params + 1] = param.name()
    else
      params[#params + 1] = BRC.data.val2str(param):gsub("<", "<_")
    end
  end
  local param_str = table.concat(params, ", ")

  BRC.log.error("BRC failure in safe_call_all_hooks(" .. hook_name .. ", " .. param_str .. ")", result)
  if BRC.mpr.yesno("Deactivate BRC." .. hook_name .. "?", BRC.COLORS.yellow) then
    _hooks[hook_name] = nil
    BRC.mpr.brown("Unregistered hook: " .. tostring(hook_name))
  else
    BRC.mpr.okay("Returning nil to " .. hook_name .. ".")
  end
end

-- safe_call_all_hooks() - Errors in this function won't show up in crawl, so it is kept very simple + protected.
-- Errors in call_all_hooks() or handle_core_error() are caught by this function.
local function safe_call_all_hooks(hook_name, ...)
  if not BRC.active and hook_name ~= HOOK_FUNCTIONS.init then return end
  if not _hooks or not _hooks[hook_name] then return end

  local success, result = pcall(call_all_hooks, hook_name, ...)
  if success then return result end

  success, result = pcall(handle_core_error, hook_name, result, ...)
  if success then return end

  -- This is a serious error. Failed in the hook, and when we tried to report it.
  BRC.log.error("Failed to report BRC core error!", result)
  if BRC.mpr.yesno("Dump char and deactivate BRC?", BRC.COLORS.yellow) then
    BRC.active = false
    BRC.mpr.brown("BRC deactivated.", "Error in hook: " .. tostring(hook_name))
    pcall(BRC.dump.char, true)
  else
    BRC.mpr.okay()
  end
end

-- Hook management
local function register_all_features(parent_module)
  local loaded_count = 0

  -- Default to scanning the global namespace for modules
  parent_module = parent_module or _G
  if type(parent_module) ~= "table" then
    BRC.log.warning("Invalid parent module (must be a table). Using global namespace instead.")
    parent_module = _G
  end

  -- Scan the namespace for feature modules and load them
  for name, value in pairs(parent_module) do
    if is_feature_module(value) then
      local feature_name = value.BRC_FEATURE_NAME
      local success = BRC.register_feature(feature_name, value)

      if success then
        loaded_count = loaded_count + 1
      else
        BRC.log.error(string.format("Failed to register feature: %s. Aborting bulk registration.", name))
        return loaded_count
      end
    end
  end

  return loaded_count
end

-- Public API
function BRC.register_feature(feature_name, feature_module)
  if not feature_name or not feature_module then
    BRC.log.error("Invalid feature registration: missing name or module")
    return false
  end
  if _features[feature_name] then
    BRC.log.error(BRC.text.yellow(feature_name) .. " is already registered")
    return false
  end

  _features[feature_name] = feature_module
  for _, hook_name in pairs(HOOK_FUNCTIONS) do
    if feature_module[hook_name] then
      if not _hooks[hook_name] then _hooks[hook_name] = {} end
      table.insert(_hooks[hook_name], {
        feature_name = feature_name,
        hook_name = hook_name,
        func = feature_module[hook_name],
      })
    end
  end

  BRC.log.debug(string.format("Feature '%s' registered", BRC.text.lightcyan(feature_name)))
  return true
end

function BRC.unregister_feature(feature_name)
  if not _features[feature_name] then
    BRC.log.error(string.format("Feature '%s' is not registered", BRC.text.yellow(feature_name)))
    return false
  end

  _features[feature_name] = nil
  for _, hook_list in pairs(_hooks) do
    for i = #hook_list, 1, -1 do
      if hook_list[i].feature_name == feature_name then
        BRC.log.info(string.format("Unregistered hook: %s.%s", hook_list[i].feature_name, hook_list[i].hook_name))
        table.remove(hook_list, i)
      end
    end
  end

  BRC.log.debug(string.format("Feature '%s' unregistered", BRC.text.lightcyan(feature_name)))
  return true
end

function BRC.init(parent_module)
  _features = {}
  _hooks = {}

  -- Load all features, then the data module last
  local loaded_count = register_all_features(parent_module)
  if loaded_count == 0 then
    BRC.mpr.lightred("No features loaded. BRC is inactive.")
    return false
  end
  BRC.log.debug(string.format("Loaded %d features.", loaded_count, parent_module))

  -- Init features
  BRC.log.debug(BRC.text.green("Initializing features..."))
  safe_call_all_hooks(HOOK_FUNCTIONS.init)
  if not BRC.data.init() then
    BRC.log.error("Failed to initialize data module. BRC is inactive.")
    return false
  end

  -- Add the autopickup hook
  add_autopickup_func(function(it, _) return BRC.autopickup(it) end)

  -- Register the char_dump macro
  if BRC.Config.offer_debug_notes_on_char_dump then
    BRC.set.macro(BRC.get.command_key("CMD_CHARACTER_DUMP") or "#", "macro_brc_dump_character")
  end

  -- Success!
  local success_emoji = BRC.Config.emojis and BRC.Emoji.SUCCESS.." " or ""
  local success_text = string.format("Successfully initialized BRC system v%s!", BRC.VERSION)
  BRC.mpr.lightgreen(string.format("\n%s%s %s", success_emoji, success_text, success_emoji))

  prev_turn = -1
  BRC.active = true
  BRC.ready()
  return true
end


-- Hook methods
function BRC.autopickup(it, _)
  return safe_call_all_hooks(HOOK_FUNCTIONS.autopickup, it)
end

function BRC.ready()
  crawl.redraw_screen()
  if you.turns() == prev_turn then return end
  prev_turn = you.turns()
  safe_call_all_hooks(HOOK_FUNCTIONS.ready)
  BRC.mpr.consume_queue()
end

function BRC.c_message(text, channel)
  safe_call_all_hooks(HOOK_FUNCTIONS.c_message, text, channel)
end

function BRC.c_answer_prompt(prompt)
  if not prompt then return end -- This fires from crawl, e.g. Shop purchase confirmation
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_answer_prompt, prompt)
end

function BRC.c_assign_invletter(it)
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_assign_invletter, it)
end

}
############################### End lua/core/brc.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

### Lua feature files ###

################################### Begin lua/features/after-shaft.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: after-shaft
Description: Automatically stops exploration on stairs after falling into a shaft
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_after_shaft = {}
f_after_shaft.BRC_FEATURE_NAME = "after-shaft"

-- Persistent variables
as_shaft_depth = BRC.data.persist("as_shaft_depth", 0)
as_shaft_branch = BRC.data.persist("as_shaft_branch", "NA")

-- Hook functions
function f_after_shaft.init()
  if not BRC.Config.stop_on_stairs_after_shaft then return end

  if you.turns() == 0 and you.class() == "Delver" then
    as_shaft_depth = 1
    as_shaft_branch = you.branch()
  end

  BRC.set.explore_stop("stairs", as_shaft_depth ~= 0)
end

function f_after_shaft.c_message(text, channel)
  if not BRC.Config.stop_on_stairs_after_shaft then return end
  if channel ~= "plain" or BRC.you.in_hell() then return end
  if as_shaft_depth ~= 0 and you.branch() == as_shaft_branch then return end

  local text_fall = "ou fall into a shaft"
  local text_sucked = "ou are sucked into a shaft"
  if text:find(text_fall, 1, true) or text:find(text_sucked, 1, true) then
    as_shaft_depth = you.depth()
    as_shaft_branch = you.branch()
    BRC.set.explore_stop("stairs", true)
  end
end

function f_after_shaft.ready()
  if not BRC.Config.stop_on_stairs_after_shaft then return end
  if you.depth() == as_shaft_depth and you.branch() == as_shaft_branch then
    BRC.set.explore_stop("stairs", false)
    as_shaft_depth = 0
    as_shaft_branch = "NA"
  end
end

}
############################### End lua/features/after-shaft.lua ###############################
##########################################################################################

################################### Begin lua/features/alert-monsters.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: alert-monsters
Description: Dynamic force_more configuration for monsters based on player HP, xl, willpower, resistances, etc.
    WARNINGS:
      - Never put a '}' on a line by itself. This breaks crawl's RC parser.
      - POSIX regex are required for this feature to use '|' in patterns.
Author: original by gammafunk, extended by buehler
Dependencies: core/config.lua, core/util.lua
--]]

f_alert_monsters = {}
f_alert_monsters.BRC_FEATURE_NAME = "alert-monsters"

-- Local constants / configuration
--[[
FM_PATTERNS configures all alerts. Each table within it creates one alert, using the following fields:
  - `name` is for debugging.
  - `pattern` is either a string or a table of monster names, that will file a force_more when they come into view.
  - `is_pack` (optional) indicates the alert is for a pack of monsters.
    Packs only fire once every few turns - as defined in BRC.Config.pack_timeout (default 15).
  - `flash_screen` (optional) indicates the alert should flash the screen instead of using force_more.
  - `cutoff` sets the point when the alert is active (usually how much HP you have)
  - `cond` defines HOW the character stats are compared against `cutoff` (HP/will/etc).
      Ex:
        `always` alerts are always on.
        `hp` alerts are active when you have < `cutoff` HP.
        `will` alerts are active when you have <= `cutoff` pips of willpower.
        `int` alerts are active when you have < `cutoff` Int.
        `xl` alerts are active when your XL is < `cutoff`.
        `elec` alerts are active when you have no rElec and < `cutoff` HP.
        `fire`, `cold`, etc are active < `cutoff` HP with no resistance. Pips of res reduce the cutoff to 50/33/20%
--]]
local FM_PATTERNS = {
  { name = "always_fm",
    pattern = {
      -- High damage/speed
      "flayed ghost", "juggernaut", "orbs? of (entropy|fire|winter)",
      --Summoning
      "boundless tesseract", "demonspawn corrupter", "draconian stormcaller", "dryad",
      "guardian serpent", "halazid warlock", "shadow demon", "spriggan druid", "worldbinder",
      --Dangerous abilities
      "iron giant", "merfolk aquamancer", "shambling mangrove", "starflower",
      "torpor snail", "water nymph", "wretched star", "wyrmhole",
      --Dangerous clouds
      "apocalypse crab","catoblepas",
    } },

  { name = "always_flash",
    flash_screen = true,
    pattern = {
      -- Noteworthy abilities
      "air elemental", "elemental wellspring", "ghost crab", "ironbound convoker",
      "vault guardian", "vault warden", "wendingo",
      -- Displacement
      "deep elf knight", "swamp worm",
      -- Summoning
      "deep elf elementalist",
    } },

  { name = "always_fm_pack",
    is_pack = true,
    pattern = { "boggart", "dream sheep", "floating eye", "shrike", } },

  -- Early game Dungeon problems for chars with low mhp. (adder defined below)
  { name = "30hp", cond = "hp", cutoff = 30,
    pattern = { "hound", "gnoll" } },

  -- Monsters dangerous until a certain point
  { name = "xl_7", cond = "xl", cutoff = 7,
    pattern = { "orc wizard" } },
  { name = "xl_12", cond = "xl", cutoff = 12,
    pattern = { "hydra", "bloated husk" } },

  -- Monsters that can hit for ~50% of hp from range with unbranded attacks
  { name = "40hp", cond = "hp", cutoff = 40,
    pattern = { "orc priest" } },
  { name = "50hp", cond = "hp", cutoff = 50,
    pattern = { "orc high priest", "manticore" } },
  { name = "60hp", cond = "hp", cutoff = 60,
    pattern = { "yaktaur(?! captain)", "cyclops", "centaur(?! warrior)" } },
  { name = "70hp_melai", cond = "hp", cutoff = 70,
    is_pack = true,
    pattern = "meliai" },
  { name = "80hp", cond = "hp", cutoff = 80,
    pattern = { "gargoyle" } },
  { name = "90hp", cond = "hp", cutoff = 90,
    pattern = { "deep elf archer", "tengu conjurer" } },
  { name = "110hp", cond = "hp", cutoff = 110,
    pattern = { "centaur warrior", "yaktaur captain", "hellion", "eye of devastation",
                "sun moth", "deep elf high priest", "deep troll earth mage",
                "stone giant", "cacodemon" } },
  { name = "120hp", cond = "hp", cutoff = 120,
    pattern = { "quicksilver (dragon|elemental)", "magenta draconian", "thorn hunter" } },
  { name = "160hp", cond = "hp", cutoff = 160,
    pattern = { "brimstone fiend", "deep elf sorcererhell sentinal", "war gargoyle",
                "draconian (knight|scorcher)" } },
  { name = "200hp", cond = "hp", cutoff = 200,
    pattern = { "(draconian|deep elf) annihilator", "iron (dragon|elemental)" } },

  -- Monsters that can crowd-control you without sufficient willpower
  -- Cutoff ~10% for most spells; lower for more significant spells like banish
  { name = "willpower2", cond = "will", cutoff = 2,
    pattern = { "basilisk", "naga ritualist", "vampire(?! (bat|mage|mosquito))", "sphinx marauder" } },
  { name = "willpower3", cond = "will", cutoff = 3,
    pattern = { "deep elf (demonologist|sorcerer|archer)", "occultist", "merfolk siren", "fenstrider witch",
                "cacodemon", "imperial myrmidon", "guardian sphinx", "nagaraja", "draconian shifter",
                "glowing orange brain", "orc sorcerer", "ogre mage", "satyr", "vault sentinel", "iron elemental",
                "death knight", "vampire knight" } },
  { name = "willpower3_great_orb_of_eyes", cond = "will", cutoff = 3,
    is_pack = true,
    pattern = "great orb of eyes" },
  { name = "willpower3_golden_eye", cond = "will", cutoff = 3,
    is_pack = true,
    pattern = "golden eye" },
  { name = "willpower4", cond = "will", cutoff = 4,
    pattern = { "merfolk avatar", "tainted leviathan", "nargun" } },

  -- Brain feed with low int
  { name = "brainfeed", cond = "int", cutoff = 6,
    pattern = { "glowing orange brain", "neqoxec" } },

  -- Alert if no resist and HP below cutoff
  { name = "pois_30", cond = "pois", cutoff = 30,
    pattern = { "adder" } },
  { name = "pois_80", cond = "pois", cutoff = 80,
    pattern = { "golden dragon", "green draconian", "swamp dragon" } },
  { name = "pois_120", cond = "pois", cutoff = 120,
    pattern = { "green death", "naga mage", "nagaraja", "fenstrider witch" } },
  { name = "pois_140", cond = "pois", cutoff = 140,
    pattern = { "tengu reaver" } },

  { name = "elec_40", cond = "elec", cutoff = 40, is_pack = true,
    pattern = "electric eel" },
  { name = "elec_80", cond = "elec", cutoff = 80,
    pattern = { "shock serpent", "raiju", "spark wasp" } },
  { name = "elec_120", cond = "elec", cutoff = 120,
    pattern = { "black draconian", "blizzard demon", "deep elf zephyrmancer", "storm dragon", "tengu conjurer" } },
  { name = "elec_140", cond = "elec", cutoff = 140,
    pattern = { "electric golem", "titan", "servants? of whisper", "spriggan air mage",
                "ball lightning", "tengu reaver" } },

  { name = "corr_60", cond = "corr", cutoff = 60,
    pattern = { "acid dragon" } },
  { name = "corr_140", cond = "corr", cutoff = 140,
    pattern = { "tengu reaver", "entropy weaver", "demonspawn corrupter", "moon troll" } },

  { name = "fire_60", cond = "fire", cutoff = 60,
    pattern = { "steam dragon", "lindwurm", "fire crab", "lava snake" } },
  { name = "fire_100", cond = "fire", cutoff = 100,
    pattern = { "efreet", "deep elf pyromancer", "smoke demon", "sun moth" } },
  { name = "fire_120", cond = "fire", cutoff = 120,
    pattern = { "orc sorcerer", "hell hound", "demonspawn blood saint", "red draconian", "ogre mage",
                "molten gargoyle", "hell knight" } },
  { name = "fire_140", cond = "fire", cutoff = 140,
    pattern = { "balrug" } },
  { name = "fire_160", cond = "fire", cutoff = 160,
    pattern = { "will-o-the-wisp", "ophan", "fire giant", "golden dragon", "fire dragon", "salamander tyrant",
                "tengu reaver" } },
  { name = "fire_240", cond = "fire", cutoff = 240,
    pattern = { "hellephant", "crystal (guardian|echidna)", "draconian scorcher" } },

  { name = "cold_80", cond = "cold", cutoff = 80,
    pattern = { "rime drake" } },
  { name = "cold_120", cond = "cold", cutoff = 120,
    pattern = { "blizzard demon", "bog body", "ironbound frostheart", "demonspawn blood saint",
                "white draconian" } },
  { name = "cold_160", cond = "cold", cutoff = 160,
    pattern = { "golden dragon", "draconian knight", "frost giant", "ice dragon", "tengu reaver" } },
  { name = "cold_180", cond = "cold", cutoff = 180,
    pattern = { "(?<!dread)(?<!ancient) lich", "lich king" } },
  { name = "cold_240", cond = "cold", cutoff = 240,
    pattern = { "crystal (guardian|echidna)" } },

  { name = "drain_100", cond = "drain", cutoff = 100,
    pattern = { "orc sorcerer" } },
  { name = "drain_120", cond = "drain", cutoff = 120,
    pattern = { "necromancer" } },
  { name = "drain_150", cond = "drain", cutoff = 150,
    pattern = { "revenant", "demonspawn blood saint" } },
  { name = "drain_190", cond = "drain", cutoff = 190,
    pattern = { "shadow dragon" } },
} -- end fm_patterns (do not remove this comment)

local function append_conditional_alerts()
  -- Conditionally add miasma monsters
  if not BRC.you.miasma_immune() then
    util.append(FM_PATTERNS, {
      name = "miasma", cond = "always", cutoff = 0,
      pattern = { "death drake", "tainted leviathan", "putrid mouth", }
    })
  end

  -- Conditionally add tormentors
  if not you.torment_immune() then
    util.append(FM_PATTERNS, {
      name = "torment", cond = "always", cutoff = 0,
      pattern = { "tormentor", "curse (toe|skull)", "Fiend", "tzitzimi", "royal mummy",
                  "mummy priest", "(dread|ancient) lich", "lurking horror", }
    })
  end

  -- Set mutators to either flash (if undead) or a conditional fm
  local mutator_str = "cacodemon|neqoxec|shining eye"
  if BRC.you.mutation_immune() then
    BRC.set.flash_screen_message("monster_warning:" .. mutator_str, true)
  else
    util.append(FM_PATTERNS, { name = "malmutate", cond = "mut", cutoff = 1, pattern = mutator_str })
  end

  -- If configured, add fm for all uniques and pan lords
  if BRC.Config.fm_on_uniques then
    BRC.set.force_more_message("monster_warning:(?-i:[A-Z]).*(?<!rb Guardian) comes? into view", true)
  end
end
------------------- End config section -------------------

-- Local variables
local patterns_to_mute -- which packs to mute at next ready()

-- Local constants
local WARN_PREFIX = "monster_warning:(?<!spectral )("
local WARN_SUFFIX = ")(?! (zombie|skeleton|simulacrum)).*comes? into view"

-- Local functions
local function check_alert_three_pip(hp, dmg_threshold, resistance)
  -- Dmg taken is 1/1; 1/2; 1/3; 1/5 (for 0; 1; 2; 3 resistance)
  if resistance >= 3 then return hp < dmg_threshold / 5 end
  return hp < dmg_threshold / (resistance + 1)
end

local function update_pack_mutes()
  -- Put pending mutes into effect
  for _, v in ipairs(patterns_to_mute) do
    if v.flash_screen then
      BRC.set.flash_screen_message(v, false)
    else
      BRC.set.force_more_message(v, false)
    end
    if BRC.Config.debug_alert_monsters then BRC.mpr.blue(string.format("Muted pack: %s", v)) end
  end
  patterns_to_mute = {}

  -- Remove expired mutes
  for _, v in ipairs(FM_PATTERNS) do
    if v.is_pack and v.last_fm_turn ~= -1 and you.turns() >= v.last_fm_turn + BRC.Config.pack_timeout then
      v.last_fm_turn = -1
      v.active_alert = false -- Set to false and let the main logic decide if it should reactivate it.
      if BRC.Config.debug_alert_monsters then BRC.mpr.blue(string.format("Unmuted pack: %s", v.pattern)) end
    end
  end
end

-- Hook functions
function f_alert_monsters.init()
  patterns_to_mute = {}
  append_conditional_alerts()

  -- Break packs with tables into individual alerts
  local add_patterns = {}
  local remove_patterns = {}
  for _, v in ipairs(FM_PATTERNS) do
    if v.is_pack and type(v.pattern) == "table" and #v.pattern > 1 then
      remove_patterns[#remove_patterns + 1] = v
      for _, m in ipairs(v.pattern) do
        local to_add = util.copy_table(v)
        to_add.name = (to_add.name or "") .. "_" .. m:gsub(" ", "_")
        to_add.pattern = m
        add_patterns[#add_patterns + 1] = to_add
      end
    end
  end
  util.append(FM_PATTERNS, add_patterns)
  for _, v in ipairs(remove_patterns) do
    util.remove(FM_PATTERNS, v)
  end

  -- Convert patterns to regex
  for _, v in ipairs(FM_PATTERNS) do
    v.active_alert = false
    v.last_fm_turn = -1
    if type(v.pattern) == "table" then
      v.pattern = table.concat(v.pattern, "|")
    end
    v.pattern = WARN_PREFIX .. v.pattern .. WARN_SUFFIX
    v.regex = crawl.regex(v.pattern:gsub("monster_warning:", ""))
  end
end

function f_alert_monsters.c_message(text, channel)
  if channel ~= "monster_warning" or not text:find("comes? into view") or BRC.Config.pack_timeout <= 0 then return end
  -- Identify when a mute should be turned on
  for _, v in ipairs(FM_PATTERNS) do
    if v.is_pack and v.regex:matches(text) then
      if v.last_fm_turn == -1 then
        patterns_to_mute[#patterns_to_mute + 1] = v.pattern
        if BRC.Config.debug_alert_monsters then BRC.mpr.blue(string.format("To mute: %s", v.pattern)) end
      else
        if BRC.Config.debug_alert_monsters then BRC.mpr.blue(string.format("Extending mute: %s", v.pattern)) end
      end
      v.last_fm_turn = you.turns()
    end
  end
end

function f_alert_monsters.ready()
  local activated = {}
  local deactivated = {}

  -- Load all stats before loop. Most of them are used multiple times.
  local hp, _ = you.hp()
  local amulet = items.equipped_at("amulet")
  if (you.race() == "Vine Stalker") or (amulet and amulet.name() == "amulet of guardian spirit") then
    local mp, _ = you.mp()
    hp = hp + mp
  end
  local xl = you.xl()
  local int = you.intelligence()
  local willpower = you.willpower()
  local res_mut = you.res_mutation()
  local res_pois = you.res_poison()
  local res_elec = you.res_shock()
  local res_corr = you.res_corr()
  local res_fire = you.res_fire()
  local res_cold = you.res_cold()
  local res_drain = you.res_draining()

  for _, v in ipairs(FM_PATTERNS) do
    local should_be_active = nil

    if BRC.Config.disable_alert_monsters_in_zigs and you.branch() == "Zig" then
      should_be_active = false
    elseif not v.cond then
      should_be_active = true
    elseif v.cond == "xl" then
      should_be_active = xl < v.cutoff
    elseif v.cond == "hp" then
      should_be_active = hp < v.cutoff
    elseif v.cond == "int" then
      should_be_active = int < v.cutoff
    elseif v.cond == "will" then
      should_be_active = willpower < v.cutoff
    elseif v.cond == "mut" then
      should_be_active = res_mut == 0
    elseif v.cond == "pois" then
      should_be_active = res_pois == 0 and hp < v.cutoff
    elseif v.cond == "elec" then
      should_be_active = res_elec == 0 and hp < v.cutoff
    elseif v.cond == "corr" then
      should_be_active = not res_corr and hp < v.cutoff
    elseif v.cond == "fire" then
      should_be_active = check_alert_three_pip(hp, v.cutoff, res_fire)
    elseif v.cond == "cold" then
      should_be_active = check_alert_three_pip(hp, v.cutoff, res_cold)
    elseif v.cond == "drain" then
      should_be_active = check_alert_three_pip(hp, v.cutoff, res_drain)
    end

    if should_be_active ~= v.active_alert then
      v.active_alert = should_be_active
      if v.flash_screen then
        BRC.set.flash_screen_message(v.pattern, should_be_active)
      else
        BRC.set.force_more_message(v.pattern, should_be_active)
      end

      if BRC.Config.debug_alert_monsters then
        if v.active_alert then
          activated[#activated + 1] = v.name or v.pattern
        else
          deactivated[#deactivated + 1] = v.name or v.pattern
        end
      end
    end
  end

  if BRC.Config.debug_alert_monsters then
    if #activated > 0 then BRC.mpr.blue(string.format("Activating f_m: %s", table.concat(activated, ", "))) end
    if #deactivated > 0 then BRC.mpr.blue(string.format("Deactivating f_m: %s", table.concat(deactivated, ", "))) end
  end

  if BRC.Config.pack_timeout > 0 then update_pack_mutes() end
end

}
############################### End lua/features/alert-monsters.lua ###############################
##########################################################################################

################################### Begin lua/features/announce-hp-mp.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: announce-hp-mp
Description: Announces changes in HP/MP with visual meters and damage warnings
Author: magus, buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_announce_hp_mp = {}
f_announce_hp_mp.BRC_FEATURE_NAME = "announce-hp-mp"

-- Persistent variables
ad_prev = BRC.data.persist("ad_prev", { hp = 0, mhp = 0, mp = 0, mmp = 0 })

-- Local constants / configuration
local NUM_PIPS_PER_METER = 5
local METER_LENGTH = 2 + NUM_PIPS_PER_METER + 2 * (BRC.Emoji.HP_BORDER and #BRC.Emoji.HP_BORDER or 0)

-- Local functions
local function create_meter(perc, emojis)
  perc = math.max(0, math.min(1, perc)) -- Clamp between 0 and 1

  local num_halfpips = math.floor(perc * NUM_PIPS_PER_METER * 2)
  local num_full_emojis = math.floor(num_halfpips / 2)
  local num_part_emojis = num_halfpips % 2
  local num_empty_emojis = NUM_PIPS_PER_METER - num_full_emojis - num_part_emojis

  return table.concat({
    emojis.BORDER or "",
    string.rep(emojis.FULL, num_full_emojis),
    string.rep(emojis.PART, num_part_emojis),
    string.rep(emojis.EMPTY, num_empty_emojis),
    emojis.BORDER or "",
  })
end

local function format_delta(delta)
  if delta > 0 then
    return BRC.text.green(string.format("+%s", delta))
  elseif delta < 0 then
    return BRC.text.red(delta)
  else
    return BRC.text.darkgrey("+0")
  end
end

local function format_ratio(cur, max)
  local color
  if cur <= (max * 0.25) then
    color = BRC.COLORS.lightred
  elseif cur <= (max * 0.50) then
    color = BRC.COLORS.red
  elseif cur <= (max * 0.75) then
    color = BRC.COLORS.yellow
  elseif cur < max then
    color = BRC.COLORS.white
  else
    color = BRC.COLORS.green
  end

  return BRC.text.color(color, string.format(" -> %s/%s", cur, max))
end

local function get_hp_message(hp_delta, mhp_delta)
  local hp, mhp = you.hp()
  local msg_tokens = {}
  msg_tokens[#msg_tokens + 1] = create_meter(hp / mhp, BRC.Emoji.HP_METER)
  msg_tokens[#msg_tokens + 1] = BRC.text.white(string.format(" HP[%s]", format_delta(hp_delta)))
  msg_tokens[#msg_tokens + 1] = format_ratio(hp, mhp)

  if mhp_delta ~= 0 then
    local text = string.format(" (%s max HP)", format_delta(mhp_delta))
    msg_tokens[#msg_tokens + 1] = BRC.text.lightgrey(text)
  end

  if not BRC.Config.announce.same_line and hp == mhp then msg_tokens[#msg_tokens + 1] = BRC.text.white(" (Full HP)") end

  return table.concat(msg_tokens)
end

local function get_mp_message(mp_delta, mmp_delta)
  local mp, mmp = you.mp()
  local msg_tokens = {}
  msg_tokens[#msg_tokens + 1] = create_meter(mp / mmp, BRC.Emoji.MP_METER)
  msg_tokens[#msg_tokens + 1] = BRC.text.lightcyan(string.format(" MP[%s]", format_delta(mp_delta)))
  msg_tokens[#msg_tokens + 1] = format_ratio(mp, mmp)

  if mmp_delta ~= 0 then
    local tok = string.format(" (%s max MP)", format_delta(mmp_delta))
    msg_tokens[#msg_tokens + 1] = BRC.text.cyan(tok)
  end

  if not BRC.Config.announce.same_line and mp == mmp then
    msg_tokens[#msg_tokens + 1] = BRC.text.lightcyan(" (Full MP)")
  end

  return table.concat(msg_tokens)
end

local function last_msg_is_meter()
  local last_msg = crawl.messages(1)
  local check = last_msg and #last_msg > METER_LENGTH + 4 and last_msg:sub(METER_LENGTH + 1, METER_LENGTH + 4)
  return check and (check == " HP[" or check == " MP[")
end

-- Hook functions
function f_announce_hp_mp.init()
  ad_prev.hp = 0
  ad_prev.mhp = 0
  ad_prev.mp = 0
  ad_prev.mmp = 0

  if BRC.Config.dmg_fm_threshold > 0 and BRC.Config.dmg_fm_threshold <= 0.5 then
    BRC.set.message_mute("Ouch! That really hurt!", true)
  end
end

function f_announce_hp_mp.ready()
  -- Update prev state first, so we can safely return early below
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  local is_startup = ad_prev.hp == 0
  local hp_delta = hp - ad_prev.hp
  local mp_delta = mp - ad_prev.mp
  local mhp_delta = mhp - ad_prev.mhp
  local mmp_delta = mmp - ad_prev.mmp
  local damage_taken = mhp_delta - hp_delta
  ad_prev.hp = hp
  ad_prev.mhp = mhp
  ad_prev.mp = mp
  ad_prev.mmp = mmp

  if is_startup then return end
  if hp_delta == 0 and mp_delta == 0 and last_msg_is_meter() then return end
  local is_very_low_hp = hp <= BRC.Config.announce.very_low_hp * mhp

  -- Determine which messages to show
  local do_hp = true
  local do_mp = true
  if hp_delta <= 0 and hp_delta > -BRC.Config.announce.hp_loss_limit then do_hp = false end
  if hp_delta >= 0 and hp_delta < BRC.Config.announce.hp_gain_limit then do_hp = false end
  if mp_delta <= 0 and mp_delta > -BRC.Config.announce.mp_loss_limit then do_mp = false end
  if mp_delta >= 0 and mp_delta < BRC.Config.announce.mp_gain_limit then do_mp = false end

  if not do_hp and is_very_low_hp and hp_delta ~= 0 then do_hp = true end
  if not do_hp and not do_mp then return end
  if BRC.Config.announce.always_both then
    do_hp = true
    do_mp = true
  end

  -- Put messages together
  local hp_msg = get_hp_message(hp_delta, mhp_delta)
  local mp_msg = get_mp_message(mp_delta, mmp_delta)
  local msg_tokens = {}
  msg_tokens[1] = (BRC.Config.announce.hp_first and do_hp) and hp_msg or mp_msg
  if do_mp and do_hp then
    msg_tokens[2] = BRC.Config.announce.same_line and "       " or "\n"
    msg_tokens[3] = BRC.Config.announce.hp_first and mp_msg or hp_msg
  end
  if #msg_tokens > 0 then BRC.mpr.que(table.concat(msg_tokens)) end

  -- Add Damage-related warnings, when damage >= threshold
  if damage_taken >= mhp * BRC.Config.dmg_flash_threshold then
    if is_very_low_hp then return end -- mute % HP alerts
    local is_force_more_msg = damage_taken >= (mhp * BRC.Config.dmg_fm_threshold)
    local emoji, msg
    if is_force_more_msg then
      emoji = BRC.Emoji.EXCLAMATION_2
      msg = BRC.text.lightmagenta(" MASSIVE DAMAGE ")
    else
      emoji = BRC.Emoji.EXCLAMATION
      msg = BRC.text.magenta(" BIG DAMAGE ")
    end
    BRC.mpr.que_optmore(is_force_more_msg, emoji .. msg .. emoji)
  end
end

}
############################### End lua/features/announce-hp-mp.lua ###############################
##########################################################################################

################################### Begin lua/features/answer-prompts.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
f_answer_prompts = {}
f_answer_prompts.BRC_FEATURE_NAME = "answer_prompts"

function f_answer_prompts.c_answer_prompt(prompt)
  if prompt == "Die?" then return false end
  if prompt:find("cheaper one?", 1, true) and you.branch() ~= "Bazaar" then
    BRC.mpr.yellow("Replacing shopping list items")
    return true
  end
end

}
############################### End lua/features/answer-prompts.lua ###############################
##########################################################################################

################################### Begin lua/features/color-inscribe.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: color-inscribe
Description: Colorizes inscriptions on items with appropriate colors for resistances, stats, and other properties
Author: buehler
Dependencies: core/config.lua, core/constants.lua
--]]

f_color_inscribe = {}
f_color_inscribe.BRC_FEATURE_NAME = "color-inscribe"

-- Local constants / configuration
local negative_color = BRC.COLORS.brown
local positive_color = BRC.COLORS.white
local MULTI_PLUS = "%++"
local MULTI_MINUS = "%-+"
local NEG_NUM = "%-%d+%.?%d*"
local POS_NUM = "%+%d+%.?%d*"
local COLORIZE_TAGS = {
  { "rF" .. MULTI_PLUS, BRC.COLORS.lightred },
  { "rF" .. MULTI_MINUS, negative_color },
  { "rC" .. MULTI_PLUS, BRC.COLORS.lightblue },
  { "rC" .. MULTI_MINUS, negative_color },
  { "rN" .. MULTI_PLUS, BRC.COLORS.lightmagenta },
  { "rN" .. MULTI_MINUS, negative_color },
  { "rPois", BRC.COLORS.lightgreen },
  { "rElec", BRC.COLORS.lightcyan },
  { "rCorr", BRC.COLORS.yellow },
  { "rMut", BRC.COLORS.yellow },
  { "sInv", BRC.COLORS.magenta },
  { "MRegen" .. MULTI_PLUS, BRC.COLORS.cyan },
  { "^Regen" .. MULTI_PLUS, BRC.COLORS.green }, -- Avoiding "MRegen"
  { " Regen" .. MULTI_PLUS, BRC.COLORS.green }, -- Avoiding "MRegen"
  { "Stlth" .. MULTI_PLUS, positive_color },
  { "%+Fly", positive_color },
  { "RMsl", BRC.COLORS.yellow },
  { "Will" .. MULTI_PLUS, BRC.COLORS.blue },
  { "Will" .. MULTI_MINUS, negative_color },
  { "Wiz" .. MULTI_PLUS, BRC.COLORS.cyan },
  { "Wiz" .. MULTI_MINUS, negative_color },
  { "Slay" .. POS_NUM, positive_color },
  { "Slay" .. NEG_NUM, negative_color },
  { "Str" .. POS_NUM, positive_color },
  { "Str" .. NEG_NUM, negative_color },
  { "Dex" .. POS_NUM, positive_color },
  { "Dex" .. NEG_NUM, negative_color },
  { "Int" .. POS_NUM, positive_color },
  { "Int" .. NEG_NUM, negative_color },
  { "AC" .. POS_NUM, positive_color },
  { "AC" .. NEG_NUM, negative_color },
  { "EV" .. POS_NUM, positive_color },
  { "EV" .. NEG_NUM, negative_color },
  { "SH" .. POS_NUM, positive_color },
  { "SH" .. NEG_NUM, negative_color },
  { "HP" .. POS_NUM, positive_color },
  { "HP" .. NEG_NUM, negative_color },
  { "MP" .. POS_NUM, positive_color },
  { "MP" .. NEG_NUM, negative_color },
} -- COLORIZE_TAGS (do not remove this comment)

-- Local functions
local function colorize_subtext(text, s, tag)
  local idx = text:find(s)
  if not idx then return text end
  if idx > 1 then
    -- Avoid '!r' or an existing color tag
    local prev = text:sub(idx - 1, idx - 1)
    if prev == "!" or prev == ">" then return text end
  end

  return text:gsub(s, string.format("<%s>%%1</%s>", tag, tag))
end

-- Hook functions
function f_color_inscribe.c_assign_invletter(it)
  if not BRC.Config.colorize_inscriptions then return end
  if it.artefact then return end
  -- If enabled, call out to inscribe stats before coloring
  if f_inscribe_stats.do_stat_inscription then f_inscribe_stats.do_stat_inscription(it) end

  local text = it.inscription
  for _, tag in ipairs(COLORIZE_TAGS) do
    text = colorize_subtext(text, tag[1], tag[2])
  end

  -- Limit length for % menu: = 80 total width - 25/32 other text - #name - #" {}"
  it.inscribe("", false)
  local max_length = 80 - (it.is_melded and 32 or 25) - #it.name("plain", true) - 3
  if max_length < 0 then return end
  -- Try removing darkgrey and white, then just remove all
  if #text > max_length then text = text:gsub("</*" .. BRC.COLORS.darkgrey .. ">", "") end
  if #text > max_length then text = text:gsub("</*" .. BRC.COLORS.white .. ">", "") end
  if #text > max_length then text = text:gsub("<.->", "") end

  it.inscribe(text, false)
end

--[[
TODO: To colorize more, need a way to:
  intercept messages before they're displayed (or delete and re-insert)
  insert tags that affect menus
  colorize artefact text
function f_color_inscribe.c_message(text, _)
  local orig_text = text
  text = colorize_subtext(text)
  if text == orig_text then return end

  local cleaned = BRC.text.clean_text(text)
  if cleaned:sub(2, 4) == " - " then
    text = " " .. text
  end

  crawl.mpr(text)
end
--]]

}
############################### End lua/features/color-inscribe.lua ###############################
##########################################################################################

################################### Begin lua/features/drop-inferior.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: drop-inferior
Description: Auto-tags inferior items and adds them to the drop list for quick dropping with ","
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
--]]

f_drop_inferior = {}
f_drop_inferior.BRC_FEATURE_NAME = "drop-inferior"

-- Local constants
local DROP_KEY = "~~DROP_ME"

-- Local functions
local function inscribe_drop(it)
  local new_inscr = it.inscription:gsub(DROP_KEY, "") .. DROP_KEY
  it.inscribe(new_inscr, false)
  if BRC.Config.msg_on_inscribe then
    local emoji = BRC.Emoji.CAUTION or ""
    local item_name = BRC.text.yellow(string.format("%s - %s", BRC.util.int2char(it.slot), it.name()))
    local msg = util.trim(string.format("%s You can drop: %s %s", emoji, item_name, emoji))
    BRC.mpr.cyan(msg)
  end
end

-- Hook functions
function f_drop_inferior.init()
  if not BRC.Config.drop_inferior then return end
  crawl.setopt(string.format("drop_filter += %s", DROP_KEY))
end

function f_drop_inferior.c_assign_invletter(it)
  if not BRC.Config.drop_inferior then return end
  -- Remove any previous DROP_KEY inscriptions
  it.inscribe(it.inscription:gsub(DROP_KEY, ""), false)

  if not (it.is_weapon or BRC.is.armour(it)) or BRC.is.risky_item(it) then return end
  if you.race() == "Poltergeist" and BRC.is.armour(it) then return end
  if you.race() == "Formicid" and it.subtype() == "gloves" then return end

  local it_ego = BRC.get.ego(it)
  for inv in iter.invent_iterator:new(items.inventory()) do
    -- To be a clear upgrade: Not artefact, same subtype, and ego is same or a clear upgrade
    local inv_ego = BRC.get.ego(inv)
    local ego_same_or_better = inv_ego == it_ego or not inv_ego or BRC.is.risky_item(inv)
    if not inv.artefact and inv.subtype() == it.subtype() and ego_same_or_better then
      if it.is_weapon then
        if you.race() == "Coglin" then return end -- More trouble than it's worth
        if inv.plus <= (it.plus or 0) then inscribe_drop(inv) end
      else
        if BRC.get.armour_ac(inv) <= BRC.get.armour_ac(it) and inv.encumbrance >= it.encumbrance then
          inscribe_drop(inv)
        end
      end
    end
  end
end

}
############################### End lua/features/drop-inferior.lua ###############################
##########################################################################################

################################### Begin lua/features/dynamic-options.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: dynamic-options
Description: Changes options based on game state: xl, class, race, god, skills
Author: buehler
Dependencies: core/config.lua, core/constants.lua
--]]

f_dynamic_options = {}
f_dynamic_options.BRC_FEATURE_NAME = "dynamic-options"

-- Local constants / configuration
local XL_FORCE_MORES = {
  { pattern = "monster_warning:wielding.*of electrocution", xl = 5 },
  { pattern = "You.*re more poisoned", xl = 7 },
  { pattern = "^(?!.*Your?).*speeds? up", xl = 10 },
  { pattern = "danger:goes berserk", xl = 18 },
  { pattern = "monster_warning:carrying a wand of", xl = 15 },
} -- XL_FORCE_MORES (do not remove this comment)

local IGNORE_SPELLBOOKS_STRING = table.concat(BRC.SPELLBOOKS, ", ")
local HIGH_LVL_MAGIC_STRING = "scrolls? of amnesia, potions? of brilliance, ring of wizardry"

-- Local state
local cur_god
local ignore_all_magic
local ignore_advanced_magic
local xl_force_mores_active

-- Local functions
local function set_class_options()
  if you.class() == "Hunter" then
    crawl.setopt("view_delay = 30")
  elseif you.class() == "Shapeshifter" then
    BRC.set.autopickup_exceptions("<flux bauble", true)
  end
end

local function set_god_options()
  if cur_god == you.god() then return end
  local prev_god = cur_god
  local new_god = you.god()
  cur_god = new_god

  if prev_god == "No God" or new_god == "No God" then
    local abandoned_god = new_god == "No God"
    BRC.set.force_more_message("Found.*the Ecumenical Temple", abandoned_god)
    BRC.set.flash_screen_message("Found.*the Ecumenical Temple", not abandoned_god)
    BRC.set.runrest_stop_message("Found.*the Ecumenical Temple", not abandoned_god)
  end

  if new_god == "Beogh" or prev_god == "Beogh" then
    local joined_beogh = new_god == "Beogh"
    BRC.set.runrest_ignore_message("no longer looks.*", joined_beogh)
    BRC.set.force_more_message("Your orc.*dies", joined_beogh)
  end

  if new_god == "Cheibriados" then
    util.remove(BRC.RISKY_EGOS, "Ponderous")
  elseif prev_god == "Cheibriados" then
    BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "Ponderous"
  end

  if new_god == "Jiyva" or prev_god == "Jiyva" then
    local joined_jiyva = new_god == "Jiyva"
    BRC.set.flash_screen_message("god:splits in two", joined_jiyva)
    BRC.set.message_mute("You hear a.*(slurping|squelching) noise", joined_jiyva)
  end

  if new_god == "Lugonu" then
    util.remove(BRC.RISKY_EGOS, "distort")
  elseif prev_god == "Lugonu" then
    BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "distort"
  end

  if new_god == "Trog" then
    util.remove(BRC.BAD_ART_PROPS, "-Cast")
    util.remove(BRC.RISKY_EGOS, "antimagic")
  elseif prev_god == "Trog" then
    BRC.BAD_ART_PROPS[#BRC.BAD_ART_PROPS + 1] = "-Cast"
    BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "antimagic"
  end

  if new_god == "Xom" or prev_god == "Xom" then
    BRC.set.force_more_message("god:", new_god == "Xom")
  end
end

local function set_race_options()
  if util.contains(BRC.UNDEAD_RACES, you.race()) then
    BRC.set.force_more_message("monster_warning:wielding.*of holy wrath", true)
  end

  if not util.contains(BRC.POIS_RES_RACES, you.race()) then
    BRC.set.force_more_message("monster_warning:curare", true)
  end

  if you.race() == "Gnoll" then BRC.set.message_mute("intrinsic_gain:skill increases to level", true) end
end

local function set_xl_options()
  for i, v in ipairs(XL_FORCE_MORES) do
    local should_be_active = you.xl() <= v.xl
    if xl_force_mores_active[i] ~= should_be_active then
      xl_force_mores_active[i] = should_be_active
      BRC.set.force_more_message(v.pattern, should_be_active)
    end
  end
end

local function set_skill_options()
  -- If zero spellcasting, don't stop on spellbook pickup, and allow -Cast / antimagic
  local no_spells = #you.spells() == 0
  if ignore_all_magic ~= no_spells then
    ignore_all_magic = no_spells
    BRC.set.explore_stop_pickup_ignore(IGNORE_SPELLBOOKS_STRING, no_spells)
    if no_spells then
      util.remove(BRC.BAD_ART_PROPS, "-Cast")
      util.remove(BRC.RISKY_EGOS, "antimagic")
    else
      BRC.BAD_ART_PROPS[#BRC.BAD_ART_PROPS + 1] = "-Cast"
      BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "antimagic"
    end
  end

  -- If heavy armour and low armour skill, ignore spellcasting items
  if ignore_all_magic and (you.race() ~= "Mountain Dwarf") then
    local worn = items.equipped_at("armour")
    local encumbered_magic = worn and worn.encumbrance > (4 + you.skill("Armour") / 2)
    if ignore_advanced_magic ~= encumbered_magic then
      ignore_advanced_magic = encumbered_magic
      BRC.set.autopickup_exceptions(HIGH_LVL_MAGIC_STRING, encumbered_magic)
    end
  end
end

-- Hook functions
function f_dynamic_options.init()
  cur_god = "No God"
  ignore_advanced_magic = false
  ignore_all_magic = false
  xl_force_mores_active = {}

  set_race_options()
  set_class_options()
  set_god_options()
end

function f_dynamic_options.ready()
  set_god_options()
  set_xl_options()
  set_skill_options()
end

}
############################### End lua/features/dynamic-options.lua ###############################
##########################################################################################

################################### Begin lua/features/exclude-dropped.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: exclude-dropped
Description: Automatically excludes dropped items from autopickup and removes exclusion when items are picked up
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_exclude_dropped = {}
f_exclude_dropped.BRC_FEATURE_NAME = "exclude-dropped"

-- Persistent variables
ed_dropped_items = BRC.data.persist("ed_dropped_items", {})

-- Local functions
local function add_exclusion(item_name)
  if not util.contains(ed_dropped_items, item_name) then table.insert(ed_dropped_items, item_name) end
  BRC.set.autopickup_exceptions(item_name, true)
end

local function remove_exclusion(item_name)
  util.remove(ed_dropped_items, item_name)
  BRC.set.autopickup_exceptions(item_name, false)
end

local function enchantable_weap_in_inv()
  for inv in iter.invent_iterator:new(items.inventory()) do
    if
      inv.is_weapon
      and not BRC.is.magic_staff(inv)
      and inv.plus < 9
      and (not inv.artefact or you.race() == "Mountain Dwarf")
    then
      return true
    end
  end
  return false
end

local function clean_item_text(text)
  text = BRC.text.clean_text(text, false) -- remove tags
  text = text:gsub("{.*}", "")
  text = text:gsub("[.]", "")
  text = text:gsub("%(.*%)", "")
  return util.trim(text)
end

local function extract_jewellery_or_evoker(text)
  local idx = text:find("ring of", 1, true) or text:find("amulet of", 1, true) or text:find("wand of", 1, true)
  if idx then return text:sub(idx, #text) end

  for _, item_name in ipairs(BRC.MISC_ITEMS) do
    if text:find(item_name) then return item_name end
  end
end

local function extract_missile(text)
  for _, item_name in ipairs(BRC.MISSILES) do
    if text:find(item_name) then return item_name end
  end
end

local function extract_potion(text)
  local idx = text:find("potions? of")
  if idx then return "potions? of " .. util.trim(text:sub(idx + 10, #text)) end
end

local function extract_scroll(text)
  local idx = text:find("scrolls? of")
  if idx then return "scrolls? of " .. util.trim(text:sub(idx + 10, #text)) end
end

--[[
  get_item_name() - Tries to extract item name from text.
  Returns name of item, or nil if not recognized as an excludable item.
--]]
local function get_item_name(text)
  text = clean_item_text(text)
  return extract_jewellery_or_evoker(text) or extract_missile(text) or extract_potion(text) or extract_scroll(text)
end

local function should_exclude(item_name)
  -- Enchant/Brand weapon scrolls continue pickup if they're still useful
  local weap_scroll = item_name:find("enchant weapon", 1, true) or item_name:find("brand weapon", 1, true)
  if BRC.Config.ignore_stashed_weapon_scrolls and weap_scroll and enchantable_weap_in_inv() then return false end

  -- Don't exclude if we dropped partial stack (except for jewellery)
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.name("qual"):find(item_name, 1, true) then
      if BRC.is.jewellery(inv) then return true end
      local qty_str = string.format("ou drop %s %s", inv.quantity, item_name)
      return inv.quantity == 1 or item_name:find(qty_str, 1, true)
    end
  end

  return true
end

-- Hook functions
function f_exclude_dropped.init()
  if not BRC.Config.exclude_dropped then return end

  for _, v in ipairs(ed_dropped_items) do
    add_exclusion(v)
  end
end

function f_exclude_dropped.c_message(text, channel)
  if not BRC.Config.exclude_dropped then return end
  if channel ~= "plain" then return end

  local picked_up = BRC.text.get_pickup_info(text)
  if not picked_up and not text:find("ou drop ", 1, true) then return end

  local item_name = get_item_name(text)
  if not item_name then return end

  if picked_up then
    remove_exclusion(item_name)
  elseif should_exclude(item_name) then
    add_exclusion(item_name)
  end
end

}
############################### End lua/features/exclude-dropped.lua ###############################
##########################################################################################

################################### Begin lua/features/fully-recover.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: fully-recover
Description: Automatically rests until fully recovered from negative statuses, with smart recovery logic
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/util.lua
--]]

f_fully_recover = {}
f_fully_recover.BRC_FEATURE_NAME = "fully-recover"

-- Local constants / configuration
local MAX_TURNS_TO_WAIT = 500
local WAITING_MESSAGE = "You start waiting."

-- Local variables
local fr_start_turn
local fr_explore_after

-- Local functions
local function abort_fully_recover()
  fr_start_turn = 0
  fr_explore_after = false
  BRC.set.message_mute(WAITING_MESSAGE, false)
  you.stop_activity()
end

local function finish_fully_recover()
  local turns = you.turns() - fr_start_turn
  BRC.mpr.lightgreen(string.format("Fully recovered (%d turns)", turns))

  fr_start_turn = 0
  BRC.set.message_mute(WAITING_MESSAGE, false)
  you.stop_activity()

  if fr_explore_after then
    fr_explore_after = false
    crawl.mpr("Exploring after fully recovering")
    BRC.util.do_cmd("CMD_EXPLORE")
  end
end

local function should_ignore_status(s)
  if s == "corroded" then
    return BRC.you.by_slimy_wall() or you.branch() == "Dis"
  elseif s == "slowed" then
    return BRC.you.zero_stat()
  end
  return false
end

local function fully_recovered()
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  if hp ~= mhp then return false end
  if mp ~= mmp then return false end

  local status = you.status()
  for _, s in ipairs(BRC.Config.rest_off_statuses) do
    if status:find(s) then
      if not should_ignore_status(s) then return false end
    end
  end

  return true
end

local function remove_statuses_from_config()
  local status = you.status()
  local to_remove = {}
  for _, s in ipairs(BRC.Config.rest_off_statuses) do
    if status:find(s) then table.insert(to_remove, s) end
  end
  for _, s in ipairs(to_remove) do
    util.remove(BRC.Config.rest_off_statuses, s)
    crawl.error(string.format("  Removed: %s", s))
  end
end

local function start_fully_recover()
  fr_start_turn = you.turns()
  BRC.set.message_mute(WAITING_MESSAGE, true)
end

-- Macro function: Attach full recovery to auto-explore
function macro_f_fully_recover_explore()
  if not BRC.active then return BRC.util.do_cmd("CMD_EXPLORE") end

  if fully_recovered() then
    if fr_start_turn > 0 then
      finish_fully_recover()
    else
      BRC.util.do_cmd("CMD_EXPLORE")
    end
  else
    fr_explore_after = true
    BRC.util.do_cmd("CMD_REST")
  end
end

-- Hook functions
function f_fully_recover.init()
  fr_start_turn = 0
  fr_explore_after = false
  util.remove(BRC.Config.rest_off_statuses, "slowed") -- special case handled elsewhere

  BRC.set.runrest_ignore_message("recovery:.*", true)
  BRC.set.runrest_ignore_message("duration:.*", true)
  BRC.set.macro(BRC.get.command_key("CMD_EXPLORE") or "o", "macro_f_fully_recover_explore")
end

function f_fully_recover.c_message(text, channel)
  if channel == "plain" then
    if text:find(WAITING_MESSAGE, 1, true) or text:find("ou start resting", 1, true) then
      if not fully_recovered() then start_fully_recover() end
    end
  elseif fr_start_turn > 0 then
    if channel == "timed_portal" then
      abort_fully_recover()
    elseif fully_recovered() then
      finish_fully_recover()
    end
  end
end

function f_fully_recover.ready()
  if fr_start_turn > 0 then
    if fully_recovered() then
      finish_fully_recover()
    elseif not you.feel_safe() then
      abort_fully_recover()
    elseif you.turns() - fr_start_turn > MAX_TURNS_TO_WAIT then
      BRC.log.error(string.format("fully-recover timed out after %s turns.", MAX_TURNS_TO_WAIT))
      BRC.log.error("Adjusting BRC.Config.rest_off_statuses:")
      remove_statuses_from_config()
      abort_fully_recover()
    else
      BRC.util.do_cmd("CMD_SAFE_WAIT")
    end
  else
    fr_explore_after = false
  end
end

}
############################### End lua/features/fully-recover.lua ###############################
##########################################################################################

################################### Begin lua/features/inscribe-stats.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: inscribe-stats
Description: Automatically inscribes+updates weapon DPS/dmg/delay, or armour AC/EV/SH, on items in inventory
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
--]]

f_inscribe_stats = {}
f_inscribe_stats.BRC_FEATURE_NAME = "inscribe-stats"

-- Local constants / configuration
local NUM_PATTERN = "[%+%-:]%d+%.%d*" -- Matches numbers w/ decimal

-- Local functions
local function inscribe_armour_stats(it)
  local abbr = BRC.is.shield(it) and "SH" or "AC"
  local ac_or_sh, ev = BRC.get.armour_stats(it)

  local new_insc
  if it.inscription:find(abbr .. NUM_PATTERN) then
    -- Replace each stat individually, to avoid overwriting <color> tags
    new_insc = it.inscription:gsub(abbr .. NUM_PATTERN, ac_or_sh)
    if ev and ev ~= "" then new_insc = new_insc:gsub("EV" .. NUM_PATTERN, ev) end
  else
    new_insc = ac_or_sh
    if ev and ev ~= "" then new_insc = string.format("%s, %s", new_insc, ev) end
    if it.inscription and it.inscription ~= "" then new_insc = string.format("%s; %s", new_insc, it.inscription) end
  end

  it.inscribe(new_insc, false)
end

local function inscribe_weapon_stats(it)
  local orig_inscr = it.inscription
  local dps_inscr = BRC.get.weapon_stats(it, BRC.DMG_TYPE[BRC.Config.inscribe_dps_type])
  local prefix, suffix = "", ""

  local idx = orig_inscr:find("DPS:", 1, true)
  if idx then
    if idx > 1 then prefix = orig_inscr:sub(1, idx - 1) .. "; " end
    if idx + #dps_inscr - 1 < #orig_inscr then suffix = orig_inscr:sub(idx + #dps_inscr, #orig_inscr) end
  elseif #orig_inscr > 0 then
    suffix = "; " .. orig_inscr
  end

  it.inscribe(table.concat({ prefix, dps_inscr, suffix }), false)
end

-- Hook functions
function f_inscribe_stats.do_stat_inscription(it)
  -- NOTE: It is important that other features do not meddle with the inscription; e.g. adding color tags
  if BRC.Config.inscribe_weapons and it.is_weapon then
    inscribe_weapon_stats(it)
  elseif BRC.Config.inscribe_armour and BRC.is.armour(it) and not BRC.is.scarf(it) then
    inscribe_armour_stats(it)
  end
end

function f_inscribe_stats.ready()
  for inv in iter.invent_iterator:new(items.inventory()) do
    f_inscribe_stats.do_stat_inscription(inv)
  end
end

}
############################### End lua/features/inscribe-stats.lua ###############################
##########################################################################################

################################### Begin lua/features/misc-alerts.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: misc-alerts
Description: Provides various single-purpose alerts: low HP, faith amulet, and spell level changes
Author: orig save w/msg by gammafunk, buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_misc_alerts = {}
f_misc_alerts.BRC_FEATURE_NAME = "misc-alerts"

-- Persistent variables
ma_alerted_max_piety = BRC.data.persist("ma_alerted_max_piety", false)
ma_prev_spell_levels = BRC.data.persist("ma_prev_spell_levels", 0)
ma_saved_msg = BRC.data.persist("ma_saved_msg", "")

-- Local constants / configuration
local REMOVE_FAITH_MSG = "6 star piety! Maybe ditch that amulet soon."

-- Local variables
local below_hp_threshold

-- Local functions
local function alert_low_hp()
  local hp, mhp = you.hp()
  if below_hp_threshold then
    below_hp_threshold = hp ~= mhp
  elseif hp <= BRC.Config.alert_low_hp_threshold * mhp then
    below_hp_threshold = true
    local low_hp_msg = string.format(" Dropped below %s%% HP ", 100 * BRC.Config.alert_low_hp_threshold)
    BRC.mpr.que_optmore(true, BRC.Emoji.EXCLAMATION .. BRC.text.magenta(low_hp_msg) .. BRC.Emoji.EXCLAMATION)
  end
end

local function alert_remove_faith()
  if not ma_alerted_max_piety and you.piety_rank() == 6 then
    local am = items.equipped_at("amulet")
    if am and am.subtype() == "amulet of faith" and not am.artefact then
      if you.god() == "Uskayaw" then return end
      BRC.mpr.more(REMOVE_FAITH_MSG, BRC.COLORS.lightcyan)
      ma_alerted_max_piety = true
    end
  end
end

local function alert_spell_level_changes()
  local new_spell_levels = you.spell_levels()
  if new_spell_levels > ma_prev_spell_levels then
    local delta = new_spell_levels - ma_prev_spell_levels
    local msg = string.format("Gained %s spell level%s", delta, delta > 1 and "s" or "")
    local avail = string.format(" (%s available)", new_spell_levels)
    BRC.mpr.lightcyan(msg .. BRC.text.cyan(avail))
  elseif new_spell_levels < ma_prev_spell_levels then
    BRC.mpr.magenta(string.format("%s spell levels remaining", new_spell_levels))
  end

  ma_prev_spell_levels = new_spell_levels
end

-- Macro function: Save with message feature
function macro_f_misc_alerts_save_with_message()
  if not BRC.active then return BRC.util.do_cmd("CMD_SAVE_GAME_NOW") end

  if not BRC.mpr.yesno("Save game and exit?", BRC.COLORS.lightcyan) then
    BRC.mpr.okay()
    return
  end

  crawl.formatted_mpr("Leave a message: ", "prompt")
  ma_saved_msg = crawl.c_input_line()
  BRC.util.do_cmd("CMD_SAVE_GAME_NOW")
end

-- Hook functions
function f_misc_alerts.init()
  ma_prev_spell_levels = you.spell_levels()
  below_hp_threshold = false

  if BRC.Config.save_with_msg then
    BRC.set.macro(BRC.get.command_key("CMD_SAVE_GAME") or "S", "macro_f_misc_alerts_save_with_message")
    if ma_saved_msg and ma_saved_msg ~= "" then
      BRC.mpr.white(string.format("MESSAGE: %s", ma_saved_msg))
      ma_saved_msg = nil
    end
  end
end

function f_misc_alerts.ready()
  if BRC.Config.alert_remove_faith then alert_remove_faith() end
  if BRC.Config.alert_low_hp_threshold > 0 then alert_low_hp() end
  if BRC.Config.alert_spell_level_changes then alert_spell_level_changes() end
end

}
############################### End lua/features/misc-alerts.lua ###############################
##########################################################################################

################################### Begin lua/features/remind-id.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: remind-id
Description: Reminds to read ID scrolls, and stops explore on increased stack sizes before finding ID scrolls
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_remind_id = {}
f_remind_id.BRC_FEATURE_NAME = "remind-id"

-- Persistent variables
ri_found_scroll_of_id = BRC.data.persist("ri_found_scroll_of_id", false)

-- Local constants / configuration
local IDENTIFY_MSG = BRC.text.magenta(" You have something to identify. ")
if BRC.Emoji.REMIND_ID then IDENTIFY_MSG = BRC.Emoji.REMIND_ID .. IDENTIFY_MSG .. BRC.Emoji.REMIND_ID end

-- Local variables
local do_remind_id_check

-- Local functions
local function get_max_stack(class)
  local max_stack_size = 0
  local slot = nil
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.class(true) == class and not inv.is_identified then
      if inv.quantity > max_stack_size then
        max_stack_size = inv.quantity
        slot = inv.slot
      elseif inv.quantity == max_stack_size then
        slot = nil -- If tied for max, no slot set a new max
      end
    end
  end
  return max_stack_size, slot
end

local function have_scroll_of_id()
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.name("qual") == "scroll of identify" then return true end
  end
  return false
end

local function have_unid_item()
  for inv in iter.invent_iterator:new(items.inventory()) do
    if not inv.is_identified then return true end
  end
  return false
end

-- Hook functions
function f_remind_id.init()
  do_remind_id_check = true
end

function f_remind_id.c_assign_invletter(it)
  if not it.is_identified and have_scroll_of_id() or it.name("qual") == "scroll of identify" and have_unid_item() then
    you.stop_activity()
    do_remind_id_check = true
  end
end

function f_remind_id.c_message(text, channel)
  if channel ~= "plain" then return end

  if text:find("scrolls? of identify") then
    ri_found_scroll_of_id = true
    if not text:find("ou drop ", 1, true) and have_unid_item() then
      you.stop_activity()
      do_remind_id_check = true
    end
  elseif not ri_found_scroll_of_id then
    local pickup_info = BRC.text.get_pickup_info(text)
    if not pickup_info then return end
    local is_scroll = pickup_info.item:find("scroll", 1, true)
    local is_potion = pickup_info.item:find("potion", 1, true)
    if not (is_scroll or is_potion) then return end

    local num_scrolls, slot_scrolls = get_max_stack("scroll")
    local num_pots, slot_pots = get_max_stack("potion")
    if is_scroll and num_scrolls >= BRC.Config.stop_on_scrolls_count and slot_scrolls == pickup_info.slot
      or is_potion and num_pots >= BRC.Config.stop_on_pots_count and slot_pots == pickup_info.slot then
        you.stop_activity()
    end
  end
end

function f_remind_id.ready()
  if do_remind_id_check then
    do_remind_id_check = false
    if have_unid_item() and have_scroll_of_id() then BRC.mpr.stop(IDENTIFY_MSG) end
  end
end

}
############################### End lua/features/remind-id.lua ###############################
##########################################################################################

################################### Begin lua/features/runrest-features.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: runrest-features
Description: Simple features related to auto-explore stops: altars, gauntlets, portals, stairs, etc
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_runrest_features = {}
f_runrest_features.BRC_FEATURE_NAME = "runrest-features"

-- Persistent variables
rr_autosearched_temple = BRC.data.persist("rr_autosearched_temple", false)
rr_autosearched_gauntlet = BRC.data.persist("rr_autosearched_gauntlet", false)

-- Local constants / configuration
local GAUNTLET_CONCAT_STRING = " && !!"
local GAUNTLET_SEARCH_STRING = table.concat(
  { "gauntlet", "gate leading", "a transporter", "gold piece", " trap", "translucent door", "translucent gate" },
  GAUNTLET_CONCAT_STRING
)

-- Local variables
local stop_on_altars
local stop_on_portals
local stop_on_stairs

-- Local functions
local function is_explore_done_msg(text)
  local cleaned = BRC.text.clean_text(text)
  return cleaned == "Done exploring." or cleaned:find("Partly explored, ", 1, true) == 1
end

-- Altar and religion functions
local function religion_is_handled()
  if you.race() == "Demigod" then return true end
  if you.god() == "No God" then return false end
  if you.good_god() then return you.xl() > 9 end
  return true
end

local function ready_ignore_altars()
  if stop_on_altars and religion_is_handled() then
    stop_on_altars = false
    BRC.set.explore_stop("altars", false)
  elseif not stop_on_altars and not religion_is_handled() then
    stop_on_altars = true
    BRC.set.explore_stop("altars", true)
  end
end

-- Temple-related functions
local function search_altars()
  local cmd_key = BRC.get.command_key("CMD_SEARCH_STASHES") or BRC.util.control_key("f")
  crawl.sendkeys({ cmd_key, "altar", BRC.KEYS.CR })
end

local function ready_temple_macro()
  if you.branch() == "Temple" and not rr_autosearched_temple then
    search_altars()
    rr_autosearched_temple = true
  end
end

local function c_message_temple(text, _)
  if you.branch() == "Temple" then
    -- Search again after explore
    if is_explore_done_msg(text) then search_altars() end
  end
end

-- Gauntlet-related functions
local function search_gauntlet()
  local cmd_key = BRC.get.command_key("CMD_SEARCH_STASHES") or BRC.util.control_key("f")
  crawl.sendkeys({ cmd_key, GAUNTLET_SEARCH_STRING, BRC.KEYS.CR })
end

local function ready_gauntlet_macro()
  if you.branch() == "Gauntlet" and not rr_autosearched_gauntlet then
    search_gauntlet()
    rr_autosearched_gauntlet = true
  end
end

local function c_message_gauntlet(text, _)
  -- Search again after explore
  if you.branch() == "Gauntlet" then
    if is_explore_done_msg(text) then search_gauntlet() end
  end
end

-- Stairs and branch-specific functions
local function ready_ignore_portals()
  if stop_on_portals and util.contains(BRC.PORTAL_NAMES, you.branch()) then
    stop_on_portals = false
    BRC.set.explore_stop("portals", false)
  elseif not stop_on_portals and not util.contains(BRC.PORTAL_NAMES, you.branch()) then
    stop_on_portals = true
    BRC.set.explore_stop("portals", true)
  end
end

local function ready_stop_on_stairs_in_pan_or_hell()
  local should_be_active = BRC.Config.stop_on_pan_gates and you.branch() == "Pan"
    or BRC.Config.stop_on_hell_stairs and BRC.you.in_hell(true)
  if stop_on_stairs and not should_be_active then
    stop_on_stairs = false
    BRC.set.explore_stop("stairs", false)
  elseif not stop_on_stairs and should_be_active then
    stop_on_stairs = true
    BRC.set.explore_stop("stairs", true)
  end
end

-- Hook functions
function f_runrest_features.init()
  stop_on_altars = true
  stop_on_portals = true
  stop_on_stairs = false
end

function f_runrest_features.c_message(text, _)
  if BRC.Config.temple_macros then c_message_temple(text) end
  if BRC.Config.gauntlet_macros then c_message_gauntlet(text) end
end

function f_runrest_features.ready()
  if BRC.Config.ignore_altars then ready_ignore_altars() end
  if BRC.Config.ignore_portal_exits then ready_ignore_portals() end
  if BRC.Config.temple_macros then ready_temple_macro() end
  if BRC.Config.gauntlet_macros then ready_gauntlet_macro() end
  ready_stop_on_stairs_in_pan_or_hell()
end

}
############################### End lua/features/runrest-features.lua ###############################
##########################################################################################

################################### Begin lua/features/safe-consumables.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: safe-consumables
Description: Automatically manages !q and !r inscriptions. An upgrade to using autoinscribe.
Author: buehler
Dependencies: core/config.lua, core/util.lua
--]]

f_safe_consumables = {}
f_safe_consumables.BRC_FEATURE_NAME = "safe-consumables"

-- Local constants
local NO_INSCRIPTION_NEEDED = {
  "acquirement", "amnesia", "blinking", "brand weapon", "enchant armour", "enchant weapon", "identify",
  "immolation", "noise", "vulnerability", "attraction", "lignification", "mutation",
} -- NO_INSCRIPTION_NEEDED (do not remove this comment)

-- Hook functions
function f_safe_consumables.ready()
  if not BRC.Config.safe_consumables then return end
  -- Remove the default "!r" and "!q" inscriptions after identify
  for inv in iter.invent_iterator:new(items.inventory()) do
    local inv_class = inv.class(true)
    local st = inv.subtype()
    if inv_class == "scroll" then
      if
        (st == "poison" and you.res_poison() > 0)
        or (st == "torment" and you.torment_immune())
        or util.contains(NO_INSCRIPTION_NEEDED, st)
      then
        if inv.inscription:find("!r", 1, true) then inv.inscribe(inv.inscription:gsub("%!r", ""), false) end
      elseif not inv.inscription:find("!r", 1, true) then
        inv.inscribe("!r")
      end
    elseif inv_class == "potion" then
      if util.contains(NO_INSCRIPTION_NEEDED, st) then
        if inv.inscription:find("!q", 1, true) then inv.inscribe(inv.inscription:gsub("%!q", ""), false) end
      elseif not inv.inscription:find("!q", 1, true) then
        inv.inscribe("!q")
      end
    end
  end
end

}
############################### End lua/features/safe-consumables.lua ###############################
##########################################################################################

################################### Begin lua/features/safe-stairs.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: safe-stairs
Description: Prevents accidental stairs use by warning about backtracking and dangerous locations like Vaults:5
Author: buehler, rypofalem (V5 warning idea)
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_safe_stairs = {}
f_safe_stairs.BRC_FEATURE_NAME = "safe-stairs"

-- Persistent variables
ss_prev_location = BRC.data.persist("ss_prev_location", "")
ss_cur_location = BRC.data.persist("ss_cur_location", "")
ss_last_stair_turn = BRC.data.persist("ss_last_stair_turn", 0)
ss_v5_unwarned = BRC.data.persist("ss_v5_unwarned", true)

-- Local functions
local function check_new_location(cmd)
  if not BRC.active then return BRC.util.do_cmd(cmd) end

  local feature = view.feature_at(0, 0)
  local one_way_stair = feature:find("escape_hatch", 1, true) or feature:find("shaft", 1, true)

  local turn_diff = you.turns() - ss_last_stair_turn
  if ss_prev_location ~= ss_cur_location and turn_diff > 0 and turn_diff < BRC.Config.warn_stairs_threshold then
    if cmd == "CMD_GO_DOWNSTAIRS" then
      if not (feature:find("down", 1, true) or feature:find("shaft", 1, true)) then
        BRC.util.do_cmd(cmd)
        return
      end
    else
      if not feature:find("up", 1, true) then
        BRC.util.do_cmd(cmd)
        return
      end
    end

    if not BRC.mpr.yesno("Really go right back?") then
      BRC.mpr.okay()
      return
    end
  elseif BRC.Config.warn_v5 and ss_v5_unwarned and ss_cur_location == "Vaults4" and cmd == "CMD_GO_DOWNSTAIRS" then
    if feature:find("down", 1, true) or feature:find("shaft", 1, true) then
      if not BRC.mpr.yesno("Really go to Vaults:5?") then
        BRC.mpr.okay()
        return
      end
      ss_v5_unwarned = false
    end
  end

  BRC.util.do_cmd(cmd)
  if not one_way_stair then ss_last_stair_turn = you.turns() end
end

-- Macro functions
function macro_f_safe_stairs_down()
  check_new_location("CMD_GO_DOWNSTAIRS")
end

function macro_f_safe_stairs_up()
  check_new_location("CMD_GO_UPSTAIRS")
end

-- Hook functions
function f_safe_stairs.init()
  ss_prev_location = you.branch() .. you.depth()
  ss_cur_location = you.branch() .. you.depth()
  ss_last_stair_turn = 0
  ss_v5_unwarned = true

  BRC.set.macro(BRC.get.command_key("CMD_GO_DOWNSTAIRS") or ">", "macro_f_safe_stairs_down")
  BRC.set.macro(BRC.get.command_key("CMD_GO_UPSTAIRS") or "<", "macro_f_safe_stairs_up")
end

function f_safe_stairs.ready()
  ss_prev_location = ss_cur_location
  ss_cur_location = you.branch() .. you.depth()
end

}
############################### End lua/features/safe-stairs.lua ###############################
##########################################################################################

################################### Begin lua/features/startup.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: startup
Description: Handles startup features like skill menu display and auto-setting skill targets
Author: rwbarton, buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
--]]

f_startup = {}
f_startup.BRC_FEATURE_NAME = "startup"

-- Hook functions
function f_startup.ready()
  if you.turns() == 0 then
    if BRC.Config.show_skills_on_startup then
      local show_skills_on_startup = (you.race() ~= "Gnoll" or you.class() == "Wanderer")
      if show_skills_on_startup then BRC.util.do_cmd("CMD_DISPLAY_SKILLS") end
    end

    ---- Auto-set default skill targets ----
    if BRC.Config.auto_set_skill_targets then
      for _, skill_target in ipairs(BRC.Config.auto_set_skill_targets) do
        local skill, target = unpack(skill_target)
        if you.skill(skill) < target then
          for _, s in ipairs(BRC.TRAINING_SKILLS) do
            you.train_skill(s, 0)
          end
          you.set_training_target(skill, target)
          you.train_skill(skill, 2)
          break
        end
      end
    end
  end
end

}
############################### End lua/features/startup.lua ###############################
##########################################################################################

################################### Begin lua/features/weapon-slots.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: weapon-slots
Description: Automatically moves weapons to slots a, b, and w with intelligent priority-based organization
Author: buehler
Dependencies: core/config.lua, core/util.lua
--]]

f_weapon_slots = {}
f_weapon_slots.BRC_FEATURE_NAME = "weapon-slots"

-- Local variables
local do_cleanup_weapon_slots
local priorities_ab
local priorities_w
local slots_changed

-- Local functions
local function get_first_empty_slot()
  for slot = 1, 52 do
    if #BRC.get.items_in_slot(slot) == 0 then return slot end
  end
end

local function get_priority_ab(it)
  if not it.is_weapon then return -1 end
  if it.equipped then return 1 end

  if BRC.is.magic_staff(it) then return 3 end
  if it.is_ranged then return (you.skill("Ranged Weapons") >= 4) and 2 or 5 end
  if BRC.is.polearm(it) then return (you.skill("Polearms") >= 4) and 2 or 4 end
  return 2
end

local function get_priority_w(it)
  if not it.is_weapon then return -1 end
  if it.is_ranged then return 1 end
  if BRC.is.polearm(it) then return 2 end
  if BRC.is.magic_staff(it) then return 3 end
  return 4
end

local function generate_priorities()
  priorities_ab = { -1, -1, -1, -1, -1 }
  priorities_w = { -1, -1, -1, -1 }

  for inv in iter.invent_iterator:new(items.inventory()) do
    local p = get_priority_w(inv)
    if p > 0 then
      if priorities_w[p] == -1 then
        priorities_w[p] = inv.slot
      else
        priorities_w[p + 1] = inv.slot
      end
    end

    p = get_priority_ab(inv)
    if p > 0 then
      if priorities_ab[p] == -1 then
        priorities_ab[p] = inv.slot
      else
        priorities_ab[p + 1] = inv.slot
      end
    end
  end
end

local function cleanup_ab(slot)
  local inv_items = BRC.get.items_in_slot(slot)
  for _, inv in ipairs(inv_items) do
    if inv.is_weapon then return end
  end

  for p = 1, #priorities_ab do
    if priorities_ab[p] > slot then -- Not from earlier slot
      items.swap_slots(priorities_ab[p], slot)
      slots_changed = true
      priorities_ab[p] = -1
      return
    end
  end
end

local function cleanup_w()
  local slot_w = items.letter_to_index("w")
  local inv_items = BRC.get.items_in_slot(slot_w)
  for _, inv in ipairs(inv_items) do
    if inv.is_weapon then return end
  end

  for p = 1, #priorities_w do
    if priorities_w[p] > 1 then -- Not from slots a or b
      items.swap_slots(priorities_w[p], slot_w)
      slots_changed = true
      return
    end
  end
end

local function cleanup_weapon_slots()
  generate_priorities()
  cleanup_ab(0)
  cleanup_ab(1)
  cleanup_w()
end

-- Hook functions
function f_weapon_slots.init()
  do_cleanup_weapon_slots = false
  slots_changed = false
  priorities_ab = nil
  priorities_w = nil
end

function f_weapon_slots.c_assign_invletter(it)
  if not BRC.Config.do_auto_weapon_slots_abw then return end
  if not it.is_weapon then return end

  for _, i in ipairs({ "a", "b", "w" }) do
    local slot = items.letter_to_index(i)
    local inv_items = BRC.get.items_in_slot(slot)
    if #inv_items == 0 then return slot end

    local any_are_weapon = false
    for _, inv in ipairs(inv_items) do
      if inv.is_weapon then any_are_weapon = true break end
    end
    if not any_are_weapon then
      items.swap_slots(slot, get_first_empty_slot())
      slots_changed = true
      return slot
    end
  end
end

function f_weapon_slots.c_message(text, channel)
  if not BRC.Config.do_auto_weapon_slots_abw then return end
  do_cleanup_weapon_slots = channel == "plain" and text:find("ou drop ", 1, true)
end

function f_weapon_slots.ready()
  if do_cleanup_weapon_slots then
    cleanup_weapon_slots()
    do_cleanup_weapon_slots = false
    if slots_changed then
      BRC.mpr.darkgrey("Weapon slots updated (ab+w).")
      crawl.redraw_screen()
      slots_changed = false
    end
  end
end

}
############################### End lua/features/weapon-slots.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

### Pickup and alert ###

################################### Begin lua/features/pickup-alert/pa-main.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert
Description: Comprehensive pickup and alert system for weapons, armour, and miscellaneous items
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua,
  pa-armour.lua, pa-data.lua, pa-misc.lua, pa-weapons.lua
--]]

f_pickup_alert = {}
f_pickup_alert.BRC_FEATURE_NAME = "pickup-alert"

-- Persistent variables
pa_num_autopickup_funcs = BRC.data.persist("pa_num_autopickup_funcs", #chk_force_autopickup + 1)

-- Local variables
local pause_pa_system

-- Local functions
local function has_configured_force_more(it)
  if it.artefact then
    if BRC.Config.fm_alert.artefact then return true end
    if BRC.Config.fm_alert.trained_artefacts and BRC.get.skill_with(it) > 0 then return true end
  end
  if BRC.Config.fm_alert.armour_ego and BRC.is.armour(it) and BRC.get.ego(it) then return true end
  return false
end

-- Public API
function f_pickup_alert.autopickup(it, _)
  local unworn_aux_item = nil -- Conditionally set below for pa-alert-armour
  if pause_pa_system then return end
  if you.have_orb() then return end
  if BRC.get.ego(it) and not it.is_identified then return false end
  if not it.is_useless then
    if f_pa_armour and BRC.Config.pickup.armour and BRC.is.armour(it) then
      if f_pa_armour.pickup_armour(it) then return true end
    elseif f_pa_misc and BRC.Config.pickup.staves and BRC.is.magic_staff(it) then
      if f_pa_misc.pickup_staff(it) then return true end
    elseif f_pa_weapons and BRC.Config.pickup.weapons and it.is_weapon then
      if f_pa_weapons.pickup_weapon(it) then return true end
    elseif f_pa_misc and f_pa_misc.is_unneeded_ring(it) then
      return false
    end
  else
    -- Useless item; allow alerts for aux armour if you're carrying one (implies a temporary mutation)
    if BRC.is.aux_armour(it) then return end

    local st = it.subtype()
    for inv in iter.invent_iterator:new(items.inventory()) do
      local inv_st = inv.subtype()
      if inv_st and inv_st == st then
        unworn_aux_item = inv
        break
      end
    end
    if not unworn_aux_item then return end
  end

  -- Not picking up this item. Now check for alerts.
  if not BRC.Config.alert.system_enabled or f_pa_data.find(pa_items_alerted, it) then return end

  if f_pa_misc and BRC.Config.alert.one_time and #BRC.Config.alert.one_time > 0 then
    if f_pa_misc.alert_OTA(it) then return end
  end

  if f_pa_misc and BRC.Config.alert.staff_resists and BRC.is.magic_staff(it) then
    if f_pa_misc.alert_staff(it) then return end
  elseif f_pa_misc and BRC.Config.alert.orbs and BRC.is.orb(it) then
    if f_pa_misc.alert_orb(it) then return end
  elseif f_pa_misc and BRC.Config.alert.talismans and BRC.is.talisman(it) then
    if f_pa_misc.alert_talisman(it) then return end
  elseif f_pa_armour and BRC.Config.alert.armour and BRC.is.armour(it) then
    if f_pa_armour.alert_armour(it, unworn_aux_item) then return end
  elseif f_pa_weapons and BRC.Config.alert.weapons and it.is_weapon then
    if f_pa_weapons.alert_weapon(it) then return end
  end
end

function f_pickup_alert.do_alert(it, alert_type, emoji, force_more)
  local item_name = f_pa_data.get_keyname(it, true)
  local alert_col
  if it.is_weapon then
    alert_col = BRC.AlertColor.weapon
    f_pa_data.update_high_scores(it)
    local weapon_info = string.format(" (%s)", BRC.get.weapon_stats(it))
    item_name = item_name .. BRC.text.color(BRC.AlertColor.weapon.stats, weapon_info)
  elseif BRC.is.body_armour(it) then
    alert_col = BRC.AlertColor.body_arm
    f_pa_data.update_high_scores(it)
    local ac, ev = BRC.get.armour_stats(it)
    local armour_info = string.format(" {%s, %s}", ac, ev)
    item_name = item_name .. BRC.text.color(BRC.AlertColor.body_arm.stats, armour_info)
  elseif BRC.is.armour(it) then
    alert_col = BRC.AlertColor.aux_arm
  elseif BRC.is.orb(it) then
    alert_col = BRC.AlertColor.orb
  elseif BRC.is.talisman(it) then
    alert_col = BRC.AlertColor.talisman
  else
    alert_col = BRC.AlertColor.misc
  end

  local tokens = {}
  tokens[1] = emoji and emoji or BRC.text.cyan("----")
  tokens[#tokens + 1] = BRC.text.color(alert_col.desc, string.format(" %s:", alert_type))
  tokens[#tokens + 1] = BRC.text.color(alert_col.item, string.format(" %s ", item_name))
  tokens[#tokens + 1] = tokens[1]
  BRC.mpr.que_optmore(force_more or has_configured_force_more(it), table.concat(tokens))

  f_pa_data.insert(pa_recent_alerts, it)
  f_pa_data.insert(pa_items_alerted, it)
  you.stop_activity()
  return true
end

-- Hook functions
function f_pickup_alert.init()
  BRC.log.debug("Initializing pickup-alert submodules...")
  local indent = "  "
  pause_pa_system = false
  f_pa_data.init()
  BRC.log.debug(indent .. "pa-data loaded")

  if f_pa_armour then
    if f_pa_armour.init then f_pa_armour.init() end
    BRC.log.debug(indent .. "pa-armour loaded")
  end

  if f_pa_weapons then
    if f_pa_weapons.init then f_pa_weapons.init() end
    BRC.log.debug(indent .. "pa-weapons loaded")
  end

  if f_pa_misc then
    if f_pa_misc.init then f_pa_misc.init() end
    BRC.log.debug(indent .. "pa-misc loaded")
  end

  -- Check for duplicate autopickup creation (affects local only)
  if pa_num_autopickup_funcs < #chk_force_autopickup then
    BRC.log.warning(table.concat({
      "Warning: Extra autopickup funcs detected. (Commonly from reloading a local game.)\n",
      "Expected: ", pa_num_autopickup_funcs, " but got: ", #chk_force_autopickup, "\n",
      "If this is not expected, restart crawl to clear its memory."
    }))
    if not BRC.mpr.yesno("Continue adding BRC autopickup function?") then
      BRC.log.info("Skipping BRC autopickup function.")
      return
    end
  end

  pa_num_autopickup_funcs = #chk_force_autopickup
end

function f_pickup_alert.c_assign_invletter(it)
  f_pa_misc.alert_OTA(it)
  f_pa_data.remove(pa_recent_alerts, it)
  if it.is_weapon and you.race() == "Coglin" then
    -- Allow 1 more alert for an identical weapon, if dual-wielding possible.
    -- ie, Reset the alert the first time you pick up.
    if f_pa_data.find(pa_items_picked, it) then f_pa_data.remove(pa_items_alerted, it) end
  end

  f_pa_data.insert(pa_items_picked, it)

  if it.is_weapon or BRC.is.armour(it) then
    f_pa_data.update_high_scores(it)
    you.stop_activity() -- crawl misses this sometimes
  end
end

function f_pickup_alert.c_message(text, channel)
  if channel == "multiturn" then
    if not pause_pa_system and text:find("ou start ", 1, true) then pause_pa_system = true end
  elseif channel == "plain" then
    if pause_pa_system and (text:find("ou stop ", 1, true) or text:find("ou finish ", 1, true)) then
      pause_pa_system = false
    elseif text:find("one exploring", 1, true) or text:find("artly explored", 1, true) then
      local tokens = { "Recent alerts:" }
      for _, v in ipairs(pa_recent_alerts) do
        tokens[#tokens + 1] = string.format("\n  %s", v)
      end
      if #tokens > 1 then BRC.mpr.que(table.concat(tokens), BRC.COLORS.magenta) end
      pa_recent_alerts = {}
    end
  end
end

function f_pickup_alert.ready()
  if pause_pa_system then return end
  f_pa_weapons.ready()
  f_pa_data.update_high_scores(items.equipped_at("armour"))
end

}
############################### End lua/features/pickup-alert/pa-main.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-data
Description: Data management and persistent storage for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_pa_data = {}
--f_pa_data.BRC_FEATURE_NAME = "pickup-alert-data"

-- Persistent variables
pa_items_picked = BRC.data.persist("pa_items_picked", {})
pa_items_alerted = BRC.data.persist("pa_items_alerted", {})
pa_recent_alerts = BRC.data.persist("pa_recent_alerts", {})
pa_OTA_items = BRC.data.persist("pa_OTA_items", BRC.Config.alert.one_time)
pa_high_score = BRC.data.persist("pa_high_score", { ac = 0, weapon = 0, plain_dmg = 0 })

-- Local functions
local function get_pa_keys(it, use_plain_name)
  if it.class(true) == "bauble" then
    return it.name("qual"):gsub('"', ""), 0
  elseif BRC.is.talisman(it) or BRC.is.orb(it) then
    return it.name():gsub('"', ""), 0
  elseif BRC.is.magic_staff(it) then
    return it.name("base"):gsub('"', ""), 0
  else
    local name = it.name(use_plain_name and "plain" or "base"):gsub('"', "")
    local value = tonumber(name:sub(1, 3))
    if not value then return name, 0 end
    return util.trim(name:sub(4)), value
  end
end

-- Public API
-- Return name of first entry found in item name, or nil if not found
function f_pa_data.find(table_ref, it)
  if table_ref == pa_OTA_items then
    local qualname = it.name("qual")
    for _, v in ipairs(pa_OTA_items) do
      if v and qualname:find(v) then return v end
    end
  else
    local name, value = get_pa_keys(it)
    if table_ref[name] ~= nil and tonumber(table_ref[name]) >= value then return name end
  end
end

function f_pa_data.insert(table_ref, it)
  if table_ref == pa_recent_alerts then
    pa_recent_alerts[#pa_recent_alerts + 1] = f_pa_data.get_keyname(it)
  elseif it.is_weapon or BRC.is.armour(it, true) or BRC.is.talisman(it) then
    local name, value = get_pa_keys(it)
    local cur_val = tonumber(table_ref[name])
    if not cur_val or value > cur_val then table_ref[name] = value end
  end
end

function f_pa_data.remove(table_ref, it)
  if table_ref == pa_OTA_items then
    repeat
      local item_name = f_pa_data.find(pa_OTA_items, it)
      if item_name == nil then return end
      util.remove(pa_OTA_items, item_name)
    until item_name == nil
  elseif table_ref == pa_recent_alerts then
    util.remove(pa_recent_alerts, f_pa_data.get_keyname(it))
  else
    local name, _ = get_pa_keys(it)
    util.remove(table_ref, name)
  end
end

-- Get name with plus included and quotes removed; stored in pa_recent_alerts table
function f_pa_data.get_keyname(it, use_plain_name)
  local name, value = get_pa_keys(it, use_plain_name)
  if BRC.is.talisman(it) or BRC.is.orb(it) or BRC.is.magic_staff(it) then return name end
  if value >= 0 then value = string.format("+%s", value) end
  return string.format("%s %s", value, name)
end

-- Returns a string of the high score type if item sets a new high score, else nil
function f_pa_data.update_high_scores(it)
  if not it then return end
  local ret_val = nil

  if BRC.is.armour(it) then
    local ac = BRC.get.armour_ac(it)
    if ac > pa_high_score.ac then
      pa_high_score.ac = ac
      if not ret_val then ret_val = "Highest AC" end
    end
  elseif it.is_weapon then
    -- Don't alert for unusable weapons
    if BRC.get.hands(it) == 2 and not BRC.you.free_offhand() then return end

    local dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.branded)
    if dmg > pa_high_score.weapon then
      pa_high_score.weapon = dmg
      if not ret_val then ret_val = "Highest damage" end
    end

    dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.plain)
    if dmg > pa_high_score.plain_dmg then
      pa_high_score.plain_dmg = dmg
      if not ret_val then ret_val = "Highest plain damage" end
    end
  end

  return ret_val
end

-- Hook functions
function f_pa_data.init()
  -- Update alerts & tables for starting items
  for inv in iter.invent_iterator:new(items.inventory()) do
    f_pa_data.remove(pa_OTA_items, inv)
    f_pa_data.insert(pa_items_picked, inv)
  end
end

}
############################### End lua/features/pickup-alert/pa-data.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-armour.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-armour
Description: Armour pickup logic and alert system for the pickup-alert system
Author: Original Equipment autopickup by Medar, gammafunk, and various others. Extended by buehler.
Dependencies: core/config.lua, core/data.lua, core/constants.lua, core/util.lua
--]]

f_pa_armour = {}
--f_pa_armour.BRC_FEATURE_NAME = "pickup-alert-armour"

-- Local constants / configuration
local ENCUMB_ARMOUR_DIVISOR = 2 -- Encumbrance penalty is offset by (Armour / ENCUMB_ARMOUR_DIVISOR)
local SAME = "same_ego"
local LOST = "lost_ego"
local GAIN = "gain_ego"
local DIFF = "diff_ego"
local HEAVIER = "heavier"
local LIGHTER = "lighter"

local ARMOUR_ALERT = {
  artefact = { msg = "Artefact armour", emoji = BRC.Emoji.ARTEFACT },
  [GAIN] = { msg = "Gain ego", emoji = BRC.Emoji.EGO },
  [DIFF] = { msg = "Diff ego", emoji = BRC.Emoji.EGO },
  [LIGHTER] = {
    [GAIN] = { msg = "Gain ego (Lighter armour)", emoji = BRC.Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Lighter armour)", emoji = BRC.Emoji.EGO },
    [SAME] = { msg = "Lighter armour", emoji = BRC.Emoji.LIGHTER },
    [LOST] = { msg = "Lighter armour (Lost ego)", emoji = BRC.Emoji.LIGHTER },
  },
  [HEAVIER] = {
    [GAIN] = { msg = "Gain ego (Heavier armour)", emoji = BRC.Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Heavier armour)", emoji = BRC.Emoji.EGO },
    [SAME] = { msg = "Heavier Armour", emoji = BRC.Emoji.HEAVIER },
    [LOST] = { msg = "Heavier Armour (Lost ego)", emoji = BRC.Emoji.HEAVIER },
  }, -- ARMOUR_ALERT.heavier (do not remove this comment)
} -- ARMOUR_ALERT (do not remove this comment)

-- Local functions
local function aux_slot_is_impaired(it)
  local st = it.subtype()
  -- Skip boots/gloves/helmet if wearing Lear's hauberk
  local worn = items.equipped_at("armour")
  if worn and worn.name("qual") == "Lear's hauberk" and st ~= "cloak" then return true end

  -- Mutation interference
  if st == "gloves" then
    return BRC.get.mut(BRC.MUTATIONS.demonic_touch, true) >= 3 and not BRC.you.free_offhand()
        or BRC.get.mut(BRC.MUTATIONS.claws, true) > 0 and not items.equipped_at("weapon")
  elseif st == "boots" then
    return BRC.get.mut(BRC.MUTATIONS.hooves, true) > 0
        or BRC.get.mut(BRC.MUTATIONS.talons, true) > 0
  elseif it.name("base"):find("helmet", 1, true) then
    return BRC.get.mut(BRC.MUTATIONS.horns, true) > 0
        or BRC.get.mut(BRC.MUTATIONS.beak, true) > 0
        or BRC.get.mut(BRC.MUTATIONS.antennae, true) > 0
  end

  return false
end

local function get_adjusted_ev_delta(encumb_delta, ev_delta)
  local encumb_skills = you.skill("Spellcasting")
    + you.skill("Ranged Weapons")
    - you.skill("Armour") / ENCUMB_ARMOUR_DIVISOR
  local encumb_impact = encumb_skills / you.xl()
  encumb_impact = math.max(0, math.min(1, encumb_impact)) -- Clamp to 0-1

  -- Subtract weighted encumbrance penalty, to align with ev_delta (negative == heavier)
  return ev_delta - encumb_delta * encumb_impact * BRC.Tuning.armour.encumb_penalty_weight
end

local function get_ego_change_type(cur_ego, it_ego)
  if it_ego == cur_ego then
    return SAME
  elseif not it_ego then
    return LOST
  elseif not cur_ego then
    return GAIN
  else
    return DIFF
  end
end

local function is_new_ego(ego_change)
  return ego_change == GAIN or ego_change == DIFF
end

local function send_armour_alert(it, alert_type)
  return f_pickup_alert.do_alert(it, alert_type.msg, alert_type.emoji, BRC.Config.fm_alert.body_armour)
end

-- Local functions: Pickup
local function pickup_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end -- surely am naked for a reason

  -- No pickup if either item is an artefact
  if cur.artefact or it.artefact then return false end

  -- No pickup if adding encumbrance or losing AC
  local encumb_delta = it.encumbrance - cur.encumbrance
  if encumb_delta > 0 then return false end

  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  if ac_delta < 0 then return false end

  -- Pickup: Diff ego, Gain AC (w/o losing ego), Lower encumbrance (w/o losing ego)
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if cur_ego then
    if not it_ego then return false end
    return it_ego ~= cur_ego or ac_delta > 0 or encumb_delta < 0
  else
    return it_ego or ac_delta > 0 or encumb_delta < 0
  end
end

local function pickup_shield(it)
  local cur = items.equipped_at("offhand")

  -- Don't replace these
  if not BRC.is.shield(cur) then return false end
  if cur.encumbrance ~= it.encumbrance then return false end
  if cur.artefact then return false end

  -- Pickup: artefact
  if it.artefact then return true end

  -- Pickup: diff ego (w/o losing SH), gain ego, gain SH (w/o losing ego)
  local it_plus = it.plus or 0
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if cur_ego then
    if it_ego == cur_ego then return it_plus > cur.plus end
    return it_ego and it_plus >= cur.plus
  end
  return it_ego or it_plus > cur.plus
end

local function pickup_aux_armour(it)
  -- Pickup: Anything if the slot is empty
  if aux_slot_is_impaired(it) then return false end
  -- Use a list to support Poltergeists; for most races it's a 1-item list
  local st = it.subtype()
  local all_equipped, num_slots = BRC.get.equipped_aux(st)
  if #all_equipped < num_slots then
    -- If we're carrying one (implying a blocking mutation), don't pickup another
    if #all_equipped == 0 and num_slots == 1 then
      for inv in iter.invent_iterator:new(items.inventory()) do
        if inv.subtype() == st then return false end
      end
    end

    return true
  end

  -- Pickup: artefact, unless slot(s) already full of artefact(s)
  for i, cur in ipairs(all_equipped) do
    if not cur.artefact then break end
    if i == num_slots then return false end
  end
  if it.is_identified and it.artefact then return true end

  -- Pickup: gain ego, gain AC (w/o losing ego), diff ego (w/o losing AC)
  local it_ac = BRC.get.armour_ac(it)
  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local cur_ac = BRC.get.armour_ac(cur)
    local cur_ego = BRC.get.ego(cur)
    if cur_ego then
      if it_ego then
        if it_ac > cur_ac then return true end
        if it_ac == cur_ac and it_ego ~= cur_ego then return true end
      end
    else
      if it_ego or it_ac > cur_ac then return true end
    end
  end
end

-- Local functions: Alerting
local function should_alert_body_armour(weight, gain, loss, ego_change)
  local meets_ratio = loss <= 0 or (gain / loss > BRC.Tuning.armour[weight][ego_change])
  if not meets_ratio then return false end

  -- Additional ego-specific restrictions
  if is_new_ego(ego_change) then
    return loss <= BRC.Tuning.armour[weight].max_loss
  elseif ego_change == LOST then
    return gain >= BRC.Tuning.armour[weight].min_gain
  end

  return true
  -- local function should_alert_lighter_armour(ac_delta, ev_delta, ego_change)
  --     local meets_ratio = ac_delta >= 0 or (ev_delta / -ac_delta > BRC.Tuning.armour.lighter[ego_change])
  --     if not meets_ratio then return false end

  --     -- Apply ego-specific restrictions
  --     if ego_change == LOST and ev_delta < BRC.Tuning.armour.lighter.min_gain then return false end
  --     if ego_change ~= SAME and -ac_delta > BRC.Tuning.armour.lighter.max_loss then return false end

  --     return true
  -- end

  -- local function should_alert_heavier_armour(ac_delta, ev_delta, ego_change)
  --     local meets_ratio = ev_delta >= 0 or (ac_delta / -ev_delta > BRC.Tuning.armour.heavier[ego_change])
  --     if not meets_ratio then return false end

  --     -- Apply ego-specific restrictions
  --     if ego_change == LOST and ac_delta < BRC.Tuning.armour.heavier.min_gain then return false end
  --     if ego_change ~= SAME and -ev_delta > BRC.Tuning.armour.heavier.max_loss then return false end

  --     return true
  -- end
end

-- If training armour in early/mid game, alert user to any armour that is the strongest found so far
local function alert_pa_high_score_ac(it)
  if not BRC.is.body_armour(it) then return false end
  if you.skill("Armour") == 0 then return false end
  if you.xl() > 12 then return false end

  if pa_high_score.ac == 0 then
    local worn = items.equipped_at("armour")
    if not worn then return false end
    pa_high_score.ac = BRC.get.armour_ac(worn)
  else
    local itAC = BRC.get.armour_ac(it)
    if itAC > pa_high_score.ac then
      pa_high_score.ac = itAC
      return f_pickup_alert.do_alert(it, "Highest AC", BRC.Emoji.STRONGEST, BRC.Config.fm_alert.high_score_armour)
    end
  end

  return false
end

local function alert_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end

  -- Always alert artefacts once identified
  if it.artefact then
    if not it.is_identified then return false end
    return send_armour_alert(it, ARMOUR_ALERT.artefact)
  end

  -- Get changes to ego, AC, EV, encumbrance
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  local ego_change = get_ego_change_type(cur_ego, it_ego)
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  local ev_delta = BRC.get.armour_ev(it) - BRC.get.armour_ev(cur)
  local encumb_delta = it.encumbrance - cur.encumbrance

  -- Alert new egos if same encumbrance, or small change to total (AC+EV)
  if is_new_ego(ego_change) then
    if encumb_delta == 0 then return send_armour_alert(it, ARMOUR_ALERT[ego_change]) end

    local weight = encumb_delta < 0 and LIGHTER or HEAVIER
    if math.abs(ac_delta + ev_delta) <= BRC.Tuning.armour[weight].ignore_small then
      return send_armour_alert(it, ARMOUR_ALERT[weight][ego_change])
    end
  end

  -- Alert for lighter/heavier armour, based on configured AC/EV ratio
  if encumb_delta < 0 then
    if should_alert_body_armour(LIGHTER, ev_delta, -ac_delta, ego_change) then
      return send_armour_alert(it, ARMOUR_ALERT.lighter[ego_change])
    end
  elseif encumb_delta > 0 then
    local adj_ev_delta = get_adjusted_ev_delta(encumb_delta, ev_delta)
    if should_alert_body_armour(HEAVIER, ac_delta, -adj_ev_delta, ego_change) then
      return send_armour_alert(it, ARMOUR_ALERT.heavier[ego_change])
    end
  end

  -- Alert for highest AC found so far, or early armour with any ego
  if alert_pa_high_score_ac(it) then return true end
  if it_ego and you.xl() <= BRC.Tuning.armour.early_xl then
    return f_pickup_alert.do_alert(it, "Early armour", BRC.Emoji.EGO)
  end
end

local function alert_shield(it)
  if it.artefact then
    if not it.is_identified then return false end
    return f_pickup_alert.do_alert(it, "Artefact shield", BRC.Emoji.ARTEFACT, BRC.Config.fm_alert.shields)
  end

  -- Don't alert shields if not wearing one (one_time_alerts fire for the first of each type)
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end

  -- Alert: New ego, Gain SH
  local ego_change = get_ego_change_type(BRC.get.ego(cur), BRC.get.ego(it))
  if is_new_ego(ego_change) then
    local alert_msg = ego_change == DIFF and "Diff ego" or "Gain ego"
    return f_pickup_alert.do_alert(it, alert_msg, BRC.Emoji.EGO, BRC.Config.fm_alert.shields)
  elseif BRC.get.shield_sh(it) > BRC.get.shield_sh(cur) then
    return f_pickup_alert.do_alert(it, "Higher SH", BRC.Emoji.STRONGER, BRC.Config.fm_alert.shields)
  end
end

local function alert_aux_armour(it, unworn_inv_item)
  if it.artefact then
    if not it.is_identified then return false end
    return f_pickup_alert.do_alert(it, "Artefact aux armour", BRC.Emoji.ARTEFACT, BRC.Config.fm_alert.aux_armour)
  end

  -- Use a list to support Poltergeists; for other races it's a 1-item list
  local all_equipped, num_slots = BRC.get.equipped_aux(it.subtype())
  if #all_equipped < num_slots then
    if unworn_inv_item then
      all_equipped[#all_equipped + 1] = unworn_inv_item
    else
      -- Catch dangerous brands or items blocked by non-innate mutations
      return f_pickup_alert.do_alert(it, "Aux armour", BRC.Emoji.EXCLAMATION, BRC.Config.fm_alert.aux_armour)
    end
  end

  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local ego_change = get_ego_change_type(BRC.get.ego(cur), it_ego)
    if is_new_ego(ego_change) then
      local alert_msg = ego_change == DIFF and "Diff ego" or "Gain ego"
      return f_pickup_alert.do_alert(it, alert_msg, BRC.Emoji.EGO, BRC.Config.fm_alert.aux_armour)
    elseif BRC.get.armour_ac(it) > BRC.get.armour_ac(cur) then
      return f_pickup_alert.do_alert(it, "Higher AC", BRC.Emoji.STRONGER, BRC.Config.fm_alert.aux_armour)
    end
  end
end

-- Public API
function f_pa_armour.pickup_armour(it)
  if BRC.is.risky_item(it) then return false end

  if BRC.is.body_armour(it) then
    return pickup_body_armour(it)
  elseif BRC.is.shield(it) then
    return pickup_shield(it)
  else
    return pickup_aux_armour(it)
  end
end

--[[
    f_pa_armour.alert_armour() - Alerts armour items that didn't auto-pickup but are worth consideration.
    This comes after pickup, so there will be no pure upgrades.
    Optional `unworn_inv_item` param, to compare against an unworn aux armour item in inventory.
--]]
function f_pa_armour.alert_armour(it, unworn_inv_item)
  if BRC.is.body_armour(it) then
    return alert_body_armour(it)
  elseif BRC.is.shield(it) then
    return alert_shield(it)
  else
    return alert_aux_armour(it, unworn_inv_item)
  end
end

}
############################### End lua/features/pickup-alert/pa-armour.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-misc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-misc
Description: Miscellaneous item pickup logic and alert system for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
--]]

f_pa_misc = {}
--f_pa_misc.BRC_FEATURE_NAME = "pickup-alert-misc"

function f_pa_misc.alert_orb(it)
  if not it.is_identified then return false end
  return f_pickup_alert.do_alert(it, "New orb", BRC.Emoji.ORB, BRC.Config.fm_alert.orbs)
end

function f_pa_misc.alert_OTA(it)
  local ota_item = f_pa_data.find(pa_OTA_items, it)
  if not ota_item then return end

  local do_alert = true

  if BRC.is.shield(it) then
    if you.skill("Shields") < BRC.Config.alert.OTA_require_skill.shield then return end

    -- Don't alert if already wearing a larger shield
    if ota_item == "buckler" then
      if BRC.you.have_shield() then do_alert = false end
    elseif ota_item == "kite shield" then
      local sh = items.equipped_at("offhand")
      if sh and sh.name("qual") == "tower shield" then do_alert = false end
    end
  elseif BRC.is.armour(it) then
    if you.skill("Armour") < BRC.Config.alert.OTA_require_skill.armour then return end
  elseif it.is_weapon then
    if you.skill(it.weap_skill) < BRC.Config.alert.OTA_require_skill.weapon then return end
  end

  f_pa_data.remove(pa_OTA_items, it)
  if not do_alert then return false end
  return f_pickup_alert.do_alert(it, "Rare item", BRC.Emoji.RARE_ITEM, BRC.Config.fm_alert.one_time_alerts)
end

function f_pa_misc.alert_staff(it)
  if not it.is_identified then return false end
  local needRes = false
  local basename = it.name("base")

  if basename == "staff of fire" then
    needRes = you.res_fire() == 0
  elseif basename == "staff of cold" then
    needRes = you.res_cold() == 0
  elseif basename == "staff of air" then
    needRes = you.res_shock() == 0
  elseif basename == "staff of poison" then
    needRes = you.res_poison() == 0
  elseif basename == "staff of death" then
    needRes = you.res_draining() == 0
  end

  if not needRes then return false end
  return f_pickup_alert.do_alert(it, "Staff resistance", BRC.Emoji.STAFF_RESISTANCE, BRC.Config.fm_alert.staff_resists)
end

function f_pa_misc.alert_talisman(it)
  if it.artefact then
    if not it.is_identified then return false end
    return f_pickup_alert.do_alert(it, "Artefact talisman", BRC.Emoji.TALISMAN, BRC.Config.fm_alert.talismans)
  end
  local required_skill = BRC.get.talisman_min_level(it) - BRC.Config.alert.talisman_lvl_diff
  if required_skill > you.skill("Shapeshifting") then return false end
  return f_pickup_alert.do_alert(it, "New talisman", BRC.Emoji.TALISMAN, BRC.Config.fm_alert.talismans)
end

function f_pa_misc.is_unneeded_ring(it)
  if not BRC.is.ring(it) or it.artefact or you.race() == "Octopode" then return false end
  local missing_hand = BRC.get.mut(BRC.MUTATIONS.missing_hand, true)
  local st = it.subtype()
  local found_first = false
  for inv in iter.invent_iterator:new(items.inventory()) do
    if BRC.is.ring(inv) and inv.subtype() == st then
      if found_first or missing_hand then return true end
      found_first = true
    end
  end
  return false
end

function f_pa_misc.pickup_staff(it)
  if not it.is_identified then return false end
  if BRC.get.skill(BRC.get.staff_school(it)) == 0 then return false end
  return not f_pa_data.find(pa_items_picked, it)
end

}
############################### End lua/features/pickup-alert/pa-misc.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-weapons.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-weapons
Description: Weapon pickup logic, caching, and alert system for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/data.lua, core/util.lua
--]]

f_pa_weapons = {}
--f_pa_weapons.BRC_FEATURE_NAME = "pickup-alert-weapons"

-- Persistent variables
lowest_num_hands_alerted = BRC.data.persist("lowest_num_hands_alerted", {
  ["Ranged Weapons"] = 3, -- Start with 3 (to fire both 1 and 2-handed alerts)
  ["Polearms"] = 3, -- Start with 3 (to fire both 1 and 2-handed alerts)
}) -- lowest_num_hands_alerted (do not remove this comment)

-- Local constants / configuration
local FIRST_WEAPON_XL_CUTOFF = 4 -- Stop looking for first weapon after this XL
local RANGED_XL_THRESHOLD = 3 -- At this skill level, don't bother alerting for polearms
local RANGED = "range_"
local MELEE = "melee_"

-- Local variables
local top_attack_skill

-- Global variable: Cache weapons in inventory (so we don't recompute DPS, etc on every autopickup call)
_weapon_cache = {}

function _weapon_cache.get_primary_key(it)
  local tokens = {}
  tokens[1] = it.is_ranged and RANGED or MELEE
  tokens[2] = tostring(it.hands)
  if BRC.get.ego(it) then tokens[3] = "b" end
  return table.concat(tokens)
end

-- Get all categories this weapon fits into (both its real category and any more-restrictive categories)
function _weapon_cache.get_keys(is_ranged, hands, is_branded)
  local ranged_types = is_ranged and { RANGED, MELEE } or { MELEE }
  local handed_types = hands == 1 and { "1", "2" } or { "2" }
  local branded_types = is_branded and { "b", "" } or { "" }

  -- Generate all combinations
  local keys = {}
  for _, r in ipairs(ranged_types) do
    for _, h in ipairs(handed_types) do
      for _, b in ipairs(branded_types) do
        keys[#keys + 1] = table.concat({ r, h, b })
      end
    end
  end

  return keys
end

function _weapon_cache.add_weapon(it)
  local weap_data = {}
  weap_data.is_weapon = it.is_weapon
  weap_data.basename = it.name("base")
  weap_data._subtype = it.subtype()
  weap_data.subtype = function() return weap_data._subtype end -- For consistency in other code
  weap_data.weap_skill = it.weap_skill
  weap_data.skill_lvl = BRC.get.skill(it.weap_skill)
  weap_data.is_ranged = it.is_ranged
  weap_data.hands = BRC.get.hands(it)
  weap_data.artefact = it.artefact
  weap_data._ego = BRC.get.ego(it)
  weap_data.ego = function() return weap_data._ego end -- For consistency in other code
  weap_data.plus = it.plus or 0
  weap_data.acc = it.accuracy + weap_data.plus
  weap_data.damage = it.damage
  weap_data.dps = BRC.get.weap_dps(it)
  weap_data.score = BRC.get.weap_score(it)
  weap_data.unbranded_score = BRC.get.weap_score(it, true)

  -- Check for exclusion tags
  local lower_insc = it.inscription:lower()
  weap_data.allow_upgrade = not (lower_insc:find("!u", 1, true) or lower_insc:find("!brc", 1, true))

  -- Track unique egos
  if weap_data._ego and not util.contains(_weapon_cache.egos, weap_data._ego) then
    _weapon_cache.egos[#_weapon_cache.egos + 1] = weap_data._ego
  end

  -- Track max damage for applicable weapon categories
  local keys = _weapon_cache.get_keys(weap_data.is_ranged, weap_data.hands, weap_data._ego ~= nil)

  -- Update the max DPS for each category
  for _, key in ipairs(keys) do
    if weap_data.dps > _weapon_cache.max_dps[key].dps then
      _weapon_cache.max_dps[key].dps = weap_data.dps
      _weapon_cache.max_dps[key].acc = weap_data.acc
    end
  end

  _weapon_cache.weapons[#_weapon_cache.weapons + 1] = weap_data
  return weap_data
end

function _weapon_cache.is_empty()
  return _weapon_cache.max_dps["melee_2"].dps == 0 -- The most restrictive category
end

function _weapon_cache.serialize()
  local tokens = { "\n---INVENTORY WEAPONS---" }
  for _, weap in ipairs(_weapon_cache.weapons) do
    tokens[#tokens + 1] = string.format("\n%s\n", weap.basename)
    for k, v in pairs(weap) do
      if k ~= "basename" then tokens[#tokens + 1] = string.format("  %s: %s\n", k, tostring(v)) end
    end
  end
  return table.concat(tokens)
end

-- Local functions
-- is_weapon_upgrade(it, cur) -> boolean : For pickup; Check if a weapon is an upgrade to one currently in inventory.
-- `cur` comes from _weapon_cache - it has some pre-computed values
local function is_weapon_upgrade(it, cur)
  if it.subtype() == cur.subtype() then
    -- Exact weapon type match
    if it.artefact then return true end
    if cur.artefact then return false end
    local it_ego = BRC.get.ego(it)
    local cur_ego = BRC.get.ego(cur)
    if cur_ego and not it_ego then return false end
    if it_ego and it.is_identified and not cur_ego then
      return BRC.get.weap_score(it) / cur.score > BRC.Tuning.weap.pickup.add_ego
    end
    return it_ego == cur_ego and BRC.get.weap_score(it) > cur.score
  elseif it.weap_skill == cur.weap_skill or you.race() == "Gnoll" then
    -- Return false if no clear upgrade possible
    if BRC.get.hands(it) > cur.hands then return false end
    if cur.is_ranged ~= it.is_ranged then return false end
    if BRC.is.polearm(cur) ~= BRC.is.polearm(it) then return false end

    if it.artefact then return true end
    if cur.artefact then return false end

    local min_ratio = it.is_ranged and BRC.Tuning.weap.pickup.same_type_ranged or BRC.Tuning.weap.pickup.same_type_melee
    return BRC.get.weap_score(it) / cur.score > min_ratio
  end

  return false
end

local function need_first_weapon()
  return you.xl() < FIRST_WEAPON_XL_CUTOFF
    and _weapon_cache.is_empty()
    and you.skill("Unarmed Combat") == 0
    and BRC.get.mut(BRC.MUTATIONS.claws, true) == 0
end

-- Local functions: Alerting
local function alert_first_of_skill(it, silent)
  local skill = it.weap_skill
  if not lowest_num_hands_alerted[skill] then return false end

  local hands = BRC.get.hands(it)
  if lowest_num_hands_alerted[skill] > hands then
    -- Some early checks to skip alerts
    if hands == 2 and BRC.you.have_shield() then return false end
    if skill == "Polearms" and you.skill("Ranged Weapons") >= RANGED_XL_THRESHOLD then return false end

    -- Update lowest # hands alerted, and alert
    lowest_num_hands_alerted[skill] = hands
    if silent then return true end
    local msg = string.format("First %s%s", string.sub(skill, 1, -2), hands == 1 and " (1-handed)" or "")
    return f_pickup_alert.do_alert(it, msg, BRC.Emoji.WEAPON, BRC.Config.fm_alert.early_weap)
  end
  return false
end

local function alert_early_weapons(it)
  -- Alert really good usable ranged weapons
  if you.xl() <= BRC.Tuning.weap.alert.early_ranged.xl then
    if it.is_identified and it.is_ranged then
      if
        it.plus >= BRC.Tuning.weap.alert.early_ranged.min_plus and BRC.get.ego(it)
        or it.plus >= BRC.Tuning.weap.alert.early_ranged.branded_min_plus
      then
        local low_shield_training = you.skill("Shields") <= BRC.Tuning.weap.alert.early_ranged.max_shields
        if BRC.get.hands(it) == 1 or not BRC.you.have_shield() or low_shield_training then
          return f_pickup_alert.do_alert(it, "Ranged weapon", BRC.Emoji.RANGED, BRC.Config.fm_alert.early_weap)
        end
      end
    end
  end

  if you.xl() <= BRC.Tuning.weap.alert.early.xl then
    -- Skip items if we're clearly going another route
    local skill_setting = BRC.Tuning.weap.alert.early.skill
    local skill_diff = BRC.get.skill(top_attack_skill) - BRC.get.skill(it.weap_skill)
    if skill_diff > you.xl() * skill_setting.factor + skill_setting.offset then return false end

    local it_plus = it.plus or 0
    if BRC.get.ego(it) or it_plus and it_plus >= BRC.Tuning.weap.alert.early.branded_min_plus then
      return f_pickup_alert.do_alert(it, "Early weapon", BRC.Emoji.WEAPON, BRC.Config.fm_alert.early_weap)
    end
  end

  return false
end

--[[
alert_interesting_weapon() -> boolean : `cur` comes from _weapon_cache - it has some pre-computed values
Check if weapon is worth alerting for, compared against one weapon currently in inventory
--]]
local function alert_interesting_weapon(it, cur)
  if it.artefact and it.is_identified then return f_pickup_alert.do_alert(it, "Artefact weapon", BRC.Emoji.ARTEFACT) end

  local inv_best = _weapon_cache.max_dps[_weapon_cache.get_primary_key(it)]
  local best_dps = math.max(cur.dps, inv_best and inv_best.dps or 0)
  local best_score = math.max(cur.score, inv_best and BRC.get.weap_score(inv_best) or 0)

  if cur.subtype() == it.subtype() then
    -- Exact weapon type match; alert new egos or higher DPS/weap_score
    local it_ego = BRC.get.ego(it, true) -- Don't overvalue speed/heavy egos (only look at their DPS)
    if not cur.artefact and it_ego and it_ego ~= BRC.get.ego(cur) then
      return f_pickup_alert.do_alert(it, "Diff ego", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
    elseif BRC.get.weap_score(it) > best_score or BRC.get.weap_dps(it) > best_dps then
      return f_pickup_alert.do_alert(it, "Weapon upgrade", BRC.Emoji.WEAPON, BRC.Config.fm_alert.upgrade_weap)
    end
    return false
  end

  if cur.is_ranged ~= it.is_ranged then return false end
  if BRC.is.polearm(cur) ~= BRC.is.polearm(it) then return false end
  if 2 * BRC.get.skill(it.weap_skill) < BRC.get.skill(cur.weap_skill) then return false end

  -- Penalize lower-trained skills
  local damp = BRC.Tuning.weap.alert.low_skill_penalty_damping
  local penalty = (BRC.get.skill(it.weap_skill) + damp) / (BRC.get.skill(top_attack_skill) + damp)
  local ratio = penalty * BRC.get.weap_score(it) / best_score

  if BRC.get.hands(it) > cur.hands then
    if BRC.you.free_offhand() or (you.skill("Shields") < BRC.Tuning.weap.alert.add_hand.ignore_sh_lvl) then
      local it_ego = BRC.get.ego(it)
      local unique_ego = it_ego and not util.contains(_weapon_cache.egos, it_ego)
      if unique_ego and ratio > BRC.Tuning.weap.alert.new_ego then
        return f_pickup_alert.do_alert(it, "New ego (2-handed)", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
      elseif ratio > BRC.Tuning.weap.alert.add_hand.not_using then
        return f_pickup_alert.do_alert(it, "2-handed weapon", BRC.Emoji.TWO_HAND, BRC.Config.fm_alert.upgrade_weap)
      end
    elseif BRC.get.ego(it) and not BRC.get.ego(cur) and ratio > BRC.Tuning.weap.alert.add_hand.add_ego_lose_sh then
      local msg = "2-handed weapon (Gain ego)"
      return f_pickup_alert.do_alert(it, msg, BRC.Emoji.TWO_HAND, BRC.Config.fm_alert.weap_ego)
    end
  else -- No extra hand required
    if cur.artefact then return false end
    if BRC.get.ego(it, true) then -- Don't overvalue Speed/Heavy egos (only look at their DPS)
      local it_ego = BRC.get.ego(it)
      if not BRC.get.ego(cur) then
        if ratio > BRC.Tuning.weap.alert.gain_ego then
          return f_pickup_alert.do_alert(it, "Gain ego", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
        end
      elseif not util.contains(_weapon_cache.egos, it_ego) and ratio > BRC.Tuning.weap.alert.new_ego then
        return f_pickup_alert.do_alert(it, "New ego", BRC.Emoji.EGO, BRC.Config.fm_alert.weap_ego)
      end
    end
    if ratio > BRC.Tuning.weap.alert.pure_dps then
      return f_pickup_alert.do_alert(it, "Weapon upgrade", BRC.Emoji.WEAPON, BRC.Config.fm_alert.upgrade_weap)
    end
  end

  return false
end

local function alert_interesting_weapons(it)
  for _, inv in ipairs(_weapon_cache.weapons) do
    if alert_interesting_weapon(it, inv) then return true end
  end
  return false
end

local function alert_weap_high_scores(it)
  local category = f_pa_data.update_high_scores(it)
  if not category then return false end
  return f_pickup_alert.do_alert(it, category, BRC.Emoji.WEAPON, BRC.Config.fm_alert.high_score_weap)
end

-- Public API
function f_pa_weapons.pickup_weapon(it)
  -- Check if we need the first weapon of the game
  if need_first_weapon() then
    -- Staves don't go into _weapon_cache; check if we're carrying just a staff
    for inv in iter.invent_iterator:new(items.inventory()) do
      if inv.is_weapon then return false end -- fastest way to check if it's a staff
    end
    return true
  end

  if BRC.is.risky_item(it) then return false end
  if f_pa_data.find(pa_items_picked, it) then return false end
  for _, inv in ipairs(_weapon_cache.weapons) do
    if inv.allow_upgrade and is_weapon_upgrade(it, inv) then return true end
  end
end

function f_pa_weapons.alert_weapon(it)
  if alert_interesting_weapons(it) then return true end
  if alert_first_of_skill(it) then return true end
  if alert_early_weapons(it) then return true end

  -- Skip high score alerts if not using weapons
  if _weapon_cache.is_empty() then return false end
  return alert_weap_high_scores(it)
end

-- Hook functions
function f_pa_weapons.init()
  _weapon_cache.weapons = {}
  _weapon_cache.egos = {}

  -- Track max DPS by weapon category
  _weapon_cache.max_dps = {}
  local keys = { "melee_1", "melee_1b", "melee_2", "melee_2b", "range_1", "range_1b", "range_2", "range_2b" }
  for _, key in ipairs(keys) do
    _weapon_cache.max_dps[key] = { dps = 0, acc = 0 }
  end

  -- Set top weapon skill
  top_attack_skill = "Unarmed Combat"
  local max_weap_skill = BRC.get.skill(top_attack_skill)
  for _, v in ipairs(BRC.WEAP_SCHOOLS) do
    if BRC.get.skill(v) > max_weap_skill then
      max_weap_skill = BRC.get.skill(v)
      top_attack_skill = v
    end
  end
end

function f_pa_weapons.ready()
  f_pa_weapons:init()
  for inv in iter.invent_iterator:new(items.inventory()) do
    if inv.is_weapon and not BRC.is.magic_staff(inv) then
      _weapon_cache.add_weapon(inv)
      f_pa_data.update_high_scores(inv)
    end
  end
end

}
############################### End lua/features/pickup-alert/pa-weapons.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##


############## Lua Hook Functions ##############
{
-- Hook functions that delegate to BRC
function ready()
    BRC.ready()
end

function c_message(text, channel)
    BRC.c_message(text, channel)
end

function c_answer_prompt(prompt)
    return BRC.c_answer_prompt(prompt)
end

function c_assign_invletter(it)
  return BRC.c_assign_invletter(it)
end


BRC.init()
}
