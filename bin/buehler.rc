
################################### Begin lua/core/config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Configuration - Various configs, overriding default values in feature configs.
Author: buehler
Dependencies: (none)
Usage:
  - Update BRC.config_to_use to load the corresponding config.
  - Update each config or create new ones.
  - Undefined values first fall back to Configs.Default, then defaults in feature.Config.
  - `init` (function or multi-line comment of lua) executes after config loads, before overrides.
  - If using config_memory == "full", the function needs to be saved as a string instead. --]]
-- To do this, just replace `function()` and `end` with double square brackets: [[ ... ]]

---- Initialize BRC namespace and Public modules
BRC = BRC or {}
BRC.Profiles = {}
BRC.config_to_use = "ask"
BRC.config_memory = "name"

-- Default Config Profile (defines all non-feature values)
BRC.Profiles.Default = {
  emojis = false, -- Use emojis in alerts and announcements
  show_debug_messages = false,
  debug_to_stderr = true,
} -- BRC.Profiles.Default (do not remove this comment)
BRC.Config = BRC.Profiles.Default -- Always init to Default profile

-- Testing Config Profile: Isolate and test specific features
BRC.Profiles.Testing = {
  show_debug_messages = true,
  disable_other_features = false,
  ["pickup-alert"] = {
    Alert = {
      armour_sensitivity = 0.3,
      weapon_sensitivity = 2,
    },
    Tuning = {
      Armour = {
        diff_body_ego_is_good = false,
      },
    },
  },
  init = [[
    if BRC.Config.disable_other_features then
      for _, v in pairs(_G) do
        if BRC.is_feature_module(v) and not BRC.Config[v.BRC_FEATURE_NAME] then
          BRC.Config[v.BRC_FEATURE_NAME] = { disabled = true }
        end
      end
    end
  ]],
} -- BRC.Profiles.Testing (do not remove this comment)

-- Custom Config Profile: Personalized settings
BRC.Profiles.Custom = {
  ["misc-alerts"] = {
    alert_low_hp_threshold = 0.35, -- % max HP to alert; 0 to disable
  },
  ["announce-hp-mp"] = {
    dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
    dmg_fm_threshold = 0.30,    -- Force more for losing this % of max HP
    always_on_bottom = false,   -- Rewrite HP/MP meters after each turn with messages
  },
  ["inscribe-stats"] = {
    inscribe_weapons = true, -- Inscribe weapon stats on pickup and keep updated
    inscribe_armour = true,  -- Inscribe armour stats on pickup and keep updated
  },
  ["remind-id"] = {
    stop_on_scrolls_count = 2, -- Stop when largest un-ID'd scroll stack increases and is >= this
    stop_on_pots_count = 3,    -- Stop when largest un-ID'd potion stack increases and is >= this
  },
  ["runrest-features"] = {
    ignore_portal_exits = true, -- don't stop explore on portal exits
    temple_search = true,       -- on enter or explore, auto-search altars
    gauntlet_search = true,     -- on enter or explore, auto-search gauntlet with filters
  },
  ["startup"] = {
    show_skills_on_startup = false, -- Open skills menu on startup
    auto_set_skill_targets = {
      { "Stealth", 2.0 },  -- First, focus stealth to 2.0
      { "Fighting", 2.0 }, -- If already have stealth, focus fighting to 2.0
    },
  },
  ["pickup-alert"] = {
    Pickup = {
      armour = true,
      staves = true,
      weapons = true,
      weapons_pure_upgrades_only = true, -- Only pick up better versions of same exact weapon
    },

    Alert = {
      armour_sensitivity = 1, -- Adjust all armour alerts; range [0.5-2.0]; 0 to disable
      weapon_sensitivity = 1,   -- Adjust all weapon alerts; range [0.5-2.0]; 0 to disable
      orbs = true,
      staff_resists = true,     -- When a staff gives a missing resistance
      talismans = true,

      one_time = { -- Alert the first time each item is found
        "wand of digging", "buckler", "kite shield", "tower shield", "crystal plate armour",
        "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales",
        "quick blade", "demon blade", "eudemon blade", "double sword", "triple sword",
        "broad axe", "executioner's axe",
        "demon whip", "eveningstar", "giant spiked club", "morningstar", "sacred scourge",
        "lajatang", "bardiche", "demon trident", "partisan", "trishula",
        "hand cannon", "triple crossbow",
      },
      OTA_require_skill = { weapon = 2, armour = 2.5, shield = 0 }, -- No one_time if skill < this

      More = { -- Which alerts generate a force_more_message (some categories overlap)
        early_weap = false,       -- Good weapons found early
        upgrade_weap = false,     -- Better DPS / weapon_score
        weap_ego = false,         -- New or diff egos
        body_armour = false,
        shields = true,
        aux_armour = false,
        armour_ego = false,        -- New or diff egos
        high_score_weap = false,  -- Highest damage found
        high_score_armour = true, -- Highest AC found
        one_time_alerts = true,
        artefact = false,         -- Any artefact
        trained_artefacts = true, -- Artefacts where you have corresponding skill > 0
        orbs = false,
        talismans = you.class() == "Shapeshifter", -- True for shapeshifter, false for everyone else
        staff_resists = false,
      },
    },
  },
} -- BRC.Profiles.Custom (do not remove this comment)

-- Speed Config Profile: For speed runs
BRC.Profiles.Speed = {
  ["alert-monsters"] = { disabled = true },
  ["safe-consumables"] = { disabled = true },
  ["safe-stairs"] = { disabled = true },
  ["announce-hp-mp"] = {
    dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
    dmg_fm_threshold = 1,       -- Force more for losing this % of max HP
    always_on_bottom = true,    -- Rewrite HP/MP meters after each turn with messages
  },
  ["misc-alerts"] = {
    alert_low_hp_threshold = 0, -- % max HP to alert; 0 to disable
    save_with_msg = false,      -- Shift-S to save and leave yourself a message
  },
  ["mute-messages"] = {
    mute_level = 3,
  },
  ["remind-id"] = {
    stop_on_scrolls_count = 9, -- Stop when largest un-ID'd scroll stack increases and is >= this
    stop_on_pots_count = 9,    -- Stop when largest un-ID'd potion stack increases and is >= this
  },
  ["runrest-features"] = { after_shaft = false },
  ["startup"] = {
    show_skills_on_startup = false, -- Open skills menu on startup
  },
  ["pickup-alert"] = {
    Pickup = {
      armour = true,
      staves = false,
      weapons = true,
      weapons_pure_upgrades_only = false, -- Only pick up better versions of same exact weapon
    },

    Alert = {
      armour_sensitivity = 1.1, -- [0.5-2.0] Adjust all armour alerts; 0 to disable
      weapon_sensitivity = 1.2, -- [0.5-2.0] Adjust all weapon alerts; 0 to disable
      orbs = false,
      staff_resists = false, -- When a staff gives a missing resistance
      talismans = false,

      one_time = { -- Alert the first time each item is found
        "kite shield", "tower shield", "crystal plate armour",
        "gold dragon scales", "pearl dragon scales", "storm dragon scales",
        "broad axe", "demon whip", "eveningstar", "morningstar",
      },
      OTA_require_skill = { weapon = 6, armour = 0, shield = 0 }, -- No one_time if skill < this

      More = {}, -- All nil / false
    },
    Tuning = {
      Armour = {
        encumb_penalty_weight = 0, -- [0-2.0] Penalty to heavy armour when training magic/ranged
        early_xl = 0, -- Alert all usable runed body armour if XL <= `early_xl`
      },
    },
  },

  init = [[
    BRC.Config.startup.auto_set_skill_targets = { { BRC.get.preferred_weapon_type(), 8.0 } }
  ]],
} -- BRC.Profiles.Speed (do not remove this comment)

-- Turncount Config Profile: For turncount runs
BRC.Profiles.Turncount = {
  ["alert-monsters"] = {
    sensitivity = 1.25, -- 0 to disable all; at 2.0, alerts will fire at 1/2 HP
  },
  ["runrest-features"] = { after_shaft = false },
  ["mute-messages"] = {
    mute_level = 1,
  },
} -- BRC.Profiles.Turncount (do not remove this comment)

-- Streak Config Profile: For win streaks
BRC.Profiles.Streak = {
  ["alert-monsters"] = {
    sensitivity = 1.5, -- 0 to disable all; at 2.0, alerts will fire at 1/2 HP
  },
  ["mute-messages"] = {
    mute_level = 1,
  },
} -- BRC.Profiles.Streak (do not remove this comment)

}
############################### End lua/core/config.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

####### Main options #######
easy_confirm = all
show_more = false
small_more = true
mouse_input = false
tile_web_mouse_control = false
default_manual_training = true
autofight_caught = true
rest_wait_both = true
rest_wait_ancestor = true

autofight_stop = 40
hp_warning = 20
item_stack_summary_minimum = 8
fail_severity_to_confirm = 4

sort_menus = true:equipped,art,ego,basename,identified,qualname,>qty
drop_filter += useless_item, forbidden
fire_order = silver javelin, javelin, silver boomerang, boomerang, curare-tipped dart, poisoned dart, dart, stone


####### Explore options #######
explore_delay = -1
travel_delay = -1
rest_delay = -1
view_delay = 100
show_travel_trail = true

explore_stop = altars,branches,portals,runed_doors,greedy_pickup_smart
explore_stop_pickup_ignore += scroll, potion, misc, wand, stone, dart, boomerang, javelin


### Mostly normal RC options ###

################################### Begin rc/autoinscribe.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
# See safe-consumables.lua for consumable inscriptions

ai := autoinscribe

# General
ai += of cold resistance:rC+
ai += of fire resistance:rF+
ai += of poison resistance:rPois
ai += of corrosion resistance:rCorr
ai += of invulnerability:rInv
ai += of magic regeneration:MRegen+
ai += of positive energy:rN+
ai += of regeneration:Regen+
ai += of resistance:rF+, rC+
ai += of willpower:Will+

# Armour
ai += fire dragon scale:rF++, rC-
ai += gold dragon scale:rC+, rF+, rPois
ai += ice dragon scale:rC++, rF-
ai += pearl dragon scale:rN+
ai += storm dragon scale:rElec
ai += swamp dragon scale:rPois
ai += quicksilver dragon scale:Will+
ai += shadow dragon scale:Stlth+
ai += (?<!moon) troll leather:Regen+


# Amulets
ai += amulet of faith:Faith, !P

# Rings
ai += ring of fire:rF+, rC-
ai += ring of flight:+Fly
ai += ring of ice:rC+, rF-
ai += ring of magical power:MP+9
ai += ring of protection from cold:rC+
ai += ring of protection from fire:rF+
ai += ring of resist corrosion:rCorr
ai += ring of see invisible:sInv
ai += ring of wizardry:Wiz+

# Staves
ai += staff of air:rElec
ai += staff of cold:rC+
ai += staff of death:rN+
ai += staff of fire:rF+
ai += staff of poison:rPois

############################### End rc/autoinscribe.rc ###############################
##########################################################################################

################################### Begin rc/autopickup.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
####### Autopickup exceptions #######
ae := autopickup_exceptions
ae ^= <potions? of attraction, <potions? of lignification, <potions? of mutation
ae ^= <scrolls? of immolation, <scrolls? of poison
ae ^= <missile, <misc, <bauble
ae ^= >staff of.*, >useless_item

############################### End rc/autopickup.rc ###############################
##########################################################################################

################################### Begin rc/display.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
show_resist_percent = false
stat_colour = 3:red, 6:yellow

hp_colour = 100:green, 99:lightgrey, 75:yellow, 50:lightred, 25:red
mp_colour = 100:green, 99:lightgrey, 75:yellow, 50:lightred, 25:red

####### Menu Colors #######
# Set Alias & clear defaults
menu := menu_colour
menu =

#### Item colours
$i_equipped := lightgreen
$i_boring := darkgrey
$i_plain := lightgrey
$i_ego := white
$i_wand := lightblue
$i_evoker := yellow
$i_misc := brown
$i_shade_artefact := cyan
$i_shade_jewellery := magenta
$i_shade_consumables := green

## Consumables
$i_warning := lightred
$i_useful := lightblue
$i_heal := green
$i_emergency := lightcyan
$i_rare := yellow

#### Assign item menu_colours
## Highest priority; always correct
menu += $i_boring:(melded|useless_item)
menu += $i_warning:forbidden
menu += inventory:$i_equipped:.*equipped

## Menu-specific overrides
# Begin workaround for https://github.com/crawl/crawl/issues/4825 (to override inventory color only)
menu += pickup:light$i_shade_artefact:artefact
menu += stash:light$i_shade_artefact:artefact

menu += pickup:$i_evoker:inert
menu += stash:$i_evoker:inert
menu += inventory:$i_boring:inert

menu += pickup:light$i_shade_jewellery:amulet
menu += stash:light$i_shade_jewellery:amulet
menu += inventory:$i_shade_jewellery:amulet
# End workaround

menu += inventory:$i_boring:inert
menu += inventory:$i_shade_jewellery:amulet
menu += pickup:light$i_shade_consumables:potion
menu += pickup:$i_shade_consumables:scroll
menu += pickup:$i_shade_artefact:artefact.*weapon
menu += pickup:$i_ego:(ego|(unidentified.*(glowing|runed|shiny|embroidered)|troll leather|dragon scales))
menu += pickup:$i_wand:wand of
menu += resists:$i_shade_artefact:artefact
menu += resists:$i_ego:ego
menu += resists:$i_plain:(armour|weapon|jewellery)
menu += shop:$i_ego:(ego|(unidentified.*(glowing|runed|shiny|embroidered)|troll leather|dragon scales))


## Main item colours
menu += $i_equipped:.*equipped.*(weapon|armour|jewellery)
menu += light$i_shade_artefact:artefact
menu += light$i_shade_jewellery:jewellery
menu += $i_ego:ego

# Decks
menu += $i_emergency:deck of escape
menu += $i_useful:deck of summoning
menu += $i_warning:deck of destruction

# Misc
menu += $i_misc:(manual of|spellbook|staff of|talisman|bauble)
menu += $i_evoker:(curare|disjunction|throwing net)
menu += $i_evoker:evoker

# Potions
menu += $i_emergency:potions? of (cancellation|haste|resistance)
menu += $i_heal:potions? of (ambrosia|curing|i_heal wounds|magic)
menu += $i_rare:potions? of experience
menu += $i_useful:potions? of (brilliance|enlightenment|invisibility|might)
menu += $i_warning:potions? of (attraction|berserk|lignification|mutation)

# Scrolls
menu += $i_plain:scrolls? of (amnesia|enchant|identify)
menu += $i_emergency:scrolls? of (blinking|butterflies|fear|fog|teleportation|summoning)
menu += $i_rare:scrolls? of (acquirement|brand)
menu += $i_useful:scrolls? of (revelation)
menu += $i_warning:scrolls? of (immolation|noise|poison|silence|torment|vulnerability)

# Wands
menu += $i_emergency:wand of digging
menu += $i_plain:wand of (flame|paralysis|charming|mindburst|polymorph)
menu += $i_useful:wand of (acid|iceblast|light|quicksilver|roots|warping)


####### Message Channels #######
# (Main changes are god, timed_portal, mutation, and several mute/boring)
$m_boring := darkgrey
$m_normal := lightgrey
$m_interesting := white
$m_interface := cyan
$m_info := blue
$m_attention := lightmagenta
$m_danger  := red
$m_warning := lightred
$m_alert := yellow
$m_gain := green
$m_restore := lightblue

channel.plain = $m_normal
channel.prompt = $m_interface
channel.god = $m_alert
channel.duration = $m_restore
channel.danger = $m_danger
channel.warning = $m_warning
channel.recovery = $m_gain
channel.talk = mute
channel.talk_visual = mute
channel.timed_portal = $m_alert
channel.sound = $m_normal
channel.intrinsic_gain = $m_gain
channel.mutation = $m_attention
channel.monster_spell = $m_interesting
channel.monster_enchant = $m_interesting
channel.monster_warning = $m_warning
channel.friend_spell = $m_boring
channel.friend_enchant = $m_boring
channel.friend_action = $m_boring
channel.monster_damage = mute
channel.monster_target = mute
channel.banishment = $m_alert
channel.equipment = $m_normal
channel.floor = $m_boring
channel.multiturn = $m_boring
channel.examine = $m_normal
channel.examine_filter = $m_boring
channel.diagnostic = $m_info
channel.error = $m_attention
channel.tutorial = $m_info
channel.orb = $m_attention
channel.hell_effect = $m_warning
channel.dgl_message = $m_attention

####### Message-specific colors
msc := message_colour

# Travel / Exploring
msc ^= $m_alert:You now have enough gold to buy 
msc ^= $m_alert:You have identified the last 
msc ^= $m_boring:You .*(open|close) the door
msc ^= $m_boring:You climb (upwards|downwards)
msc ^= $m_interesting:Done exploring
msc ^= $m_interesting:Found a faded altar
msc ^= $m_interesting:You disentangle yourself
msc ^= $m_warning:You are caught in .* web

# Combat
msc ^= $m_boring:(T|t)he (bush|plant|fungus)
msc ^= $m_boring:does no damage
msc ^= $m_boring:You block .* attack
msc ^= $m_boring:fails to defend itself
msc ^= $m_boring:No (reachable )?target in view
msc ^= $m_boring:struggles against the net
msc ^= $m_boring:You furiously retaliate
msc ^= $m_boring:You swing at nothing
msc ^= $m_boring:You hear a splash
msc ^= $m_interesting:flickers and vanishes
msc ^= $m_interesting:is touched by paradox
msc ^= $m_interesting:seems to slow down
msc ^= $m_interesting:Your unstable footing causes you to 
msc ^= $m_interesting:You become entangled in the net
msc ^= $m_interesting:You feel a bit more experienced
msc ^= $m_interesting:You .*miss something
msc ^= $m_interesting:You are blasted

# Equipment
msc ^= $m_boring:You unwield your 

# Bad things
msc ^= $m_danger: delaying your translocation

############################### End rc/display.rc ###############################
##########################################################################################

################################### Begin rc/fm-messages.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
more := force_more_message
flash := flash_screen_message

# Almost worth removing
#force_more_message -= You bow before the missionary of Beogh
#force_more_message -= You .* the altar of

# Remove annoying defaults
more -= You have reached level
more -= Marking area around .* as unsafe
more -= welcomes you( back)?!
more -= upon you is lifted
more -= You pick up the .* gem and feel its .* weight
more -= You pick up the .* rune and feel its power
more -= The lock glows eerily
more -= Heavy smoke blows from the lock
more -= The gate opens wide
more -= With a soft hiss the gate opens wide
more -= grants you (a gift|throwing weapons|a weapon)
more += grants you (a gift|a weapon)
more -= You finish merging with the rock

# Significant spells/effects ending
flash += You feel stable
more += is no longer charmed
more += You.*re starting to lose your buoyancy
# Death's Door
more += time is.*running out
more += life is in your own
# Death channel
more += unholy channel is weakening

# Monsters doing things
more += monster_warning:wielding.*of distortion
more += begins to recite a word of recall
more += There is.*feeling in your soul
more += wretched star pulses
more += Strange energies course through your body

flash += doors? slams? shut
flash += blows.*on a signal horn
flash += Deactivating autopickup
flash += Its appearance distorts for a moment
flash += The.*offers itself to Yredelemnul
flash += The forest starts to sway and rumble
flash += Your?.*suddenly stops? moving

# Crowd control
more += You.*(?<!( too|less)) confused
more += You .*(slow.*down|lose consciousness)
more += infuriates you
more += hits you .* distortion
more += Space .* around you
more += surroundings become eerily quiet
more += Your limbs are stiffening

flash += You .* (blown|knocked back|mesmerised|trampled|stumble backwards|encased)
flash += Your magical (effects|defenses) are (unraveling|stripped away)
flash += You stop (a|de)scending the stairs
flash += A sentinel's mark forms upon you
flash += The pull of.*song draws you forward
flash += engulfs you in water

# Clouds
more += danger:(calcify|mutagenic)
more += You.*re engulfed in.*miasma
flash += Miasma billows from the

# You Screwed Up
more += is no longer ready
more += You really shouldn't be using
more += You don't have enough magic to cast this spell
flash += Your body shudders with the violent release
flash += power of Zot

# Found something important
flash += You pick up the .* (gem|rune) and feel its 
more += Found.*the Ecumenical Temple
more += Found.*(treasure|bazaar|ziggurat)
more += .*resides here
more += You have a vision of.*gates?
more += Press the corresponding letter to learn more about a god
flash += timed_portal:.*

# Translocations
more += danger:sense of stasis
more += Your surroundings.*(different|flicker)
more += You.*re suddenly pulled into a different region
flash += You blink
flash += danger:You feel strangely .*stable
flash += delaying your translocation

# Big damage
more += your body is wracked
more += The poison in your body grows stronger
more += You.*re lethally poisoned
more += danger:You convulse
more += You feel a (horrible|terrible) chill
more += Your.*terribly
more += You are.*terribly

# Hit by something
more += Terrible wounds open
more += The air around.*erupts in flames
more += The air twists around and violently strikes you in flight
more += You shudder from the earth-shattering force
more += You feel.*(?<!less)( haunted| rot| vulnerable)
flash += danger:corrodes you
flash += Your damage is reflected back at you
flash += ^(?!Your? ).*reflects

# FYI
more += seems mollified
more += You have finished your manual

# Unexpected monsters
more += appears in a (shower|flash)
more += appears out of thin air
more += You sense the presence of something unfriendly
more += Wisps of shadow swirl around

# Misc
more += hell effect:.*
more += god:wrath finds you
more += The walls disappear

# Ashenzari
more += god:Ashenzari invites you to partake
# Dithmenos
more += god:You are shrouded in an aura of darkness
more += god:You.*bleed smoke
more += god:Your shadow.*tangibly mimics your actions
# Fedhas
more += god:Fedhas invokes the elements against you
# Jivya
more += god:will now unseal the treasures of the Slime Pits
more += god:Jiyva alters your body
# Kikubaaqudgha
more += god:Kikubaaqudgha will grant you
# Lugonu
more += god:Lugonu will now corrupt your weapon
more += god:Lugonu sends minions to punish you
# Okawaru
more += god:Okawaru sends forces against you
# Qazlal
flash += god:resistances upon receiving elemental damage
flash += god:You are surrounded by a storm which can block enemy attacks
# The Shining One
more += god:Your divine shield starts to fade
more += god:Your divine shield fades away
# Trog
more += god:You feel the effects of Trog's Hand fading
more += god:You feel less resistant to hostile enchantments
# Xom
more += staircase.*moves
more += Some monsters swap places
# Yredelemnul
more += god:soul is no.* ripe for the taking
more += god:dark mirror aura disappears
# Zin
more += god:will now cure all your mutations

############################### End rc/fm-messages.rc ###############################
##########################################################################################

################################### Begin rc/macros.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
# Remap ~ to Lua interpreter (CMD_GAME_MENU is still on F1)
bindkey = [~] CMD_LUA_CONSOLE

# Cntl-Tab
bindkey = [\{-222}] CMD_AUTOFIGHT_NOMOVE

# Cntl-D (Go down closest stairs)
macros += M \{4} \{7}>


# Numpad keymaps
macros += K \{-1019} f
macros += K \{-1018} 3
macros += K \{-1016} \{9}
macros += K \{-1015} 2
macros += K \{-1012} 1
macros += K \{-1010} o
macros += K \{-1000} .
macros += K \{-247} 5
macros += K2 \{-1019} .

# Spellcasting macros
macros += M 1 za
macros += M 2 zb
macros += M 3 zc
macros += M 4 zd
macros += M 6 zf
macros += M 7 zg
macros += M 8 zh
macros += M 9 zi
macros += M 0 zj

# Confirm targeting with same keys as spellcasting
macros += K2 \{-1018} \{13}
macros += K2 \{-1015} \{13}
macros += K2 \{-1012} \{13}
macros += K2 1 \{13}
macros += K2 2 \{13}
macros += K2 3 \{13}
macros += K2 4 \{13}
macros += K2 6 \{13}
macros += K2 7 \{13}
macros += K2 8 \{13}
macros += K2 9 \{13}
macros += K2 0 \{13}

############################### End rc/macros.rc ###############################
##########################################################################################

################################### Begin rc/runrest.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
# Aliases
stop := runrest_stop_message
ignore := runrest_ignore_message

# Ignore these stops
interrupt_travel -= sense_monster
interrupt_travel -= mimic
ignore ^= "sense a monster nearby"
ignore ^= recovery:.*
ignore ^= duration:.*

# Monsters to ignore at a distance
runrest_ignore_monster += fire vortex:1

# Stop for consumables you want to use immediately
stop += potions? of experience
stop += scrolls? of acquirement

# Don't stop for noisy doors unless someone shouts back
stop -= it creaks loudly
stop -= flies open with a bang
stop += You hear

# Ignore some stops for ally actions, then stop on the rest
ignore -= friend_action:
ignore -= friend_spell:
ignore -= friend_enchant:
ignore ^= butterfly disappears
ignore ^= friend_action:(a|the) web
ignore ^= friend_action:(seems|blinks)
ignore ^= clockwork bee (falls|winds down)
stop += friend_action:
stop += friend_spell:
stop += friend_enchant:
stop += appears from out of your range of vision
stop += hits your
stop += our.*is destroyed

# Expiring effects; Turn on transmutation|flight|swiftness ending and ignore the rest
ignore -= transformation is almost over\.
ignore -= transformation has ended\.
ignore -= revert to.*form\.
ignore -= You feel yourself come back to life
ignore ^= unholy channel is weakening
ignore ^= magical contamination.*faded
ignore ^= our foxfire dissipates
stop ^= unholy channel expires
stop ^= are starting to lose your buoyancy
stop ^= You feel.*sluggish
# Expiring effects for friends too
stop ^= no longer petrified
ignore ^= no longer.*(covered in acid|unusually strong)
ignore ^= looks more healthy

# Misc
stop -= You now have enough gold to
stop ^= timed_portal:.*
ignore ^= nearby plant withers and dies
ignore ^= disentangle yourself
ignore ^= You swap places.

# Summonings
ignore ^= our.*crimson imp blinks
ignore ^= our.*simulacrum vaporises
ignore ^= our.*returns to the shadows of the Dungeon
ignore ^= our.*skeleton crumbles into dust
ignore ^= our.*fades into mist
ignore ^= our.*looks more healthy
ignore ^= our.*is no longer (corroded|moving slowly)
ignore ^= our.*dissolves into a puddle of slime

# Ashenzari
stop += god:Ashenzari invites you to partake
# Ru
stop += god:Ru believes you are ready to make a new sacrifice
# Hepliaklqana
ignore ^= emerges from the mists of memory
# Wu Jian Council
ignore += heavenly storm settles
# Yredelemnul
ignore += offer up the Black Torch's flame
ignore += mindless puppets stay behind to rot

############################### End rc/runrest.rc ###############################
##########################################################################################

################################### Begin rc/slot-defaults.rc ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
####### Item Slots #########
# Rings to P/p for easy swapping
item_slot += ring of:Pp

# ignored: moonshine, noise
# unassigned slots: d, e, F
item_slot ^= scroll of acquirement:q
item_slot ^= scroll of amnesia:E
item_slot ^= scroll of blinking:B
item_slot ^= scroll of brand weapon:D
item_slot ^= scroll of butterflies:s
item_slot ^= scroll of enchant armour:u
item_slot ^= scroll of enchant weapon:W
item_slot ^= scroll of fear:f
item_slot ^= scroll of fog:F
item_slot ^= scroll of identify:i
item_slot ^= scroll of immolation:o
item_slot ^= scroll of revelation:j
item_slot ^= scroll of poison:y
item_slot ^= scroll of silence:S
item_slot ^= scroll of summoning:s
item_slot ^= scroll of teleportation:t
item_slot ^= scroll of torment:k
item_slot ^= scroll of vulnerability:v

item_slot ^= potion of ambrosia:A
item_slot ^= potion of attraction:n
item_slot ^= potion of berserk rage:z
item_slot ^= potion of brilliance:R
item_slot ^= potion of cancellation:C
item_slot ^= potion of curing:c
item_slot ^= potion of experience:x
item_slot ^= potion of enlightenment:g
item_slot ^= potion of haste:H
item_slot ^= potion of heal wounds:h
item_slot ^= potion of invisibility:I
item_slot ^= potion of lignification:l
item_slot ^= potion of magic:M
item_slot ^= potion of might:m
item_slot ^= potion of resistance:r
item_slot ^= potion of mutation:U

item_slot ^= condenser vane:V
item_slot ^= phial of floods:O
item_slot ^= phantom mirror:N
item_slot ^= box of beasts:X
item_slot ^= tin of tremorstones:T
item_slot ^= lightning rod:L

item_slot ^= wand of digging:K
item_slot ^= wand of flame:Q
item_slot ^= wand of mindburst:Y
item_slot ^= wand of acid:G
item_slot ^= wand of light:G
item_slot ^= wand of quicksilver:G
item_slot ^= wand of iceblast:Z
item_slot ^= wand of roots:Z
item_slot ^= wand of charming:J
item_slot ^= wand of paralysis:J



######## Spell Slots #########
spell_slot ^= Alistair's Intoxication:AITX
spell_slot ^= Alistair’s Walking Alembic:AWKLMBSTEI
spell_slot ^= Anguish:ANGUISH
spell_slot ^= Animate Armour:ANMT
spell_slot ^= Animate Dead:ADNMT
spell_slot ^= Arcjolt:AJCOLT
spell_slot ^= Blink:BLNK
spell_slot ^= Borgnjor's Revivification:BRVF
spell_slot ^= Call Canine Familiar:CFN
spell_slot ^= Call Imp:ICMP
spell_slot ^= Cause Fear:CFSUR
spell_slot ^= Chain Lightning:LCHGNT
spell_slot ^= Cigotuvi's Dreadful Rot:CDRVT
spell_slot ^= Confusing Touch:CTF
spell_slot ^= Conjure Ball Lightning:BLCTN
spell_slot ^= Construct Spike Launcher:CSLPKNRAUE
spell_slot ^= Corpse Rot:CRPS
spell_slot ^= Death Channel:DCNL
spell_slot ^= Death's Door:DROTHEA
spell_slot ^= Detonation Catalyst:DCTNYTSAEO
spell_slot ^= Diamond Sawblades:DSWBLNIAO
spell_slot ^= Discord:DISCORD
spell_slot ^= Disjunction:DJNIS
spell_slot ^= Dispersal:DPLIS
spell_slot ^= Dragon's Call:DCRGN
spell_slot ^= Forge Monarch Bomb:FMBONRCHGEA
spell_slot ^= Forge Phalanx Beetle:FPBENXORG
spell_slot ^= Fortress Blast:FBRTSLA
spell_slot ^= Foxfire:FXOIRE
spell_slot ^= Fugue of the Fallen:FUGALNE
spell_slot ^= Fulsome Fusillade:FLSOMADE
spell_slot ^= Gloom:GLOM
spell_slot ^= Hoarfrost Cannonade:HCORFND
spell_slot ^= Ice Form:IFORM
spell_slot ^= Ignite Poison:IPOSN
spell_slot ^= Ignition:IGNTO
spell_slot ^= Infestation:INFESTAON
spell_slot ^= Irradiate:IRADTE
spell_slot ^= Iskenderun's Battlespehere:BSI
spell_slot ^= Iskenderun's Mystic Blast:IMB
spell_slot ^= Jinxbite:JNXBITE
spell_slot ^= Leda's Liquefaction:LQFND
spell_slot ^= Malign Gateway:MGWTN
spell_slot ^= Manifold Assault:MANFT
spell_slot ^= Martyr's Knell:MKNARTYEL
spell_slot ^= Maxwell's Capacitive Coupling:MCXW
spell_slot ^= Metabolic Englaciation:MENC
spell_slot ^= Monstrous Menagerie:MNGR
spell_slot ^= Nazja’s Percussive Tempering:NPTZJACUE
spell_slot ^= Olgreb's Toxic Radiance:TOR
spell_slot ^= Ozocubu's Armour:OAMR
spell_slot ^= Ozocubu's Refrigeration:ROZFG
spell_slot ^= Permafrost Eruption:PERUTFMAOSTIN
spell_slot ^= Platinum Paragon:PLTGNMAO
spell_slot ^= Polar Vortex:PVXT
spell_slot ^= Rending Blade:RBENDALG
spell_slot ^= Scorch:SCORH
spell_slot ^= Shatter:SHTR
spell_slot ^= Sigil of Binding:SBGILDNG
spell_slot ^= Silence:SICL
spell_slot ^= Spellspark Servitor:SVFR
spell_slot ^= Sphinx Sisters:SPHINXR
spell_slot ^= Starburst:SBUT
spell_slot ^= Static Discharge:DSCGT
spell_slot ^= Sublimation of Blood:SBLM
spell_slot ^= Summon Blazeheart Golem:SBGLZOM
spell_slot ^= Summon Cactus Giant:CGS
spell_slot ^= Summon Forest:FSRTM
spell_slot ^= Summon Horrible Things:HST
spell_slot ^= Summon Hydra:HYDRA
spell_slot ^= Summon Ice Beast:ISB
spell_slot ^= Summon Lightning Spire:SMLIRNG
spell_slot ^= Summon Mana Viper:MSV
spell_slot ^= Summon Seismosaurus Egg:EGSMIEOAU
spell_slot ^= Summon Small Mammal:SMLAUON
spell_slot ^= Swiftness:SWIFT
spell_slot ^= Volatile Blastmotes:VBOLMASTE
:if you.class() == "Summoner" then
  spell_slot ^= (summon|call):abcdefgh
:end

############################### End rc/slot-defaults.rc ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

### buehler.rc core files ###

################################### Begin lua/core/constants.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Constants - All constant definitions
Author: buehler
Dependencies: (none)
--]]

---- Initialize BRC namespace
BRC = BRC or {}

---- Cosmetic settings
BRC.EMOJI = {
  CAUTION = BRC.Config.emojis and "⚠️" or "<yellow>!</yellow>",
  EXCLAMATION = BRC.Config.emojis and "❗" or "<magenta>!</magenta>",
  EXCLAMATION_2 = BRC.Config.emojis and "‼️" or "<lightmagenta>!!</lightmagenta>",
  SUCCESS = BRC.Config.emojis and "✅" or nil,
} -- BRC.EMOJI (do not remove this comment)

---- Items ----
BRC.MISC_ITEMS = {
  "box of beasts", "condenser vane", "figurine of a ziggurat", "Gell's gravitambourine",
  "horn of Geryon", "lightning rod", "phantom mirror", "phial of floods", "sack of spiders",
  "tin of tremorstones",
} -- BRC.MISC_ITEMS (do not remove this comment)

-- This is checked against the full text of the pickup message, so use patterns to match
BRC.MISSILES = {
  "poisoned dart", "atropa-tipped dart", "curare-tipped dart", "datura-tipped dart",
  "darts? of disjunction", "darts? of dispersal", " stone", "boomerang",
  "silver javelin", "javelin", "large rock", "throwing net",
} -- BRC.MISSILES (do not remove this comment)

-- Could be removed after https://github.com/crawl/crawl/issues/4606 is addressed
BRC.SPELLBOOKS = {
  "parchment of", "book of", "Necronomicon", "Grand Grimoire", "tome of obsoleteness",
  "Everburning Encyclopedia", "Ozocubu's Autobiography", "Maxwell's Memoranda",
  "Young Poisoner's Handbook", "Fen Folio", "Inescapable Atlas", "There-And-Back Book",
  "Great Wizards, Vol. II", "Great Wizards, Vol. VII", "Trismegistus Codex",
  "the Unrestrained Analects", "Compendium of Siegecraft", "Codex of Conductivity",
  "Handbook of Applied Construction", "Treatise on Traps", "My Sojourn through Swampland",
  "Akashic Record",
  -- Include prefixes for randart books
  "Almanac", "Anthology", "Atlas", "Book", "Catalogue", "Codex", "Compendium",
  "Compilation", "Cyclopedia", "Directory", "Elucidation", "Encyclopedia", "Folio",
  "Grimoire", "Handbook", "Incunable", "Incunabulum", "Octavo", "Omnibus", "Papyrus",
  "Parchment", "Precepts", "Quarto", "Secrets", "Spellbook", "Tome", "Vellum", "Volume",
} -- BRC.SPELLBOOKS (do not remove this comment)

---- Races ----
BRC.UNDEAD_RACES = { "Demonspawn", "Mummy", "Poltergeist", "Revenant" }
BRC.NONLIVING_RACES = { "Djinni", "Gargoyle" }
BRC.POIS_RES_RACES = { "Djinni", "Gargoyle", "Mummy", "Naga", "Poltergeist", "Revenant" }
BRC.LITTLE_RACES = { "Spriggan" }
BRC.SMALL_RACES = { "Kobold" }
BRC.LARGE_RACES = { "Armataur", "Naga", "Oni", "Troll" }

---- Skills ----
BRC.MAGIC_SCHOOLS = {
  air = "Air Magic", alchemy = "Alchemy", cold = "Ice Magic", conjuration = "Conjurations",
  death = "Necromancy", earth = "Earth Magic", fire = "Fire Magic",   necromancy = "Necromancy",
} -- BRC.MAGIC_SCHOOLS (do not remove this comment)

BRC.TRAINING_SKILLS = {
  "Air Magic", "Alchemy", "Armour", "Axes", "Conjurations", "Dodging", "Earth Magic",
  "Evocations", "Fighting", "Fire Magic", "Forgecraft", "Hexes", "Ice Magic",
  "Invocations", "Long Blades", "Maces & Flails", "Necromancy", "Polearms",
  "Ranged Weapons", "Shapeshifting", "Shields", "Short Blades", "Spellcasting", "Staves",
  "Stealth", "Summonings", "Translocations", "Unarmed Combat", "Throwing",
} -- BRC.TRAINING_SKILLS (do not remove this comment)

BRC.WEAP_SCHOOLS = {
  "axes", "maces & flails", "polearms", "long blades", "short blades",
  "staves", "unarmed combat", "ranged weapons",
} -- BRC.WEAP_SCHOOLS (do not remove this comment)

---- Branches ----
BRC.HELL_BRANCHES = { "Coc", "Dis", "Geh", "Hell", "Tar" }
BRC.PORTAL_NAMES = {
  "Bailey", "Bazaar", "Desolation", "Gauntlet", "Ice Cave", "Necropolis",
  "Ossuary", "Sewer", "Trove", "Volcano", "Wizlab", "Zig",
} -- BRC.PORTAL_NAMES (do not remove this comment)

---- Egos + artefact properties ----
BRC.RISKY_EGOS = { "antimagic", "chaos", "distort", "harm", "heavy", "Infuse", "Ponderous" }
BRC.NON_ELEMENTAL_DMG_EGOS = { "distort", "heavy", "spect" }
BRC.BAD_ART_PROPS = {
  "Bane", "-Cast", "-Move", "-Tele",
  "*Corrode", "*Noise", "*Rage", "*Silence", "*Slow", "*Tele",
} -- BRC.BAD_ART_PROPS (do not remove this comment)

---- Other ----
BRC.KEYS = { ESC = 27 }

BRC.COL = {
  black = "0", blue = "1", green = "2", cyan = "3", red = "4", magenta = "5", brown = "6",
  lightgrey = "7", darkgrey = "8", lightblue = "9", lightgreen = "10",
  lightcyan = "11", lightred = "12", lightmagenta = "13", yellow = "14", white = "15",
} -- BRC.COL (do not remove this comment)

BRC.DMG_TYPE = {
  unbranded = 1, -- No brand
  plain = 2, -- Include brand dmg with no associated damage type
  branded = 3, -- Include full brand dmg
  scoring = 4, -- Include boosts for non-damaging brands
} -- BRC.DMG_TYPE (do not remove this comment)

BRC.SIZE_PENALTY = { LITTLE = -2, SMALL = -1, NORMAL = 0, LARGE = 1, GIANT = 2 }

}
############################### End lua/core/constants.lua ###############################
##########################################################################################

################################### Begin lua/core/util.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC Utility Functions - All utility functions organized into logical tables
Author: buehler
Dependencies: core/config.lua, core/constants.lua
--]]

---- Initialize BRC namespace
BRC = BRC or {}

---- Local variables ----
-- Init in declaration, since there's no BRC.util.init()
local _mpr_queue = {}

---- Local functions ----
local function cap_lines(str)
  if BRC.Data.Config.max_lines_per_table and BRC.Data.Config.max_lines_per_table > 0 then
    local lines = BRC.util.count_lines(str)
    if lines > BRC.Data.Config.max_lines_per_table then
      return string.format("{ %s lines... }", lines)
    end
  end
  return str
end

local function log_message(message, context, color)
  -- Avoid referencing BRC, to stay robust during startup
  color = color or "lightgrey"
  local msg = "[BRC] " .. tostring(message)
  if context then msg = string.format("%s (%s)", msg, tostring(context)) end
  crawl.mpr(string.format("<%s>%s</%s>", color, msg, color))
  crawl.flush_prev_message()
end

local function serialize_chk_lua_save()
  local tokens = { BRC.text.lightblue("\n---CHK_LUA_SAVE---") }
  for _, func in ipairs(chk_lua_save) do
    local result = func()
    if result and #result > 0 then tokens[#tokens + 1] = util.trim(result) end
  end

  return table.concat(tokens, "\n")
end

local function serialize_inventory()
  local tokens = { BRC.text.lightcyan("\n---INVENTORY---\n") }
  for _, inv in ipairs(items.inventory()) do
    local base = inv.name("base") or "N/A"
    local cls = inv.class(true) or "N/A"
    local st = inv.subtype() or "N/A"
    tokens[#tokens + 1] = string.format("%s: (%s) Qual: %s", inv.slot, inv.quantity, inv.name())
    tokens[#tokens + 1] = string.format("  Base: %s Class: %s, Subtype: %s\n", base, cls, st)
  end

  return table.concat(tokens)
end

--- Stringify BRC.Config and all feature configs, including headers
local function serialize_config()
  local tokens = {}
  tokens[#tokens + 1] = BRC.text.lightcyan("\n---BRC Config---\n")
  tokens[#tokens + 1] = BRC.util.tostring(BRC.Config, true)

  local all_features = BRC.get_registered_features()
  local keys = util.keys(all_features)
  util.sort(keys)

  for i = 1, #keys do
    local name = keys[i]
    local feature = all_features[name]
    if feature.Config then
      local header = BRC.text.cyan("\n\n---Feature Config: " .. name .. "---\n")
      tokens[#tokens + 1] = header .. BRC.util.tostring(feature.Config, true)
    end
  end

  return table.concat(tokens)
end

-----------------------------------
---- BRC.log - Logging methods ----
BRC.log = {}

--- Primary function for displaying errors. Includes a force_more_message by default.
-- @param context (optional) Additional context. No context if params are (string, bool).
function BRC.log.error(message, context, skip_more)
  if type(context) == "boolean" and skip_more == nil then
    skip_more = context
    context = nil
  end

  log_message("(Error) " .. message, context, BRC.COL.lightred)
  you.stop_activity()
  crawl.redraw_screen()

  if not skip_more then
    crawl.more()
    crawl.redraw_screen()
  end
end

function BRC.log.warning(message, context)
  log_message(message, context, BRC.COL.yellow)
  you.stop_activity()
end

function BRC.log.info(message, context)
  log_message(message, context, BRC.COL.white)
end

function BRC.log.debug(message, context)
  if BRC.Config.show_debug_messages then
    log_message(message, context, BRC.COL.lightblue)
  end
  if BRC.Config.debug_to_stderr then
    crawl.stderr("[BRC] (Debug) " .. message)
  end
end

---------------------------------------------------
---- BRC.text - Text color + parsing functions ----
BRC.text = {}

--- Remove newlines and tags from text
function BRC.text.clean(text)
  return text:gsub("\n", ""):gsub("<[^>]*>", "")
end

-- Wrap text in a color tag, Usage: BRC.text.blue("Hello"), or BRC.text["1"]("Hello")
for k, v in pairs(BRC.COL) do
  BRC.text[k] = function(text)
    return string.format("<%s>%s</%s>", v, tostring(text), v)
  end
  BRC.text[v] = BRC.text[k]
end

function BRC.text.capitalize(s)
  if not s or s == "" then return s end
  return string.upper(string.sub(s, 1, 1)) .. string.lower(string.sub(s, 2))
end

function BRC.text.color(color, text)
  return color and BRC.text[color](text) or tostring(text)
end

function BRC.text.contains(self, text)
  return self:find(text, 1, true) ~= nil
end
-- Connect string:contains() to BRC.text.contains()
getmetatable("").__index.contains = BRC.text.contains

function BRC.text.wrap(text, wrapper, no_space)
  if not wrapper then return text end
  return table.concat({ wrapper, text, wrapper }, no_space and "" or " ")
end

function BRC.text.get_pickup_info(text)
  local cleaned = BRC.text.clean(text)
  if cleaned:sub(2, 4) ~= " - " then return nil end
  return cleaned:sub(5, #cleaned), items.letter_to_index(cleaned:sub(1, 1))
end

---------------------------------------------
---- BRC.mpr - Wrappers around crawl.mpr ----
BRC.mpr = {}

--- Output message in color. Usage: BRC.mpr.white("Hello"), or BRC.mpr["15"]("Hello")
for k, v in pairs(BRC.COL) do
  BRC.mpr[k] = function(msg, channel)
    crawl.mpr(BRC.text.color(v, msg), channel)
    crawl.flush_prev_message()
  end
  BRC.mpr[v] = BRC.mpr[k]
end

function BRC.mpr.color(msg, color, channel)
  if color then
    BRC.mpr[color](msg, channel)
  else
    crawl.mpr(tostring(msg), channel)
    crawl.flush_prev_message()
  end
end

function BRC.mpr.okay(suffix)
  BRC.mpr.darkgrey("Okay, then." .. (suffix and " " .. suffix or ""))
end

-- Message plus stop travel/activity
function BRC.mpr.stop(msg, color, channel)
  BRC.mpr.color(msg, color, channel)
  you.stop_activity()
end

-- Message as a force_more_message
function BRC.mpr.more(msg, color, channel)
  BRC.mpr.color(msg, color, channel)
  you.stop_activity()
  crawl.redraw_screen()
  crawl.more()
  crawl.redraw_screen()
end

-- Conditional force_more_message
function BRC.mpr.optmore(show_more, msg, color, channel)
  if show_more then
    BRC.mpr.more(msg, color, channel)
  else
    BRC.mpr.color(msg, color, channel)
  end
end

--- Queue the message to dispay at the end of ready()
function BRC.mpr.que(msg, color, channel)
  BRC.mpr.que_optmore(false, msg, color, channel)
end

-- Queue msg w/ conditional force_more_message
function BRC.mpr.que_optmore(show_more, msg, color, channel)
  for _, q in ipairs(_mpr_queue) do
    if q.m == msg and q.ch == channel and q.more == show_more then return end
  end
  _mpr_queue[#_mpr_queue + 1] = { m = BRC.text.color(color, msg), ch = channel, more = show_more }
end

--- Display queued messages and clear the queue
function BRC.mpr.consume_queue()
  local do_more = util.exists(_mpr_queue, function(q) return q.more end)
  -- stop_activity() can generate more autopickups, and thus more queue'd messages
  if do_more then
    you.stop_activity()
    crawl.redraw_screen()
  end

  for _, msg in ipairs(_mpr_queue) do
    crawl.mpr(tostring(msg.m), msg.ch)
    crawl.flush_prev_message()
  end
  _mpr_queue = {}

  if do_more then
    crawl.more()
    crawl.redraw_screen()
  end
end

--- Get a selection from the user, from a list of options
function BRC.mpr.select(msg, options, color)
  if not (type(options) == "table" and #options > 0) then
    BRC.log.error("No options provided for BRC.mpr.select")
    return false
  end

  msg = msg .. ":\n"
  for i, option in ipairs(options) do
    msg = msg .. string.format("%s: %s\n", i, BRC.text.white(option))
  end
  BRC.mpr[color or BRC.COL.lightcyan](msg, "prompt")
  for _ = 1, 10 do
    local res = crawl.getch()
    if res then
      local num = res - string.byte("0")
      if num > 0 and num <= #options then return options[num] end
    end
    BRC.mpr.magenta("Invalid option, try again.")
  end

  BRC.mpr.lightmagenta("Fine then. Using option 1: " .. options[1])
  return options[1]
end

-- Get a yes/no response
function BRC.mpr.yesno(msg, color, capital_only)
  msg = string.format("%s (%s)", msg, capital_only and "Y/N" or "y/n")

  for i = 1, 10 do
    BRC.mpr.color(msg, color, "prompt")
    local res = crawl.getch()
    if res and res >= 0 and res <= 255 then
      local c = string.char(res)
      if c == "Y" or c == "y" and not capital_only then return true end
      if c == "N" or c == "n" and not capital_only then return false end
    end
    if i == 1 and capital_only then msg = "[CAPS ONLY] " .. msg end
  end

  BRC.mpr.lightmagenta("Feels like a no.")
  return false
end

-----------------------------------------------------
---- BRC.get - Functions to get non-boolean data ----
BRC.get = {}

function BRC.get.command_key(cmd)
  local key = crawl.get_command(cmd)
  if not key or key == "NULL" then return nil end
  -- get_command returns things like "Uppercase Ctrl-S"; we just want 'S'
  local char_key = key:sub(-1)
  return key:contains("Ctrl") and BRC.util.cntl(char_key) or char_key
end

--[[
BRC.get.equipped_at() - Returns 2 values (usually a list of length 1, with num_slots==1):
  1. A list of equipped items at the same slot as the item
  2. the num_slots (ie maximum size the list can ever be)
--]]
function BRC.get.equipped_at(it)
  local all_aux = {}
  local num_slots = BRC.get.num_equip_slots(it)
  local slot_name = it.is_weapon and "weapon"
    or BRC.is.body_armour(it) and "armour"
    or it.subtype()

  for i = 1, num_slots do
    local eq = items.equipped_at(slot_name, i)
    all_aux[#all_aux + 1] = eq
  end

  return all_aux, num_slots
end

function BRC.get.item_xy(name, radius)
  local r = radius or you.los()
  for dx = -r, r do
    for dy = -r, r do
      for _, fl in ipairs(items.get_items_at(dx, dy) or {}) do
        if fl.name() == name then
          return dx, dy
        end
      end
    end
  end
end

function BRC.get.items_in_slot(idx)
  local res = {}
  for _, inv in ipairs(items.inventory()) do
    if inv.slot == idx then
      res[#res + 1] = inv
    end
  end

  return res
end

--- Get mutation level, explicitly specifying crawl's optional params
-- @param bool innate_only (optional) - Exclude to include all mutations
function BRC.get.mut(mutation, innate_only)
  return you.get_base_mutation_level(mutation, true, not innate_only, not innate_only)
end

function BRC.get.num_equip_slots(it)
  local player_race = you.race()
  if it.is_weapon then return player_race == "Coglin" and 2 or 1 end
  if BRC.is.aux_armour(it) then
    if player_race == "Formicid" then return it.subtype() == "gloves" and 2 or 1 end
    return player_race == "Poltergeist" and 6 or 1
  end

  return 1
end

function BRC.get.preferred_weapon_type()
  local max_weap_skill = 0
  local pref = nil
  for _, v in ipairs(BRC.WEAP_SCHOOLS) do
    if BRC.get.skill(v) > max_weap_skill then
      max_weap_skill = BRC.get.skill(v)
      pref = v
    end
  end
  return pref
end

function BRC.get.skill(skill)
  if skill and not skill:contains(",") then return you.skill(skill) end

  local skills = crawl.split(skill, ",")
  local sum = 0
  local count = 0
  for _, s in ipairs(skills) do
    sum = sum + you.skill(s)
    count = count + 1
  end

  return sum / count
end

function BRC.get.skill_with(it)
  if BRC.is.magic_staff(it) then
    return math.max(BRC.get.skill(BRC.get.staff_school(it)), BRC.get.skill("Staves"))
  end
  if it.is_weapon then return BRC.get.skill(it.weap_skill) end
  if BRC.is.body_armour(it) then return BRC.get.skill("Armour") end
  if BRC.is.shield(it) then return BRC.get.skill("Shields") end
  if BRC.is.talisman(it) then return BRC.you.shapeshifting_skill() end

  return nil
end

function BRC.get.staff_school(it)
  for k, v in pairs(BRC.MAGIC_SCHOOLS) do
    if it.subtype() == k then return v end
  end
end

function BRC.get.talisman_min_level(it)
  if it.name() == "protean talisman" then return 6 end

  -- Parse the item description
  local tokens = crawl.split(it.description, "\n")
  for _, v in ipairs(tokens) do
    if v:sub(1, 4) == "Min " then
      local start_pos = v:find("%d", 4)
      if start_pos then
        local end_pos = v:find("[^%d]", start_pos)
        return tonumber(v:sub(start_pos, end_pos - 1))
      end
    end
  end

  BRC.log.error("Failed to find skill required for: " .. it.name())
  return -1
end

------------------------------------------
---- BRC.is - Boolean checks of items ----
BRC.is = {}

function BRC.is.amulet(it)
  return it and it.name("base") == "amulet"
end

function BRC.is.armour(it, include_orbs)
  return it and it.class(true) == "armour" and (include_orbs or not BRC.is.orb(it))
end

function BRC.is.aux_armour(it)
  return BRC.is.armour(it) and not (BRC.is.body_armour(it) or BRC.is.shield(it))
end

function BRC.is.body_armour(it)
  return it and it.subtype() == "body"
end

function BRC.is.jewellery(it)
  return it and it.class(true) == "jewellery"
end

function BRC.is.list(value)
  return value and type(value) == "table" and #value > 0
end

function BRC.is.magic_staff(it)
  return it and it.class and it.class(true) == "magical staff"
end

function BRC.is.map(value)
  return value and type(value) == "table" and next(value) ~= nil and #value == 0
end

function BRC.is.ring(it)
  return it and it.name("base") == "ring"
end

function BRC.is.scarf(it)
  return BRC.is.armour(it) and it.subtype() == "cloak" and it.name():contains("scarf")
end

function BRC.is.shield(it)
  return it and it.is_shield()
end

function BRC.is.talisman(it)
  return it and it.class(true) == "talisman"
end

function BRC.is.orb(it)
  return it and it.subtype() == "offhand" and not it.is_shield()
end

function BRC.is.polearm(it)
  return it and it.weap_skill:contains("Polearms")
end

-------------------------------------------------------
---- BRC.you - Boolean attributes of the character ----
BRC.you = {}

function BRC.you.by_slimy_wall()
  for x = -1, 1 do
    for y = -1, 1 do
      if view.feature_at(x, y) == "slimy_wall" then return true end
    end
  end
  return false
end

function BRC.you.free_offhand()
  if BRC.get.mut("missing a hand") > 0 then return true end
  return not items.equipped_at("offhand")
end

function BRC.you.have_shield()
  return BRC.is.shield(items.equipped_at("offhand"))
end

function BRC.you.in_hell(exclude_vestibule)
  local branch = you.branch()
  if exclude_vestibule and branch == "Hell" then return false end
  return util.contains(BRC.HELL_BRANCHES, branch)
end

function BRC.you.miasma_immune()
  if util.contains(BRC.UNDEAD_RACES, you.race()) then return true end
  if util.contains(BRC.NONLIVING_RACES, you.race()) then return true end
  return false
end

function BRC.you.mutation_immune()
  return util.contains(BRC.UNDEAD_RACES, you.race())
end

function BRC.you.shapeshifting_skill()
  local skill = you.skill("Shapeshifting")
  local AMU = "amulet of wildshape"
  if util.exists(items.inventory(), function(i) return i.name("qual") == AMU end) then
    return skill + 5
  end
  return skill
end

function BRC.you.zero_stat()
  return you.strength() <= 0 or you.dexterity() <= 0 or you.intelligence() <= 0
end

--------------------------------------------------
---- BRC.set - Wrappers around crawl.setopt() ----
BRC.set = {}

function BRC.set.autopickup_exceptions(pattern, add_pattern)
  local op = add_pattern and "^=" or "-="
  crawl.setopt(string.format("autopickup_exceptions %s %s", op, pattern))
end

function BRC.set.explore_stop(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop %s %s", op, pattern))
end

function BRC.set.explore_stop_pickup_ignore(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("explore_stop_pickup_ignore %s %s", op, pattern))
end

function BRC.set.flash_screen_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("flash_screen_message %s %s", op, pattern))
end

function BRC.set.force_more_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("force_more_message %s %s", op, pattern))
end

-- Binds a macro to a key. Function must be global and not a member of a module.
function BRC.set.macro(key, function_name)
  BRC.log.debug(
    string.format(
      "Assigning macro: %s to key: %s",
      BRC.text.magenta(function_name .. "()"),
      BRC.text.lightred("<<< '" .. key .. "' >>")
    )
  )
  crawl.setopt(string.format("macros += M %s ===%s", key, function_name))
end

function BRC.set.message_mute(pattern, mute_pattern)
  local op = mute_pattern and "^=" or "-="
  crawl.setopt(string.format("message_colour %s mute:%s", op, pattern))
end

function BRC.set.runrest_ignore_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_ignore_message %s %s", op, pattern))
end

function BRC.set.runrest_stop_message(pattern, add_pattern)
  local op = add_pattern and "+=" or "-="
  crawl.setopt(string.format("runrest_stop_message %s %s", op, pattern))
end

function BRC.set.single_turn_mute(pattern)
  BRC.set.message_mute(pattern, true)
  BRC.single_turn_mutes[#BRC.single_turn_mutes + 1] = pattern
end

------------------------------------------------------------------------------
--- BRC.dump - Debugging messages for char dump or in-game lua interpreter ---
BRC.dump = {}

--- Main dump for debugging
-- @param skip_mpr (optional bool) Used in char dump macro to only return the string
function BRC.dump.all(verbose, skip_mpr)
  local tokens = {}
  tokens[#tokens + 1] = BRC.Data.serialize()
  if verbose then
    tokens[#tokens + 1] = serialize_chk_lua_save()
    tokens[#tokens + 1] = serialize_inventory()
    tokens[#tokens + 1] = f_pa_weapons.serialize_weapon_cache()
    tokens[#tokens + 1] = serialize_config()
  end

  local text = table.concat(tokens, "\n")
  if not skip_mpr then BRC.mpr.white(text) end

  return text
end

function BRC.dump.char(add_debug_info)
  if add_debug_info then
    crawl.take_note(BRC.dump.all(true, true))
    BRC.mpr.lightgrey("BRC debug info added to character dump.")
  else
    BRC.mpr.darkgrey("No debug info added.")
  end
  BRC.util.do_cmd("CMD_CHARACTER_DUMP")
end

function BRC.dump.var(v)
  crawl.mpr(BRC.util.tostring(v, true) or "nil")
end

function macro_brc_dump_character()
  if not BRC.active then BRC.util.do_cmd("CMD_CHARACTER_DUMP") end
  BRC.dump.char(BRC.mpr.yesno("Add BRC debug info to character dump?", BRC.COL.lightcyan))
end

--- Cntl-E (Go up closest stairs)
function macro_brc_cntl_e()
  if you.where() == "D:1" and you.have_orb() then
    crawl.sendkeys({ "X", "<", "\r", BRC.KEYS.ESC, "<" }) -- {ESC, <} handles standing on stairs
  else
    crawl.sendkeys({ BRC.util.cntl("g"), "<" })
  end
end

----------------------------------------------
---- BRC.util - General utility functions ----
BRC.util = {}

function BRC.util.cntl(c)
  return string.byte(c:upper()) - 64
end

function BRC.util.count_lines(str)
  if type(str) ~= "string" then return 0 end
  local count = 1
  str:gsub("\n", function() count = count + 1 end)
  return count
end

--- Tries keypress first, then crawl.do_commands() (which isn't always immediate)
-- @param cmd (string) The command to execute like "CMD_EXPLORE"
function BRC.util.do_cmd(cmd)
  local key = BRC.get.command_key(cmd)
  if key then
    crawl.sendkeys({ key })
  else
    crawl.do_commands({ cmd })
  end
end

function BRC.util.int2char(num)
  return string.char(string.byte("a") + num)
end

--- Sorts the keys of a dictionary/map: vars before tables, then alphabetically by key
--- If a list is passed, it assumed it is a list of global variable names
function BRC.util.get_sorted_keys(map_or_list)
  local keys_vars = {}
  local keys_tables = {}

  if BRC.is.map(map_or_list) then
    for key, v in pairs(map_or_list) do
      table.insert(type(v) == "table" and keys_tables or keys_vars, key)
    end
  else
    for _, key in ipairs(map_or_list) do
      table.insert(type(_G[key]) == "table" and keys_tables or keys_vars, key)
    end
  end

  util.sort(keys_vars)
  util.sort(keys_tables)
  util.append(keys_vars, keys_tables)
  return keys_vars
end

--- Serializes a variable to a string, for chk_lua_save or data dumps.
-- @param pretty (optional bool) format for human readability
-- @param _indents (optional int) Used internally to format multi-line tables
function BRC.util.tostring(var, pretty, _indents)
  local var_type = type(var)
  if var_type == "string" then
    local s
    if var:contains("\n") then
      s = string.format("[[\n%s]]", var)
    else
      s = '"' .. var:gsub('"', "") .. '"'
    end

    if not pretty then return s end
    -- Replace > and < to display the color tags instead of colored text
    return s:gsub(">", "TempGT"):gsub("<", "TempLT"):gsub("TempGT", "<gt>"):gsub("TempLT", "<lt>")
  elseif var_type == "table" then
    _indents = _indents or 0
    local indent = string.rep("  ", _indents)
    local child_indent = string.rep("  ", _indents + 1)
    local list_sep = ",\n" .. child_indent

    if BRC.is.list(var) then
      local tokens = {}
      for _, v in ipairs(var) do
        tokens[#tokens + 1] = cap_lines(BRC.util.tostring(v, pretty, _indents + 1))
      end
      if #tokens < 4 and not util.exists(var, function(t) return type(t) == "table" end) then
        return "{ " .. table.concat(tokens, ", ") .. " }"
      else
        return "{\n" .. child_indent .. table.concat(tokens, list_sep) .. "\n" .. indent .. "}"
      end
    elseif BRC.is.map(var) then
      local tokens = {}
      if pretty then
        local keys = BRC.util.get_sorted_keys(var)
        local contains_table = false
        for i = 1, #keys do
          local v = cap_lines(BRC.util.tostring(var[keys[i]], true, _indents + 1))
          if v then
            if type(var[keys[i]]) == "table" then
              contains_table = true
              tokens[#tokens + 1] = string.format('["%s"] = %s', keys[i], v)
            else
              tokens[#tokens + 1] = string.format("%s = %s", keys[i], v)
            end
          end
        end
        if #tokens <= 2 and not contains_table then
          return "{ " .. table.concat(tokens, ", ") .. " }"
        end
      else
        for k, v in pairs(var) do
          tokens[#tokens + 1] = '["' .. k .. '"] = ' .. BRC.util.tostring(v, pretty, _indents + 1)
        end
      end
      return "{\n" .. child_indent .. table.concat(tokens, list_sep) .. "\n" .. indent .. "}"
    else
      return "{}"
    end
  else
    if BRC.Data.Config.skip_pointers and (type(var) == "function" or type(var) == "userdata") then
      return nil
    end
    return tostring(var)
  end
end

--[[
The functions above are general purpose: They should apply to any crawl RC file.
The functions below contain design choices or logic that are somewhat specific to BRC.
Examples: Weapon DPS calculation, treat dragon scales as branded, defining what a "risky item" is.
--]]

---- Local functions ---- (Often mirroring calculations that live in crawl.)
-- Last verified against: dcss v0.33.1

local function format_dmg(dmg)
  -- Format damage values for consistent display width (4 characters)
  if dmg < 10 then return string.format("%.2f", dmg) end
  if dmg > 99.9 then return ">100" end
  return string.format("%.1f", dmg)
end

--- Format as armour/weapon stat to a string for display or inscription
local function format_stat(abbr, val, is_worn)
  local stat_str = string.format("%.1f", val)
  if val < 0 then
    return string.format("%s%s", abbr, stat_str)
  elseif is_worn then
    return string.format("%s:%s", abbr, stat_str)
  else
    return string.format("%s+%s", abbr, stat_str)
  end
end

local function get_size_penalty()
  if util.contains(BRC.LITTLE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LITTLE
  elseif util.contains(BRC.SMALL_RACES, you.race()) then
    return BRC.SIZE_PENALTY.SMALL
  elseif util.contains(BRC.LARGE_RACES, you.race()) then
    return BRC.SIZE_PENALTY.LARGE
  else
    return BRC.SIZE_PENALTY.NORMAL
  end
end

local function get_unadjusted_armour_pen(encumb)
  local pen = encumb - 2 * BRC.get.mut("sturdy frame")
  if pen > 0 then return pen end
  return 0
end

local function get_adjusted_armour_pen(encumb, str)
  local base_pen = get_unadjusted_armour_pen(encumb)
  return 2 * base_pen * base_pen * (45 - you.skill("Armour")) / 45 / (5 * (str + 3))
end

local function get_adjusted_dodge_bonus(encumb, str, dex)
  local size_factor = -2 * get_size_penalty()
  local dodge_bonus = 8 * (10 + you.skill("Dodging") * dex) / (20 - size_factor) / 10
  local armour_dodge_penalty = get_unadjusted_armour_pen(encumb) - 3
  if armour_dodge_penalty <= 0 then return dodge_bonus end

  if armour_dodge_penalty >= str then return dodge_bonus * str / (armour_dodge_penalty * 2) end
  return dodge_bonus - dodge_bonus * armour_dodge_penalty / (str * 2)
end

local function get_shield_penalty(sh)
  return 2 * sh.encumbrance * sh.encumbrance
    * (27 - you.skill("Shields")) / 27
    / (25 + 5 * you.strength())
end

local function get_branded_delay(delay, ego)
  if not ego then return delay end
  if ego == "speed" then
    return delay * 2 / 3
  elseif ego == "heavy" then
    return delay * 1.5
  end
  return delay
end

local function get_weap_min_delay(it)
  -- This is an abbreviated version of the actual calculation.
  -- Doesn't check brand or delay >=3, which are covered in get_weap_delay()
  if it.artefact and it.name("qual"):contains("woodcutter's axe") then return it.delay end

  local min_delay = math.floor(it.delay / 2)
  if it.weap_skill == "Short Blades" then return 5 end
  if it.is_ranged then
    local basename = it.name("base")
    local is_2h_ranged = basename:contains("crossbow") or basename:contains("arbalest")
    if is_2h_ranged then return math.max(min_delay, 10) end
  end

  return math.min(min_delay, 7)
end

local function get_weap_delay(it)
  -- dcss v0.33.1
  local delay = it.delay - BRC.get.skill(it.weap_skill) / 2
  delay = math.max(delay, get_weap_min_delay(it))
  delay = get_branded_delay(delay, BRC.get.ego(it))
  delay = math.max(delay, 3)

  local sh = items.equipped_at("offhand")
  if BRC.is.shield(sh) then delay = delay + get_shield_penalty(sh) end

  if it.is_ranged then
    local worn = items.equipped_at("armour")
    if worn then
      local str = you.strength()

      local cur = items.equipped_at("weapon")
      if cur and cur ~= it and cur.artefact then
        if it.artefact and it.artprops["Str"] then str = str + it.artprops["Str"] end
        if cur.artefact and cur.artprops["Str"] then str = str - cur.artprops["Str"] end
      end

      delay = delay + get_adjusted_armour_pen(worn.encumbrance, str)
    end
  end

  return delay / 10
end

local function get_slay_bonuses()
  local sum = 0

  -- Slots can go as high as 18 afaict
  for i = 0, 20 do
    local inv = items.equipped_at(i)
    if inv then
      if BRC.is.ring(inv) then
        if inv.artefact then
          local name = inv.name()
          local idx = name:find("Slay", 1, true)
          if idx then
            local slay = tonumber(name:sub(idx + 5, idx + 5))
            if slay == 1 then
              local next_digit = tonumber(name:sub(idx + 6, idx + 6))
              if next_digit then slay = 10 + next_digit end
            end

            if name:sub(idx + 4, idx + 4) == "+" then
              sum = sum + slay
            else
              sum = sum - slay
            end
          end
        elseif BRC.get.ego(inv) == "Slay" then
          sum = sum + inv.plus
        end
      elseif inv.artefact and (BRC.is.armour(inv, true) or BRC.is.amulet(inv)) then
        local slay = inv.artprops["Slay"]
        if slay then sum = sum + slay end
      end
    end
  end

  if you.race() == "Demonspawn" then
    sum = sum + 3 * BRC.get.mut("augmentation")
    sum = sum + BRC.get.mut("sharp scales")
  end

  return sum
end

local function get_staff_bonus_dmg(it, dmg_type)
  -- dcss v0.33.1
  if dmg_type == BRC.DMG_TYPE.unbranded then return 0 end
  if dmg_type == BRC.DMG_TYPE.plain then
    local basename = it.name("base")
    if basename ~= "staff of earth" and basename ~= "staff of conjuration" then return 0 end
  end

  local spell_skill = BRC.get.skill(BRC.get.staff_school(it))
  local evo_skill = you.skill("Evocations")

  local chance = (2 * evo_skill + spell_skill) / 30
  if chance > 1 then chance = 1 end
  -- 0.75 is an acceptable approximation; most commonly 63/80
  -- Varies by staff type in sometimes complex ways
  local avg_dmg = 3 / 4 * (evo_skill / 2 + spell_skill)
  return avg_dmg * chance
end

-- Formatting for stat inscriptions & alerts
function BRC.get.armour_stats(it)
  if not BRC.is.armour(it) then return "", "" end

  local equip_type = it.equip_type
  if equip_type == "body armour" then equip_type = "armour" end
  local cur = items.equipped_at(equip_type)
  local is_worn = it.equipped or (it.ininventory and cur and cur.slot == it.slot)
  local cur_ac = 0
  local cur_sh = 0
  local cur_ev = 0

  -- Show as delta if wearing a different item (and only one equip slot)
  if cur and not is_worn and BRC.get.num_equip_slots(it) == 1 then
    if BRC.is.shield(cur) then
      cur_sh = BRC.get.shield_sh(cur)
      cur_ev = -get_shield_penalty(cur)
    else
      cur_ac = BRC.get.armour_ac(cur)
      cur_ev = BRC.get.armour_ev(cur)
    end
  end

  if BRC.is.shield(it) then
    local sh_str = format_stat("SH", BRC.get.shield_sh(it) - cur_sh, is_worn)
    local ev_str = format_stat("EV", -get_shield_penalty(it) - cur_ev, is_worn)
    return sh_str, ev_str
  else
    local ac_str = format_stat("AC", BRC.get.armour_ac(it) - cur_ac, is_worn)
    if not BRC.is.body_armour(it) then return ac_str end
    local ev_str = format_stat("EV", BRC.get.armour_ev(it) - cur_ev, is_worn)
    return ac_str, ev_str
  end
end

function BRC.get.weapon_stats(it, dmg_type)
  if not it.is_weapon then return end
  if not dmg_type then
    if f_inscribe_stats and f_inscribe_stats.Config and f_inscribe_stats.Config.dmg_type then
      dmg_type = BRC.DMG_TYPE[f_inscribe_stats.Config.dmg_type]
    else
      dmg_type = BRC.DMG_TYPE.plain
    end
  end

  local dmg = format_dmg(BRC.get.weap_damage(it, dmg_type))
  local delay = get_weap_delay(it)
  local delay_str = string.format("%.1f", delay)
  if delay < 1 then
    delay_str = string.format("%.2f", delay)
    delay_str = delay_str:sub(2, #delay_str)
  end

  local dps = format_dmg(dmg / delay)
  local acc = it.accuracy + (it.plus or 0)
  if acc >= 0 then acc = "+" .. acc end

  --TODO: This would be nice if it worked in all UIs
  --return string.format("DPS:<w>%s</w> (%s/%s), Acc<w>%s</w>", dps, dmg, delay_str, acc)
  return string.format("DPS: %s (%s/%s), Acc%s", dps, dmg, delay_str, acc)
end

--- Get the ego of an item, with custom logic:
-- Treat unusable egos as no ego. Always lowercase ego in return value.
-- Include armours with innate effects (except steam dragon scales)
-- Artefacts return their normal ego if they have one, else their name
-- @param no_stat_only_egos (optional bool) Exclude egos that only affect speed/damage
function BRC.get.ego(it, no_stat_only_egos)
  local ego = it.ego(true)
  if ego then
    ego = ego:lower()
    if BRC.is.unusable_ego(ego) or (no_stat_only_egos and (ego == "speed" or ego == "heavy")) then
      return it.artefact and it.name() or nil
    end
    return ego
  end

  if BRC.is.body_armour(it) then
    local name = it.name("qual")
    local good_scales = name:contains("dragon scales") and not name:contains("steam")
    if name:contains("troll leather") or good_scales then return name end
  end

  return it.artefact and it.name() or nil
end

function BRC.get.hands(it)
  if you.race() ~= "Formicid" then return it.hands end
  local st = it.subtype()
  if st == "giant club" or st == "giant spiked club" then return 2 end
  return 1
end

function BRC.is.risky_item(it)
  if it.artefact then
    for k, v in pairs(it.artprops) do
      if util.contains(BRC.BAD_ART_PROPS, k) or v < 0 then return true end
    end
  end

  local ego_name = BRC.get.ego(it)
  return ego_name and util.contains(BRC.RISKY_EGOS, ego_name)
end

function BRC.is.unusable_ego(ego)
  if BRC.MAGIC_SCHOOLS[ego] then
    return BRC.Data.Config.unskilled_egos_usable or you.skill(BRC.MAGIC_SCHOOLS[ego]) > 0
  end

  local race = you.race()
  return ego == "holy" and util.contains(BRC.UNDEAD_RACES, race)
    or ego == "rPois" and util.contains(BRC.POIS_RES_RACES, race)
    or ego == "pain" and you.skill("Necromancy") == 0
end

-- Armour stats
function BRC.get.armour_ac(it)
  -- dcss v0.33.1
  local it_plus = it.plus or 0

  if it.artefact and it.is_identified then
    local art_ac = it.artprops["AC"]
    if art_ac then it_plus = it_plus + art_ac end
  end

  local ac = it.ac * (1 + you.skill("Armour") / 22) + it_plus
  if not BRC.is.body_armour(it) then return ac end

  if BRC.get.mut("deformed body") + BRC.get.mut("pseudopods") > 0 then ac = ac * 0.6 end

  return ac
end

function BRC.get.armour_ev(it)
  -- dcss v0.33.1
  -- This function computes the armour-based component to standard EV (not paralysed, etc)
  -- Factors in stat changes from this armour and removing current one
  local str = you.strength()
  local dex = you.dexterity()
  local no_art_str = str
  local no_art_dex = dex
  local art_ev = 0

  -- Adjust str/dex/EV for artefact stat changes
  local worn = items.equipped_at("armour")
  if worn and worn.artefact then
    if worn.artprops["Str"] then str = str - worn.artprops["Str"] end
    if worn.artprops["Dex"] then dex = dex - worn.artprops["Dex"] end
    if worn.artprops["EV"] then art_ev = art_ev - worn.artprops["EV"] end
  end

  if it.artefact then
    if it.artprops["Str"] then str = str + it.artprops["Str"] end
    if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
    if it.artprops["EV"] then art_ev = art_ev + it.artprops["EV"] end
  end

  if str <= 0 then str = 1 end

  local dodge_bonus = get_adjusted_dodge_bonus(it.encumbrance, str, dex)
  local naked_dodge_bonus = get_adjusted_dodge_bonus(0, no_art_str, no_art_dex)
  return (dodge_bonus - naked_dodge_bonus) + art_ev - get_adjusted_armour_pen(it.encumbrance, str)
end

function BRC.get.shield_sh(it)
  -- dcss v0.33.1
  local dex = you.dexterity()
  if it.artefact and it.is_identified then
    local art_dex = it.artprops["Dex"]
    if art_dex then dex = dex + art_dex end
  end

  local cur = items.equipped_at("offhand")
  if BRC.is.shield(cur) and cur.artefact and cur.slot ~= it.slot then
    local art_dex = cur.artprops["Dex"]
    if art_dex then dex = dex - art_dex end
  end

  local it_plus = it.plus or 0

  local base_sh = it.ac * 2
  local shield = base_sh * (50 + you.skill("Shields") * 5 / 2)
  shield = shield + 200 * it_plus
  shield = shield + 38 * (you.skill("Shields") + 3 + dex * (base_sh + 13) / 26)
  return shield / 200
end

-- Weapon stats
function BRC.get.weap_dps(it, dmg_type)
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  return BRC.get.weap_damage(it, dmg_type) / get_weap_delay(it)
end

function BRC.get.weap_damage(it, dmg_type)
  -- Returns an adjusted weapon damage = damage * speed
  -- Includes stat/slay changes between weapon and the one currently wielded
  -- Aux attacks not included
  if not dmg_type then dmg_type = BRC.DMG_TYPE.scoring end
  local it_plus = it.plus or 0
  -- Adjust str/dex/slay from artefacts
  local str = you.strength()
  local dex = you.dexterity()

  -- Adjust str/dex/EV for artefact stat changes
  if not it.equipped then
    local wielded = items.equipped_at("weapon")
    if wielded and wielded.artefact then
      if wielded.artprops["Str"] then str = str - wielded.artprops["Str"] end
      if wielded.artprops["Dex"] then dex = dex - wielded.artprops["Dex"] end
      if wielded.artprops["Slay"] then it_plus = it_plus - wielded.artprops["Slay"] end
    end

    if it.artefact and it.is_identified then
      if it.artprops["Str"] then str = str + it.artprops["Str"] end
      if it.artprops["Dex"] then dex = dex + it.artprops["Dex"] end
      if it.artprops["Slay"] then it_plus = it_plus + it.artprops["Slay"] end
    end
  end

  local stat = str
  if it.is_ranged or it.weap_skill:contains("Blades") then stat = dex end

  local stat_mod = 0.75 + 0.025 * stat
  local skill_mod = (1 + BRC.get.skill(it.weap_skill) / 50) * (1 + you.skill("Fighting") / 60)

  it_plus = it_plus + get_slay_bonuses()

  local pre_brand_dmg_no_plus = it.damage * stat_mod * skill_mod
  local pre_brand_dmg = pre_brand_dmg_no_plus + it_plus

  if BRC.is.magic_staff(it) then return pre_brand_dmg + get_staff_bonus_dmg(it, dmg_type) end

  if dmg_type == BRC.DMG_TYPE.plain then
    local ego = BRC.get.ego(it)
    if ego and util.contains(BRC.NON_ELEMENTAL_DMG_EGOS, ego) then
      local bonus = BRC.Data.Config.BrandBonus[ego] or BRC.Data.Config.BrandBonus.subtle[ego]
      return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset
    end
  elseif dmg_type >= BRC.DMG_TYPE.branded then
    local ego = BRC.get.ego(it)
    if ego then
      local bonus = BRC.Data.Config.BrandBonus[ego]
      if not bonus and dmg_type == BRC.DMG_TYPE.scoring then
        bonus = BRC.Data.Config.BrandBonus.subtle[ego]
      end
      if bonus then return bonus.factor * pre_brand_dmg_no_plus + it_plus + bonus.offset end
    end
  end

  return pre_brand_dmg
end

}
############################### End lua/core/util.lua ###############################
##########################################################################################

################################### Begin lua/core/data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC.Data - Persistent data management module
Manages persistent data across games and saves
Author: buehler
Dependencies: core/constants.lua, core/util.lua
--]]

---- Initialize BRC namespace and Data module
BRC = BRC or {}
BRC.Data = {}
BRC.Data.BRC_FEATURE_NAME = "data-manager" -- Included as a feature for Config override

-- Config values for data dumps
BRC.Data.Config = {
  max_lines_per_table = 200, -- Avoid huge tables (alert_monsters.Config.Alerts) in debug dumps
  skip_pointers = true, -- Don't dump functions and userdata (they only show a hex address)

  unskilled_egos_usable = false,
  BrandBonus = {
    chaos = { factor = 1.15, offset = 2.0 }, -- Approximate weighted average
    distort = { factor = 1.0, offset = 6.0 },
    drain = { factor = 1.25, offset = 2.0 },
    elec = { factor = 1.0, offset = 4.5 },   -- 3.5 on avg; fudged up for AC pen
    flame = { factor = 1.25, offset = 0 },
    freeze = { factor = 1.25, offset = 0 },
    heavy = { factor = 1.8, offset = 0 },    -- Speed is accounted for elsewhere
    pain = { factor = 1.0, offset = you.skill("Necromancy") / 2 },
    spect = { factor = 1.7, offset = 0 },    -- Fudged down for increased incoming damage
    venom = { factor = 1.0, offset = 5.0 },  -- 5 dmg per poisoning

    subtle = { -- Values estimated for weapon comparisons
      antimagic = { factor = 1.1, offset = 0 },
      holy = { factor = 1.15, offset = 0 },
      penet = { factor = 1.3, offset = 0 },
      protect = { factor = 1.15, offset = 0 },
      reap = { factor = 1.3, offset = 0 },
      vamp = { factor = 1.2, offset = 0 },
    },
  },
} -- BRC.Data.Config (do not remove this comment)

---- Local constants ----
local RESTORE_TABLE = "_brc_persist_restore_table"

---- Local variables ----
-- Init in declaration, so persist() can be used before init()
local _failures = {}
local _persist_names = {}
local _default_values = {}
local pushed_restore_table_creation = false

---- Local functions ----
local function is_usable_backup()
  if
    type(c_persist.BRC) ~= "table"
    or type(c_persist.BRC.Backup) ~= "table"
    or c_persist.BRC.Backup.backup_name ~= you.name()
    or c_persist.BRC.Backup.backup_race ~= you.race()
    or c_persist.BRC.Backup.backup_class ~= you.class()
  then
    return false
  end

  local turn_diff = you.turns() - c_persist.BRC.Backup.backup_turn
  if turn_diff == 0 then return true end
  for _ = 1, 5 do
    if BRC.mpr.yesno("Use backup from " .. turn_diff .. " turns ago?") then return true end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return false end
  end
  return true
end

local function try_restore(failed_vars)
  if not is_usable_backup() then
    BRC.mpr.red("[BRC] Unable to restore from backup. Persistent data reset to defaults.")
    BRC.log.info("For detailed startup info, set BRC.Config.show_debug_messages=True.")
    return false
  end

  for _, name in ipairs(failed_vars) do
    _default_values[name] = nil -- Avoid re-init warnings
    _G[name] = BRC.Data.persist(name, c_persist.BRC.Backup[name])
  end
  BRC.mpr.green("[BRC] Restored data from backup.")
  return true
end

---- Public API ----

--- Creates a persistent global variable or table, that retains its value through restarts.
-- Use this pattern to make the global definition obvious: `var = BRC.Data.persist("var", value)`
-- After restarting, the variable/table will not exist until this is called.
-- @param default_value - Variable set to this if it doesn't exist yet
-- @return The current value (whether default or persisted)
function BRC.Data.persist(name, default_value)
  local t = type(default_value)
  if not util.contains({ "table", "string", "number", "boolean", "nil" }, t) then
    BRC.log.error(string.format("Cannot persist %s. Default value is of type %s", name, t))
    return default_value
  end

  -- Keep default value for re-init
  if _default_values[name] then
    BRC.log.warning("Multiple calls to BRC.Data.persist(" .. name .. ", ...)")
  end
  _default_values[name] = default_value

  -- Try to restore from persistent restore table
  if you.turns() == 0 then
    _G[name] = default_value
  elseif _G[RESTORE_TABLE] and _G[RESTORE_TABLE][name] ~= nil then
    _G[name] = _G[RESTORE_TABLE][name]
    _G[RESTORE_TABLE][name] = nil
  elseif default_value ~= nil and not util.contains(_failures, name) then -- avoid inf loop
    _G[name] = default_value
    _failures[#_failures + 1] = name
    BRC.log.debug(BRC.text.red(name .. " failed to restore from chk_lua_save."))
  end

  -- Create persistent restore table on next startup
  if not pushed_restore_table_creation then
    table.insert(chk_lua_save, function()
      return RESTORE_TABLE .. " = {}\n"
    end)
    pushed_restore_table_creation = true
  end

  -- Set up persist on next startup
  if not util.contains(_persist_names, name) then
    _persist_names[#_persist_names + 1] = name
    table.insert(chk_lua_save, function()
      if _G[name] == nil then return "" end
      return RESTORE_TABLE .. "." .. name .. " = " .. BRC.util.tostring(_G[name]) .. "\n"
    end)
  end

  return _G[name]
end

function BRC.Data.serialize()
  local tokens = { BRC.text.lightmagenta("\n---PERSISTENT VARIABLES---\n") }
  local sorted_keys = BRC.util.get_sorted_keys(_persist_names)
  for _, key in ipairs(sorted_keys) do
    tokens[#tokens + 1] = string.format("%s = %s\n", key, BRC.util.tostring(_G[key], true))
  end
  return table.concat(tokens)
end

function BRC.Data.reset()
  if _persist_names then
    for _, name in ipairs(_persist_names) do
      _G[name] = _default_values[name]
    end
  end

  BRC.log.warning("Reset all persistent data to default values.")
end

-- @return true if no persist errors, false if failed restore, nil for user-accepted errors
function BRC.Data.handle_persist_errors()
  if #_failures == 0 then return true end
  local msg = "%s persistent variables did not restore: (%s)"
  BRC.log.error(msg:format(#_failures, table.concat(_failures, ", ")), true)

  for _ = 1, 5 do
    if BRC.mpr.yesno("Try restoring from backup?") then break end
    if BRC.mpr.yesno("Are you sure? Data will reset to defaults.") then return nil end
  end

  -- Whether restore works or not, we should reset _failures
  local failed_vars = _failures
  _failures = {}
  if try_restore(failed_vars) then return nil end
  return false
end

-- Backup and Restore from c_persist.BRC.Backup
function BRC.Data.backup()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end
  c_persist.BRC.Backup = {}
  c_persist.BRC.Backup.backup_name = you.name()
  c_persist.BRC.Backup.backup_race = you.race()
  c_persist.BRC.Backup.backup_class = you.class()
  c_persist.BRC.Backup.backup_turn = you.turns()
  for _, name in ipairs(_persist_names) do
    c_persist.BRC.Backup[name] = _G[name]
  end
end

}
############################### End lua/core/data.lua ###############################
##########################################################################################

################################### Begin lua/core/brc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
BRC (Buehler RC) Core Module
This module serves as the central coordinator for all feature modules
It automatically loads any global module/table that defines `BRC_FEATURE_NAME`
It then manages the feature's lifecycle and hook dispatching
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua
--]]

---- Initialize BRC namespace and non-persistent public variables
BRC = BRC or {}
BRC.VERSION = "1.2.0"
BRC.active = false
BRC.single_turn_mutes = {}

---- Persistent variables ----
brc_config_full = BRC.Data.persist("brc_config_full", nil)
brc_config_name = BRC.Data.persist("brc_config_name", nil)

---- Local constants ----
local HOOK_FUNCTIONS = {
  autopickup = "autopickup",
  c_answer_prompt = "c_answer_prompt",
  c_assign_invletter = "c_assign_invletter",
  c_message = "c_message",
  init = "init",
  ready = "ready",
} -- HOOK_FUNCTIONS (do not remove this comment)

---- Local variables ----
local _features
local _hooks
local turn_count
local cur_location

---- Local functions ----
local function feature_is_disabled(f)
  return f.Config and f.Config.disabled
    or BRC.Config[f.BRC_FEATURE_NAME] and BRC.Config[f.BRC_FEATURE_NAME].disabled
end

local function handle_feature_error(feature_name, hook_name, result)
  BRC.log.error(string.format("Failure in %s.%s", feature_name, hook_name), result, true)
  if BRC.mpr.yesno(string.format("Deactivate %s?", feature_name), BRC.COL.yellow) then
    BRC.unregister(feature_name)
  else
    BRC.mpr.okay()
  end
end

local function handle_core_error(hook_name, result, ...)
  local params = { hook_name }
  for i = 1, select("#", ...) do
    local param = select(i, ...)
    if param and type(param.name) == "function" then
      params[#params + 1] = "[" .. param.name() .. "]"
    else
      params[#params + 1] = BRC.util.tostring(param, true)
    end
  end

  local msg = "BRC failure in safe_call_all_hooks(" .. table.concat(params, ", ") .. ")"
  BRC.log.error(msg, result, true)
  if BRC.mpr.yesno("Deactivate BRC." .. hook_name .. "?", BRC.COL.yellow) then
    _hooks[hook_name] = nil
    BRC.mpr.brown("Unregistered hook: " .. tostring(hook_name))
  else
    BRC.mpr.okay("Returning nil to " .. hook_name .. ".")
  end
end

-- Config management
local function get_validated_config_name(input_name)
  if type(input_name) ~= "string" then
    BRC.log.warning("Non-string config name: " .. tostring(input_name))
  else
    local config_name = input_name:lower()
    if config_name == "ask" then
      if you.turns() > 0 and brc_config_name then
        return get_validated_config_name(brc_config_name)
      end
    elseif config_name == "previous" then
      if c_persist.BRC and c_persist.BRC.current_config then
        return get_validated_config_name(c_persist.BRC.current_config)
      else
        BRC.log.warning("No previous config found.")
      end
    else
      for k, _ in pairs(BRC.Profiles) do
        if config_name == k:lower() then return k end
      end
      BRC.log.warning("Could not load config: " .. tostring(input_name))
    end
  end

  return BRC.mpr.select("Select a config", util.keys(BRC.Profiles))
end

local function safe_call_string(str, module_name)
  local chunk, err = loadstring(str)
  if not chunk then
    BRC.log.error("Error loading " .. module_name .. ".Config.init string: ", err)
  else
    local success, result = pcall(chunk)
    if not success then
      BRC.log.error("Error executing " .. module_name .. ".Config.init string: ", result)
    end
  end
end

local function override_feature_config_table(source, dest)
  if type(source) ~= "table" then return end

  for key, value in pairs(source) do
    if BRC.is.map(value) then
      if not dest[key] then dest[key] = {} end
      override_feature_config_table(value, dest[key])
    elseif key ~= "init" then
      dest[key] = value
    end
  end
end

local function process_feature_config(feature_name)
  local f = _features[feature_name]
  if not f.Config then
    f.Config = {}
  elseif type(f.Config.init) == "function" then
    f.Config.init()
  elseif type(f.Config.init) == "string" then
    safe_call_string(f.Config.init, feature_name)
  end

  override_feature_config_table(BRC.Config[feature_name], f.Config)
end

-- Hook management
local function call_all_hooks(hook_name, ...)
  local last_return_value = nil
  local returning_feature = nil

  for i = #_hooks[hook_name], 1, -1 do
    local hook_info = _hooks[hook_name][i]
    if not feature_is_disabled(_features[hook_info.feature_name]) then
      if hook_name == HOOK_FUNCTIONS.init then
        BRC.log.debug(string.format("Initialize %s...", BRC.text.lightcyan(hook_info.feature_name)))
      end
      local success, result = pcall(hook_info.func, ...)
      if not success then
        handle_feature_error(hook_info.feature_name, hook_name, result)
      else
        if last_return_value and result and last_return_value ~= result then
          BRC.log.warning(
            string.format(
              "Return value mismatch in %s:\n  (first) %s -> %s\n  (final) %s -> %s",
              hook_name,
              returning_feature,
              BRC.util.tostring(last_return_value, true),
              hook_info.feature_name,
              BRC.util.tostring(result, true)
            )
          )
        end

        last_return_value = result
        returning_feature = hook_info.feature_name
      end
    end
  end

  return last_return_value
end

--- Errors in this function won't show up in crawl, so it's kept simple and safe.
local function safe_call_all_hooks(hook_name, ...)
  if not (_hooks and _hooks[hook_name] and #_hooks[hook_name] > 0) then return end

  local success, result = pcall(call_all_hooks, hook_name, ...)
  if success then return result end

  success, result = pcall(handle_core_error, hook_name, result, ...)
  if success then return end

  -- This is a serious error. Failed in the hook, and when we tried to report it.
  BRC.log.error("Failed to handle BRC core error!", result, true)
  if BRC.mpr.yesno("Dump char and deactivate BRC?", BRC.COL.yellow) then
    BRC.active = false
    BRC.mpr.brown("BRC deactivated.", "Error in hook: " .. tostring(hook_name))
    pcall(BRC.dump.char, true)
  else
    BRC.mpr.okay()
  end
end

local function register_all_features()
  -- Find all feature modules
  local feature_names = {}
  for name, value in pairs(_G) do
    if BRC.is_feature_module(value) then feature_names[#feature_names + 1] = name end
  end

  -- Sort alphabetically (for reproducable behavior)
  table.sort(feature_names)

  -- Register features
  local loaded_count = 0
  for _, name in ipairs(feature_names) do
    local success = BRC.register(_G[name])
    if success then
      loaded_count = loaded_count + 1
    elseif success == false then
      BRC.log.error("Failed to register feature: " .. name .. ". Aborting bulk registration.")
      return loaded_count
    end
  end

  return loaded_count
end

---- Public API ----
function BRC.get_registered_features()
  return _features
end

function BRC.is_feature_module(f)
  return f
    and type(f) == "table"
    and f.BRC_FEATURE_NAME
    and type(f.BRC_FEATURE_NAME) == "string"
    and #f.BRC_FEATURE_NAME > 0
end

-- BRC.register(): Return true if success, false if error, nil if feature is disabled
function BRC.register(f)
  if not BRC.is_feature_module(f) then
    BRC.log.error("Tried to register a non-feature module! Module contents:")
    BRC.dump.var(f)
    return false
  elseif _features[f.BRC_FEATURE_NAME] then
    BRC.log.warning(BRC.text.lightcyan(f.BRC_FEATURE_NAME) .. " already registered! Repeating...")
    BRC.unregister(f.BRC_FEATURE_NAME)
  end

  if feature_is_disabled(f) then
    BRC.log.debug(BRC.text.lightcyan(f.BRC_FEATURE_NAME) .. " is disabled. Skipped registration.")
    return nil
  else
    if not BRC.Config[f.BRC_FEATURE_NAME] then BRC.Config[f.BRC_FEATURE_NAME] = {} end
    if not f.Config then f.Config = {} end
    f.Config.disabled = false
  end

  BRC.log.debug(string.format("Registering %s...", BRC.text.lightcyan(f.BRC_FEATURE_NAME)))
  _features[f.BRC_FEATURE_NAME] = f

  -- Register hooks
  for _, hook_name in pairs(HOOK_FUNCTIONS) do
    if f[hook_name] then
      if not _hooks[hook_name] then _hooks[hook_name] = {} end
      table.insert(_hooks[hook_name], {
        feature_name = f.BRC_FEATURE_NAME,
        hook_name = hook_name,
        func = f[hook_name],
      })
    end
  end

  process_feature_config(f.BRC_FEATURE_NAME)

  return true
end

function BRC.unregister(name)
  if not _features[name] then
    BRC.log.error(BRC.text.yellow(name) .. " is not registered. Cannot unregister.")
    return false
  end

  _features[name] = nil
  local hooks_removed = {}
  for hook_name, hooks in pairs(_hooks) do
    for i = #hooks, 1, -1 do
      if hooks[i].feature_name == name then
        table.remove(hooks, i)
        hooks_removed[#hooks_removed + 1] = hook_name
      end
    end
  end

  BRC.log.info(string.format("Unregistered %s.", BRC.text.lightcyan(name)))
  BRC.log.debug(string.format("Unregistered hooks: (%s)", table.concat(hooks_removed, ", ")))
  return true
end

function BRC.init()
  _features = {}
  _hooks = {}
  turn_count = -1
  cur_location = you.where()
  if type(c_persist.BRC) ~= "table" then c_persist.BRC = {} end

  BRC.log.debug("Load config...")
  local config_name
  if BRC.config_memory and BRC.config_memory:lower() == "full" then
    config_name = BRC.load_config(brc_config_full or brc_config_name or BRC.config_to_use)
    brc_config_full = BRC.Config
  elseif BRC.config_memory and BRC.config_memory:lower() == "name" then
    config_name = BRC.load_config(brc_config_name or BRC.config_to_use)
  else
    config_name = BRC.load_config(BRC.config_to_use)
  end
  brc_config_name = config_name

  BRC.log.debug("Register features...")
  BRC.register(BRC.Data) -- Data must be the first feature registered (so it's last to initialize)
  register_all_features()

  BRC.log.debug("Initialize features...")
  safe_call_all_hooks(HOOK_FUNCTIONS.init)
  local suffix = BRC.text.blue(string.format(" (%s features)", #util.keys(_features)))

  BRC.log.debug("Add non-feature hooks...")
  add_autopickup_func(BRC.autopickup)
  BRC.set.macro(BRC.get.command_key("CMD_CHARACTER_DUMP") or "#", "macro_brc_dump_character")
  BRC.set.macro("\\{5}", "macro_brc_cntl_e")

  BRC.log.debug("Verify persistent data reload...")
  local success = BRC.Data.handle_persist_errors()
  if success then
    BRC.Data.backup() -- Only backup after a clean startup
    local msg = string.format("Successfully initialized BRC v%s!%s", BRC.VERSION, suffix)
    BRC.mpr.lightgreen("\n" .. BRC.text.wrap(msg, BRC.EMOJI.SUCCESS) .. "\n")
  else
    -- success == nil if errors were resolved, false if tried restore but failed
    if success == false and BRC.mpr.yesno("Deactivate BRC?" .. suffix, BRC.COL.yellow) then
      BRC.active = false
      BRC.mpr.lightred("\nBRC is off.\n")
      return false
    end
    BRC.mpr.magenta(string.format("\nInitialized BRC v%s with warnings!%s\n", BRC.VERSION, suffix))
  end

  -- We're a go!
  BRC.active = true
  BRC.ready()
  return true
end

function BRC.load_config(input_config)
  local config_name
  if type(input_config) == "table" then
    BRC.Config = input_config
    config_name = brc_config_name or "Unknown"
  else
    config_name = get_validated_config_name(input_config)
    BRC.Config = util.copy_table(BRC.Profiles.Default)
    for k, v in pairs(BRC.Profiles[config_name]) do
      BRC.Config[k] = v
    end
  end

  -- Do config init() and feature overrides
  if type(BRC.Config.init) == "function" then
    BRC.Config.init()
  elseif type(BRC.Config.init) == "string" then
    safe_call_string(BRC.Config.init, "BRC")
  end
  for name, _ in pairs(_features) do
    process_feature_config(name)
  end

  BRC.log.info("Using config: " .. BRC.text.lightcyan(config_name))
  return config_name
end

function BRC.reset()
  BRC.active = false
  BRC.single_turn_mutes = {}
  BRC.Data.reset()
  BRC.init()
end

---- Crawl hooks ----
function BRC.autopickup(it, _)
  return safe_call_all_hooks(HOOK_FUNCTIONS.autopickup, it)
end

function BRC.ready()
  if not BRC.active then return end
  crawl.redraw_screen()

  -- Unmute single-turn mutes
  util.foreach(BRC.single_turn_mutes, function(m) BRC.set.message_mute(m, false) end)

  if you.turns() > turn_count then
    turn_count = you.turns()

    if you.where() ~= cur_location and not you.have_orb() then
      cur_location = you.where()
      BRC.Data.backup()
    end

    safe_call_all_hooks(HOOK_FUNCTIONS.ready)
  end

  -- Always do this, even if same turn
  BRC.mpr.consume_queue()
end

function BRC.c_message(text, channel)
  if not BRC.active then return end
  safe_call_all_hooks(HOOK_FUNCTIONS.c_message, text, channel)
end

function BRC.c_answer_prompt(prompt)
  if not BRC.active then return end
  if not prompt then return end -- This fires from crawl, e.g. Shop purchase confirmation
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_answer_prompt, prompt)
end

function BRC.c_assign_invletter(it)
  if not BRC.active then return end
  return safe_call_all_hooks(HOOK_FUNCTIONS.c_assign_invletter, it)
end

}
############################### End lua/core/brc.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

### Lua feature files ###

################################### Begin lua/features/alert-monsters.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: alert-monsters
Description: Dynamic force_more and flash_screen messages for monsters
    Based on player HP, xl, willpower, resistances, etc.
    WARNINGS:
      - Never put a '}' on a line by itself. This breaks crawl's RC parser.
      - POSIX regex are required for this feature to use '|' in patterns.
Author: original by gammafunk, extended by buehler
Dependencies: core/util.lua
--]]

f_alert_monsters = {}
f_alert_monsters.BRC_FEATURE_NAME = "alert-monsters"
f_alert_monsters.Config = {
  sensitivity = 1.0, -- 0 to disable all; at 2.0, alerts will fire at 1/2 HP
  fm_on_uniques = true, -- Stop on all Uniques & Pan lords
  pack_timeout = 10, -- turns to wait before repeating a pack alert. 0 to disable
  disable_alert_monsters_in_zigs = true, -- Disable dynamic force_mores in Ziggurats
  debug_alert_monsters = false, -- Get a message when alerts toggle off/on
} -- f_alert_monsters.Config (do not remove this comment)

---- Local config alias ----
local Config = f_alert_monsters.Config

--[[
Config.Alerts contains all alerts. Each table in it creates one alert, using the following fields:
  - `name` is for debugging.
  - `pattern` is a string or list of monster names, will alert when one comes into view.
  - `is_pack` (optional) indicates the alert is for a pack of monsters.
    Packs only fire once every few turns - as defined in Config.pack_timeout (default 15).
  - `flash_screen` (optional) alert will flash the screen instead of using force_more.
  - `cutoff` sets the point when the alert is active (usually how much HP you have)
  - `cond` defines HOW the character stats are compared against `cutoff` (HP/will/etc).
    Ex:
      `always` alerts are always on.
      `hp` alerts are active when you have < `cutoff` HP.
      `will` alerts are active when you have <= `cutoff` pips of willpower.
      `int` alerts are active when you have < `cutoff` Int.
      `xl` alerts are active when your XL is < `cutoff`.
      `elec` alerts are active when you have no rElec and < `cutoff` HP.
      `fire`, `cold`, etc active < `cutoff` HP with no resistance. Pips lower cutoff to 50/33/20%
--]]
f_alert_monsters.Config.Alerts = {
  { name = "always_fm",
    pattern = {
      -- High damage/speed
      "flayed ghost", "juggernaut", "orbs? of (entropy|fire|winter)",
      --Summoning
      "boundless tesseract", "demonspawn corrupter", "draconian stormcaller", "dryad",
      "guardian serpent", "halazid warlock", "shadow demon", "spriggan druid", "worldbinder",
      --Dangerous abilities
      "iron giant", "merfolk aquamancer", "shambling mangrove", "starflower",
      "torpor snail", "water nymph", "wretched star", "wyrmhole",
      --Dangerous clouds
      "apocalypse crab","catoblepas",
    } },

  { name = "always_flash", flash_screen = true,
    pattern = {
      -- Noteworthy abilities
      "air elemental", "elemental wellspring", "ghost crab", "ironbound convoker",
      "vault guardian", "vault warden", "wendingo",
      -- Displacement
      "deep elf knight", "swamp worm",
      -- Summoning
      "deep elf elementalist",
    } },

  { name = "always_fm_pack", is_pack = true,
    pattern = { "boggart", "dream sheep", "floating eye", "shrike" } },

  -- Early game Dungeon problems for chars with low mhp. (adder defined below)
  { name = "30hp", cond = "hp", cutoff = 30,
    pattern = { "hound", "gnoll" } },

  -- Monsters dangerous until a certain point
  { name = "xl_7", cond = "xl", cutoff = 7,
    pattern = { "orc wizard" } },
  { name = "xl_12", cond = "xl", cutoff = 12,
    pattern = { "hydra", "bloated husk" } },

  -- Monsters that can hit for ~50% of hp from range with unbranded attacks
  { name = "40hp", cond = "hp", cutoff = 40,
    pattern = { "orc priest" } },
  { name = "50hp", cond = "hp", cutoff = 50,
    pattern = { "manticore", "orc high priest" } },
  { name = "60hp", cond = "hp", cutoff = 60,
    pattern = { "centaur(?! warrior)", "cyclops", "yaktaur(?! captain)" } },
  { name = "70hp_melai", cond = "hp", cutoff = 70, is_pack = true,
    pattern = "meliai" },
  { name = "80hp", cond = "hp", cutoff = 80,
    pattern = { "gargoyle" } },
  { name = "90hp", cond = "hp", cutoff = 90,
    pattern = { "deep elf archer", "tengu conjurer" } },
  { name = "110hp", cond = "hp", cutoff = 110,
    pattern = { "cacodemon", "centaur warrior", "deep elf high priest",
                "deep troll earth mage", "eye of devastation", "hellion", "stone giant",
                "sun moth", "yaktaur captain" } },
  { name = "120hp", cond = "hp", cutoff = 120,
    pattern = { "magenta draconian", "thorn hunter", "quicksilver (dragon|elemental)" } },
  { name = "160hp", cond = "hp", cutoff = 160,
    pattern = { "brimstone fiend", "deep elf sorcererhell sentinal",
                "draconian (knight|scorcher)", "war gargoyle" } },
  { name = "200hp", cond = "hp", cutoff = 200,
    pattern = { "(deep elf|draconian) annihilator", "iron (dragon|elemental)" } },

  -- Monsters that can crowd-control you without sufficient willpower
  -- Cutoff ~10% for most spells; lower for more significant spells like banish
  { name = "willpower2", cond = "will", cutoff = 2,
    pattern = { "basilisk", "naga ritualist", "vampire(?! (bat|mage|mosquito))",
                "sphinx marauder" } },
  { name = "willpower3", cond = "will", cutoff = 3,
    pattern = { "cacodemon", "death knight", "deep elf (demonologist|sorcerer|archer)",
                "draconian shifter", "fenstrider witch", "glowing orange brain",
                "guardian sphinx", "imperial myrmidon", "iron elemental", "occultist",
                "merfolk siren", "nagaraja", "ogre mage", "orc sorcerer", "satyr",
                "vampire knight", "vault sentinel" } },
  { name = "willpower3_great_orb_of_eyes", cond = "will", cutoff = 3, is_pack = true,
    pattern = "great orb of eyes" },
  { name = "willpower3_golden_eye", cond = "will", cutoff = 3, is_pack = true,
    pattern = "golden eye" },
  { name = "willpower4", cond = "will", cutoff = 4,
    pattern = { "merfolk avatar", "tainted leviathan", "nargun" } },

  -- Mutators (only flash if immune)
  { name = "malmutate", cond = "mut", cutoff = 1, flash_screen = BRC.you.mutation_immune(),
    pattern = { "cacodemon", "neqoxec", "shining eye" } },

  -- Brain feed with low int
  { name = "brainfeed", cond = "int", cutoff = 6,
    pattern = { "glowing orange brain", "neqoxec" } },

  -- Alert if no resist and HP below cutoff
  { name = "pois_30", cond = "pois", cutoff = 30,
    pattern = { "adder" } },
  { name = "pois_80", cond = "pois", cutoff = 80,
    pattern = { "golden dragon", "green draconian", "swamp dragon" } },
  { name = "pois_120", cond = "pois", cutoff = 120,
    pattern = { "fenstrider witch", "green death", "naga mage", "nagaraja" } },
  { name = "pois_140", cond = "pois", cutoff = 140,
    pattern = { "tengu reaver" } },

  { name = "elec_40", cond = "elec", cutoff = 40, is_pack = true,
    pattern = "electric eel" },
  { name = "elec_80", cond = "elec", cutoff = 80,
    pattern = { "raiju", "shock serpent", "spark wasp" } },
  { name = "elec_120", cond = "elec", cutoff = 120,
    pattern = { "black draconian", "blizzard demon", "deep elf zephyrmancer",
                "storm dragon", "tengu conjurer" } },
  { name = "elec_140", cond = "elec", cutoff = 140,
    pattern = { "electric golem", "servants? of whisper", "spriggan air mage",
                "tengu reaver", "titan" } },
  { name = "elec_140_pack", cond = "elec", cutoff = 140, is_pack = true,
    pattern = { "ball lightning" } },
  { name = "corr_60", cond = "corr", cutoff = 60,
    pattern = { "acid dragon" } },
  { name = "corr_140", cond = "corr", cutoff = 140,
    pattern = { "demonspawn corrupter", "entropy weaver", "moon troll", "tengu reaver" } },

  { name = "fire_60", cond = "fire", cutoff = 60,
    pattern = { "fire crab", "lava snake", "lindwurm", "steam dragon" } },
  { name = "fire_100", cond = "fire", cutoff = 100,
    pattern = { "deep elf pyromancer", "efreet", "smoke demon", "sun moth" } },
  { name = "fire_120", cond = "fire", cutoff = 120,
    pattern = { "demonspawn blood saint", "hell hound", "hell knight", "molten gargoyle",
                "ogre mage", "orc sorcerer", "red draconian" } },
  { name = "fire_140", cond = "fire", cutoff = 140,
    pattern = { "balrug" } },
  { name = "fire_160", cond = "fire", cutoff = 160,
    pattern = { "fire dragon", "fire giant", "golden dragon", "ophan", "salamander tyrant",
                "tengu reaver", "will-o-the-wisp" } },
  { name = "fire_240", cond = "fire", cutoff = 240,
    pattern = { "crystal (guardian|echidna)", "draconian scorcher", "hellephant" } },

  { name = "cold_80", cond = "cold", cutoff = 80,
    pattern = { "rime drake" } },
  { name = "cold_120", cond = "cold", cutoff = 120,
    pattern = { "blizzard demon", "bog body", "demonspawn blood saint",
               "ironbound frostheart", "white draconian" } },
  { name = "cold_160", cond = "cold", cutoff = 160,
    pattern = { "draconian knight", "frost giant", "golden dragon",
                "ice dragon", "tengu reaver" } },
  { name = "cold_180", cond = "cold", cutoff = 180,
    pattern = { "(?<!dread)(?<!ancient) lich", "lich king" } },
  { name = "cold_240", cond = "cold", cutoff = 240,
    pattern = { "crystal (guardian|echidna)" } },

  { name = "drain_100", cond = "drain", cutoff = 100,
    pattern = { "orc sorcerer" } },
  { name = "drain_120", cond = "drain", cutoff = 120,
    pattern = { "necromancer" } },
  { name = "drain_150", cond = "drain", cutoff = 150,
    pattern = { "demonspawn blood saint", "revenant" } },
  { name = "drain_190", cond = "drain", cutoff = 190,
    pattern = { "shadow dragon" } },
} -- fm_patterns (do not remove this comment)

f_alert_monsters.Config.init = [[
    local alert_list = f_alert_monsters.Config.Alerts
    -- Conditionally add miasma monsters
    if not BRC.you.miasma_immune() then
      util.append(alert_list, {
        name = "miasma", cond = "always", cutoff = 0,
        pattern = { "death drake", "tainted leviathan", "putrid mouth" }
      })
    end

    -- Conditionally add tormentors
    if not you.torment_immune() then
      util.append(alert_list, {
        name = "torment", cond = "always", cutoff = 0,
        pattern = { "curse (toe|skull)", "Fiend", "(dread|ancient) lich", "lurking horror",
                    "mummy priest", "royal mummy", "tormentor", "tzitzimi" }
      })
    end

    -- If configured, add fm for all uniques and pan lords
    if f_alert_monsters.Config.fm_on_uniques then
      local uniques_pattern = "monster_warning:(?-i:[A-Z]).*(?<!rb Guardian) comes? into view"
      BRC.set.force_more_message(uniques_pattern, true)
    end
]]
------------------- End config section -------------------

---- Local variables ----
local patterns_to_mute -- which packs to mute at next ready()

---- Local constants ----
local WARN_PREFIX = "monster_warning:(?<!spectral )("
local WARN_SUFFIX = ")(?! (zombie|skeleton|simulacrum)).*comes? into view"

---- Local functions ----
local function check_alert_three_pip(hp, dmg_threshold, resistance)
  -- Dmg taken is 1/1; 1/2; 1/3; 1/5 (for 0; 1; 2; 3 resistance)
  if resistance >= 3 then return hp < dmg_threshold / 5 end
  return hp < dmg_threshold / (resistance + 1)
end

local function update_pack_mutes()
  -- Put pending mutes into effect
  for _, v in ipairs(patterns_to_mute) do
    if v.flash_screen then
      BRC.set.flash_screen_message(v, false)
    else
      BRC.set.force_more_message(v, false)
    end
    if Config.debug_alert_monsters then BRC.mpr.blue("Muted pack: " .. v) end
  end
  patterns_to_mute = {}

  -- Remove expired mutes
  for _, v in ipairs(Config.Alerts) do
    if
      v.is_pack
      and v.last_fm_turn ~= -1
      and you.turns() >= v.last_fm_turn + Config.pack_timeout
    then
      v.last_fm_turn = -1
      v.active_alert = false -- Let the main logic decide if/when to reactivate it.
      if Config.debug_alert_monsters then BRC.mpr.blue("Unmuted pack: " .. v.pattern) end
    end
  end
end

---- Hook functions ----
function f_alert_monsters.init()
  patterns_to_mute = {}

  -- Break packs with tables into individual alerts
  local add_patterns = {}
  local remove_patterns = {}
  for _, v in ipairs(Config.Alerts) do
    if v.is_pack and type(v.pattern) == "table" and #v.pattern > 1 then
      remove_patterns[#remove_patterns + 1] = v
      for _, m in ipairs(v.pattern) do
        local to_add = util.copy_table(v)
        to_add.name = (to_add.name or "") .. "_" .. m:gsub(" ", "_")
        to_add.pattern = m
        add_patterns[#add_patterns + 1] = to_add
      end
    end
  end
  util.append(Config.Alerts, add_patterns)
  for _, v in ipairs(remove_patterns) do
    util.remove(Config.Alerts, v)
  end

  -- Convert patterns to regex
  for _, v in ipairs(Config.Alerts) do
    v.active_alert = false
    v.last_fm_turn = -1
    if type(v.pattern) == "table" then v.pattern = table.concat(v.pattern, "|") end
    v.pattern = WARN_PREFIX .. v.pattern .. WARN_SUFFIX
    v.regex = crawl.regex(v.pattern:gsub("monster_warning:", ""))
  end
end

function f_alert_monsters.c_message(text, channel)
  if channel ~= "monster_warning" or not text:find("comes? into view") then return end
  if Config.pack_timeout <= 0 then return end

  -- Identify when a mute should be turned on
  for _, v in ipairs(Config.Alerts) do
    if v.is_pack and v.regex:matches(text) then
      if v.last_fm_turn == -1 then
        patterns_to_mute[#patterns_to_mute + 1] = v.pattern
        if Config.debug_alert_monsters then BRC.mpr.blue("To mute: " .. v.pattern) end
      else
        if Config.debug_alert_monsters then BRC.mpr.blue("Extending mute: " .. v.pattern) end
      end
      v.last_fm_turn = you.turns()
    end
  end
end

function f_alert_monsters.ready()
  local activated = {}
  local deactivated = {}

  -- Load all stats before loop. Most of them are used multiple times.
  local hp, _ = you.hp()
  if you.spirit_shield() > 0 then
    local mp, _ = you.mp()
    hp = hp + mp
  end
  local xl = you.xl()
  local int = you.intelligence()
  local willpower = you.willpower()
  local res_mut = you.res_mutation()
  local res_pois = you.res_poison()
  local res_elec = you.res_shock()
  local res_corr = you.res_corr()
  local res_fire = you.res_fire()
  local res_cold = you.res_cold()
  local res_drain = you.res_draining()

  for _, v in ipairs(Config.Alerts) do
    local should_be_active = nil

    if Config.disable_alert_monsters_in_zigs and you.branch() == "Zig" then
      should_be_active = false
    elseif not v.cond then
      should_be_active = true
    elseif v.cond == "xl" then
      should_be_active = xl < v.cutoff * Config.sensitivity
    elseif v.cond == "hp" then
      should_be_active = hp < v.cutoff * Config.sensitivity
    elseif v.cond == "int" then
      should_be_active = int < v.cutoff * Config.sensitivity
    elseif v.cond == "will" then
      should_be_active = willpower < v.cutoff * Config.sensitivity
    elseif v.cond == "mut" then
      should_be_active = res_mut == 0
    elseif v.cond == "pois" then
      should_be_active = res_pois == 0 and hp < v.cutoff * Config.sensitivity
    elseif v.cond == "elec" then
      should_be_active = res_elec == 0 and hp < v.cutoff * Config.sensitivity
    elseif v.cond == "corr" then
      should_be_active = not res_corr and hp < v.cutoff * Config.sensitivity
    elseif v.cond == "fire" then
      should_be_active = check_alert_three_pip(hp, v.cutoff * Config.sensitivity, res_fire)
    elseif v.cond == "cold" then
      should_be_active = check_alert_three_pip(hp, v.cutoff * Config.sensitivity, res_cold)
    elseif v.cond == "drain" then
      should_be_active = check_alert_three_pip(hp, v.cutoff * Config.sensitivity, res_drain)
    end

    if should_be_active ~= v.active_alert then
      v.active_alert = should_be_active
      if v.flash_screen then
        BRC.set.flash_screen_message(v.pattern, should_be_active)
      else
        BRC.set.force_more_message(v.pattern, should_be_active)
      end

      if Config.debug_alert_monsters then
        if v.active_alert then
          activated[#activated + 1] = v.name or v.pattern
        else
          deactivated[#deactivated + 1] = v.name or v.pattern
        end
      end
    end
  end

  if Config.debug_alert_monsters then
    if #activated > 0 then
      BRC.mpr.blue("Activating f_m: " .. table.concat(activated, ", "))
    end
    if #deactivated > 0 then
      BRC.mpr.blue("Deactivating f_m: " .. table.concat(deactivated, ", "))
    end
  end

  if Config.pack_timeout > 0 then update_pack_mutes() end
end

}
############################### End lua/features/alert-monsters.lua ###############################
##########################################################################################

################################### Begin lua/features/announce-hp-mp.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: announce-hp-mp
Description: Announces changes in HP/MP with visual meters and damage warnings
Author: magus, buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua
--]]

f_announce_hp_mp = {}
f_announce_hp_mp.BRC_FEATURE_NAME = "announce-hp-mp"
f_announce_hp_mp.Config = {
  dmg_flash_threshold = 0.20, -- Flash screen when losing this % of max HP
  dmg_fm_threshold = 0.30, -- Force more for losing this % of max HP
  always_on_bottom = false, -- Rewrite HP/MP meters after each turn with messages

  Announce = {
    hp_loss_limit = 1, -- Announce when HP loss >= this
    hp_gain_limit = 4, -- Announce when HP gain >= this
    mp_loss_limit = 1, -- Announce when MP loss >= this
    mp_gain_limit = 2, -- Announce when MP gain >= this
    hp_first = true, -- Show HP first in the message
    same_line = true, -- Show HP/MP on the same line
    always_both = true, -- If showing one, show both
    very_low_hp = 0.10, -- At this % of max HP, show all HP changes and mute % HP alerts
  },

  HP_METER = BRC.Config.emojis and { FULL = "❤️", PART = "❤️‍🩹", EMPTY = "🤍" } or {
    BORDER = BRC.text.white("|"),
    FULL = BRC.text.lightgreen("+"),
    PART = BRC.text.lightgrey("+"),
    EMPTY = BRC.text.darkgrey("-"),
  },

  MP_METER = BRC.Config.emojis and { FULL = "🟦", PART = "🔹", EMPTY = "➖" } or {
    BORDER = BRC.text.white("|"),
    FULL = BRC.text.lightblue("+"),
    PART = BRC.text.lightgrey("+"),
    EMPTY = BRC.text.darkgrey("-"),
  },
} -- f_announce_hp_mp.Config (do not remove this comment)

---- Persistent variables ----
ad_prev = BRC.Data.persist("ad_prev", { hp = 0, mhp = 0, mp = 0, mmp = 0 })

---- Local config alias ----
local Config = f_announce_hp_mp.Config

---- Local constants ----
local PIPS_PER_METER = 5
local METER_LENGTH = PIPS_PER_METER + 2 * #BRC.text.clean(Config.HP_METER.BORDER or "")
local ALWAYS_BOTTOM_SETTINGS = {
  hp_loss_limit = 0, hp_gain_limit = 0, mp_loss_limit = 0, mp_gain_limit = 0,
  hp_first = true, same_line = true, always_both = true, very_low_hp = 0,
} -- ALWAYS_BOTTOM_SETTINGS (do not remove this comment)

---- Local functions ----
local function create_meter(perc, emojis)
  perc = math.max(0, math.min(1, perc)) -- Clamp between 0 and 1

  local num_halfpips = math.floor(perc * PIPS_PER_METER * 2)
  local num_full_emojis = math.floor(num_halfpips / 2)
  local num_part_emojis = num_halfpips % 2
  local num_empty_emojis = PIPS_PER_METER - num_full_emojis - num_part_emojis

  return table.concat({
    emojis.BORDER or "",
    string.rep(emojis.FULL, num_full_emojis),
    string.rep(emojis.PART, num_part_emojis),
    string.rep(emojis.EMPTY, num_empty_emojis),
    emojis.BORDER or "",
  })
end

local function format_delta(delta)
  if delta > 0 then
    return BRC.text.green("+" .. delta)
  elseif delta < 0 then
    return BRC.text.red(delta)
  else
    return BRC.text.darkgrey("+0")
  end
end

local function format_ratio(cur, max)
  local color
  if cur <= (max * 0.25) then
    color = BRC.COL.lightred
  elseif cur <= (max * 0.50) then
    color = BRC.COL.red
  elseif cur <= (max * 0.75) then
    color = BRC.COL.yellow
  elseif cur < max then
    color = BRC.COL.white
  else
    color = BRC.COL.green
  end

  return BRC.text[color](string.format(" -> %s/%s", cur, max))
end

local function get_hp_message(hp_delta, mhp_delta)
  local hp, mhp = you.hp()
  local msg_tokens = {}
  msg_tokens[#msg_tokens + 1] = create_meter(hp / mhp, Config.HP_METER)
  msg_tokens[#msg_tokens + 1] = BRC.text.white(string.format(" HP[%s]", format_delta(hp_delta)))
  msg_tokens[#msg_tokens + 1] = format_ratio(hp, mhp)

  if mhp_delta ~= 0 then
    local text = string.format(" (%s max HP)", format_delta(mhp_delta))
    msg_tokens[#msg_tokens + 1] = BRC.text.lightgrey(text)
  end

  if not Config.Announce.same_line and hp == mhp then
    msg_tokens[#msg_tokens + 1] = BRC.text.white(" (Full HP)")
  end

  return table.concat(msg_tokens)
end

local function get_mp_message(mp_delta, mmp_delta)
  local mp, mmp = you.mp()
  local msg_tokens = {}
  msg_tokens[#msg_tokens + 1] = create_meter(mp / mmp, Config.MP_METER)
  msg_tokens[#msg_tokens + 1] = BRC.text.lightcyan(string.format(" MP[%s]", format_delta(mp_delta)))
  msg_tokens[#msg_tokens + 1] = format_ratio(mp, mmp)

  if mmp_delta ~= 0 then
    local tok = string.format(" (%s max MP)", format_delta(mmp_delta))
    msg_tokens[#msg_tokens + 1] = BRC.text.cyan(tok)
  end

  if not Config.Announce.same_line and mp == mmp then
    msg_tokens[#msg_tokens + 1] = BRC.text.lightcyan(" (Full MP)")
  end

  return table.concat(msg_tokens)
end

local function last_msg_is_meter()
  local last_msg = crawl.messages(1)
  if not (last_msg and #last_msg > METER_LENGTH + 4) then return false end

  local s = last_msg:sub(METER_LENGTH + 1, METER_LENGTH + 4)
  return s == " HP[" or s == " MP["
end

---- Hook functions ----
function f_announce_hp_mp.init()
  ad_prev.hp = 0
  ad_prev.mhp = 0
  ad_prev.mp = 0
  ad_prev.mmp = 0

  if Config.always_on_bottom then Config.Announce = ALWAYS_BOTTOM_SETTINGS end

  if Config.dmg_fm_threshold > 0 and Config.dmg_fm_threshold <= 0.5 then
    BRC.set.message_mute("Ouch! That really hurt!", true)
  end
end

function f_announce_hp_mp.ready()
  -- Update prev state first, so we can safely return early below
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  local is_startup = ad_prev.hp == 0
  local hp_delta = hp - ad_prev.hp
  local mp_delta = mp - ad_prev.mp
  local mhp_delta = mhp - ad_prev.mhp
  local mmp_delta = mmp - ad_prev.mmp
  local damage_taken = mhp_delta - hp_delta
  ad_prev.hp = hp
  ad_prev.mhp = mhp
  ad_prev.mp = mp
  ad_prev.mmp = mmp

  if is_startup then return end
  if hp_delta == 0 and mp_delta == 0 and last_msg_is_meter() then return end
  local is_very_low_hp = hp <= Config.Announce.very_low_hp * mhp

  -- Determine which messages to show
  local do_hp = true
  local do_mp = true
  if hp_delta <= 0 and hp_delta > -Config.Announce.hp_loss_limit then do_hp = false end
  if hp_delta >= 0 and hp_delta < Config.Announce.hp_gain_limit then do_hp = false end
  if mp_delta <= 0 and mp_delta > -Config.Announce.mp_loss_limit then do_mp = false end
  if mp_delta >= 0 and mp_delta < Config.Announce.mp_gain_limit then do_mp = false end

  if not do_hp and is_very_low_hp and hp_delta ~= 0 then do_hp = true end
  if not do_hp and not do_mp then return end
  if Config.Announce.always_both then
    do_hp = true
    do_mp = true
  end

  -- Put messages together
  local hp_msg = get_hp_message(hp_delta, mhp_delta)
  local mp_msg = get_mp_message(mp_delta, mmp_delta)
  local msg_tokens = {}
  msg_tokens[1] = (Config.Announce.hp_first and do_hp) and hp_msg or mp_msg
  if do_mp and do_hp then
    msg_tokens[2] = Config.Announce.same_line and string.rep(" ", 7) or "\n"
    msg_tokens[3] = Config.Announce.hp_first and mp_msg or hp_msg
  end
  if #msg_tokens > 0 then BRC.mpr.que(table.concat(msg_tokens)) end

  -- Add Damage-related warnings, when damage >= threshold
  if damage_taken >= mhp * Config.dmg_flash_threshold then
    if is_very_low_hp then return end -- mute % HP alerts
    if damage_taken >= (mhp * Config.dmg_fm_threshold) then
      local msg = BRC.text.lightmagenta("MASSIVE DAMAGE")
      BRC.mpr.que_optmore(true, BRC.text.wrap(msg, BRC.EMOJI.EXCLAMATION_2))
    else
      local msg = BRC.text.magenta("BIG DAMAGE")
      BRC.mpr.que_optmore(false, BRC.text.wrap(msg, BRC.EMOJI.EXCLAMATION))
    end
  end
end

}
############################### End lua/features/announce-hp-mp.lua ###############################
##########################################################################################

################################### Begin lua/features/answer-prompts.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: answer-prompts
Description: Automatically answer crawl prompts
Author: buehler
Dependencies: core/util.lua
--]]

f_answer_prompts = {}
f_answer_prompts.BRC_FEATURE_NAME = "answer_prompts"

function f_answer_prompts.c_answer_prompt(prompt)
  if prompt == "Die?" then return false end
  if prompt:contains("cheaper one?") and you.branch() ~= "Bazaar" then
    BRC.mpr.yellow("Replacing shopping list items")
    return true
  end
end

}
############################### End lua/features/answer-prompts.lua ###############################
##########################################################################################

################################### Begin lua/features/color-inscribe.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: color-inscribe
Description: Colorizes inscriptions: resistances, stats, and other properties
Author: buehler
Dependencies: core/constants.lua, inscribe-stats.lua
--]]

f_color_inscribe = {}
f_color_inscribe.BRC_FEATURE_NAME = "color-inscribe"

---- Local constants / configuration ----
local LOSS_COLOR = BRC.COL.brown
local GAIN_COLOR = BRC.COL.white
local MULTI_PLUS = "%++"
local MULTI_MINUS = "%-+"
local NEG_NUM = "%-%d+%.?%d*"
local POS_NUM = "%+%d+%.?%d*"
local POS_WORN = ":%d+%.?%d*"
local COLORIZE_TAGS = {
  { "rF" .. MULTI_PLUS, BRC.COL.lightred },
  { "rF" .. MULTI_MINUS, LOSS_COLOR },
  { "rC" .. MULTI_PLUS, BRC.COL.lightblue },
  { "rC" .. MULTI_MINUS, LOSS_COLOR },
  { "rN" .. MULTI_PLUS, BRC.COL.lightmagenta },
  { "rN" .. MULTI_MINUS, LOSS_COLOR },
  { "rPois", BRC.COL.lightgreen },
  { "rElec", BRC.COL.lightcyan },
  { "rCorr", BRC.COL.yellow },
  { "rMut", BRC.COL.yellow },
  { "sInv", BRC.COL.magenta },
  { "MRegen" .. MULTI_PLUS, BRC.COL.cyan },
  { "^Regen" .. MULTI_PLUS, BRC.COL.green }, -- Avoiding "MRegen"
  { " Regen" .. MULTI_PLUS, BRC.COL.green }, -- Avoiding "MRegen"
  { "Stlth" .. MULTI_PLUS, GAIN_COLOR },
  { "%+Fly", GAIN_COLOR },
  { "RMsl", BRC.COL.yellow },
  { "Will" .. MULTI_PLUS, BRC.COL.blue },
  { "Will" .. MULTI_MINUS, LOSS_COLOR },
  { "Wiz" .. MULTI_PLUS, BRC.COL.cyan },
  { "Wiz" .. MULTI_MINUS, LOSS_COLOR },
  { "Slay" .. POS_NUM, GAIN_COLOR },
  { "Slay" .. NEG_NUM, LOSS_COLOR },
  { "Str" .. POS_NUM, GAIN_COLOR },
  { "Str" .. NEG_NUM, LOSS_COLOR },
  { "Dex" .. POS_NUM, GAIN_COLOR },
  { "Dex" .. NEG_NUM, LOSS_COLOR },
  { "Int" .. POS_NUM, GAIN_COLOR },
  { "Int" .. NEG_NUM, LOSS_COLOR },
  { "AC" .. POS_NUM, GAIN_COLOR },
  { "AC" .. POS_WORN, GAIN_COLOR },
  { "AC" .. NEG_NUM, LOSS_COLOR },
  { "EV" .. POS_NUM, GAIN_COLOR },
  { "EV" .. POS_WORN, GAIN_COLOR },
  { "EV" .. NEG_NUM, LOSS_COLOR },
  { "SH" .. POS_NUM, GAIN_COLOR },
  { "SH" .. POS_WORN, GAIN_COLOR },
  { "SH" .. NEG_NUM, LOSS_COLOR },
  { "HP" .. POS_NUM, GAIN_COLOR },
  { "HP" .. NEG_NUM, LOSS_COLOR },
  { "MP" .. POS_NUM, GAIN_COLOR },
  { "MP" .. NEG_NUM, LOSS_COLOR },
} -- COLORIZE_TAGS (do not remove this comment)

---- Local functions ----
local function colorize_subtext(text, subtext, tag)
  if not text:find(subtext) then return text end
  -- Remove current color tag if it exists
  text = text:gsub("<(%d%d?)>(" .. subtext .. ")</%1>", "%2")
  return text:gsub(subtext, string.format("<%s>%%1</%s>", tag, tag))
end

---- Public API ----
function f_color_inscribe.colorize(it)
  local text = it.inscription
  for _, tag in ipairs(COLORIZE_TAGS) do
    text = colorize_subtext(text, tag[1], tag[2])
  end

  -- Limit length for % menu: = 80 total width - 25/32 other text - #name - #" {}"
  it.inscribe("", false)
  local max_length = 80 - (it.is_melded and 32 or 25) - #it.name("plain", true) - 3
  if max_length < 0 then return end
  -- Try removing darkgrey and white, then just remove all
  if #text > max_length then text = text:gsub("</?" .. BRC.COL.darkgrey .. ">", "") end
  if #text > max_length then text = text:gsub("</?" .. BRC.COL.white .. ">", "") end
  if #text > max_length then text = text:gsub("<.->", "") end

  it.inscribe(text, false)
end

---- Hook functions ----
function f_color_inscribe.c_assign_invletter(it)
  if it.artefact then return end
  -- If enabled, call inscribe stats before colorizing
  if
    f_inscribe_stats
    and f_inscribe_stats.Config
    and not f_inscribe_stats.Config.disabled
    and f_inscribe_stats.do_stat_inscription
    and (
      it.is_weapon and f_inscribe_stats.Config.inscribe_weapons
      or BRC.is.armour(it) and f_inscribe_stats.Config.inscribe_armour
    )
  then
    f_inscribe_stats.do_stat_inscription(it)
  end

  f_color_inscribe.colorize(it)
end

--[[
TODO: To colorize more, need a way to:
  intercept messages before they're displayed (or delete and re-insert)
  insert tags that affect menus
  colorize artefact text
function f_color_inscribe.c_message(text, _)
  local orig_text = text
  text = colorize_subtext(text)
  if text == orig_text then return end

  local cleaned = BRC.text.clean(text)
  if cleaned:sub(2, 4) == " - " then
    text = " " .. text
  end

  crawl.mpr(text)
end
--]]

}
############################### End lua/features/color-inscribe.lua ###############################
##########################################################################################

################################### Begin lua/features/drop-inferior.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: drop-inferior
Description: Auto-tags inferior items and adds them to the drop list for quick dropping with ","
Author: buehler
Dependencies: core/config.lua, core/util.lua, hotkey.lua
--]]

f_drop_inferior = {}
f_drop_inferior.BRC_FEATURE_NAME = "drop-inferior"
f_drop_inferior.Config = {
  msg_on_inscribe = true, -- Show a message when an item is marked for drop
  hotkey_drop = true, -- BRC hotkey drops all items on the drop list
} -- f_drop_inferior.Config (do not remove this comment)

---- Local constants ----
local DROP_KEY = "~~DROP_ME"

---- Local functions ----
local function inscribe_drop(it)
  local new_inscr = it.inscription:gsub(DROP_KEY, "") .. DROP_KEY
  it.inscribe(new_inscr, false)
  if f_drop_inferior.Config.msg_on_inscribe then
    local item_name = BRC.text.yellow(BRC.util.int2char(it.slot) .. " - " .. it.name())
    BRC.mpr.cyan(BRC.text.wrap("You can drop: " .. item_name, BRC.EMOJI.CAUTION))
  end
end

---- Hook functions ----
function f_drop_inferior.init()
  crawl.setopt("drop_filter += " .. DROP_KEY)
end

function f_drop_inferior.c_assign_invletter(it)
  -- Remove any previous DROP_KEY inscriptions
  it.inscribe(it.inscription:gsub(DROP_KEY, ""), false)

  if
    not (it.is_weapon or BRC.is.armour(it))
    or BRC.is.risky_item(it)
    or BRC.get.num_equip_slots(it) > 1
  then
    return
  end

  local it_ego = BRC.get.ego(it)
  local marked_something = false
  for _, inv in ipairs(items.inventory()) do
    -- To be a clear upgrade: Not artefact, same subtype, and ego is same or a clear upgrade
    local inv_ego = BRC.get.ego(inv)
    local not_worse = inv_ego == it_ego or not inv_ego or BRC.is.risky_item(inv)
    if not_worse and not inv.artefact and inv.subtype() == it.subtype() then
      if it.is_weapon then
        if inv.plus <= (it.plus or 0) then
          inscribe_drop(inv)
          marked_something = true
        end
      else
        local not_more_ac = BRC.get.armour_ac(inv) <= BRC.get.armour_ac(it)
        if not_more_ac and inv.encumbrance >= it.encumbrance then
          inscribe_drop(inv)
          marked_something = true
        end
      end
    end
  end

  if marked_something and f_drop_inferior.Config.hotkey_drop then
    BRC.set_hotkey("drop", "your useless items", function()
      crawl.sendkeys(BRC.get.command_key("CMD_DROP") .. ",\r")
    end, 1)
  end
end

}
############################### End lua/features/drop-inferior.lua ###############################
##########################################################################################

################################### Begin lua/features/dynamic-options.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: dynamic-options
Description: Changes options based on game state: xl, class, race, god, skills
Author: buehler
Dependencies: core/constants.lua, core/util.lua
--]]

f_dynamic_options = {}
f_dynamic_options.BRC_FEATURE_NAME = "dynamic-options"

---- Local constants / configuration ----
local XL_FORCE_MORES = {
  { pattern = "monster_warning:wielding.*of electrocution", xl = 5 },
  { pattern = "You.*re more poisoned", xl = 7 },
  { pattern = "^(?!.*Your?).*speeds? up", xl = 10 },
  { pattern = "danger:goes berserk", xl = 18 },
  { pattern = "monster_warning:carrying a wand of", xl = 15 },
} -- XL_FORCE_MORES (do not remove this comment)

local IGNORE_SPELLBOOKS_STRING = table.concat(BRC.SPELLBOOKS, ", ")
local HIGH_LVL_MAGIC_STRING = "scrolls? of amnesia, potions? of brilliance, ring of wizardry"

---- Local variables ----
local cur_god
local ignore_all_magic
local ignore_advanced_magic
local xl_force_mores_active

---- Local functions ----
local function set_class_options()
  if you.class() == "Hunter" then
    crawl.setopt("view_delay = 30")
  elseif you.class() == "Shapeshifter" then
    BRC.set.autopickup_exceptions("<flux bauble", true)
  end
end

local function set_god_options()
  if cur_god == you.god() then return end
  local prev_god = cur_god
  local new_god = you.god()
  cur_god = new_god

  if prev_god == "No God" or new_god == "No God" then
    local abandoned_god = new_god == "No God"
    BRC.set.force_more_message("Found.*the Ecumenical Temple", abandoned_god)
    BRC.set.flash_screen_message("Found.*the Ecumenical Temple", not abandoned_god)
    BRC.set.runrest_stop_message("Found.*the Ecumenical Temple", not abandoned_god)
  end

  if new_god == "Beogh" or prev_god == "Beogh" then
    local joined_beogh = new_god == "Beogh"
    BRC.set.runrest_ignore_message("no longer looks.*", joined_beogh)
    BRC.set.force_more_message("Your orc.*dies", joined_beogh)
  end

  if new_god == "Cheibriados" then
    util.remove(BRC.RISKY_EGOS, "Ponderous")
  elseif prev_god == "Cheibriados" then
    BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "Ponderous"
  end

  if new_god == "Jiyva" or prev_god == "Jiyva" then
    local joined_jiyva = new_god == "Jiyva"
    BRC.set.flash_screen_message("god:splits in two", joined_jiyva)
    BRC.set.message_mute("You hear a.*(slurping|squelching) noise", joined_jiyva)
  end

  if new_god == "Lugonu" then
    util.remove(BRC.RISKY_EGOS, "distort")
  elseif prev_god == "Lugonu" then
    BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "distort"
  end

  if new_god == "Trog" then
    util.remove(BRC.BAD_ART_PROPS, "-Cast")
    util.remove(BRC.RISKY_EGOS, "antimagic")
  elseif prev_god == "Trog" then
    BRC.BAD_ART_PROPS[#BRC.BAD_ART_PROPS + 1] = "-Cast"
    BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "antimagic"
  end

  if new_god == "Xom" or prev_god == "Xom" then
    BRC.set.flash_screen_message("god:", new_god == "Xom")
  end
end

local function set_race_options()
  if util.contains(BRC.UNDEAD_RACES, you.race()) then
    BRC.set.force_more_message("monster_warning:wielding.*of holy wrath", true)
  end

  if not util.contains(BRC.POIS_RES_RACES, you.race()) then
    BRC.set.force_more_message("monster_warning:curare", true)
  end

  if you.race() == "Gnoll" then
    BRC.set.message_mute("intrinsic_gain:skill increases to level", true)
  end
end

local function set_xl_options()
  for i, v in ipairs(XL_FORCE_MORES) do
    local should_be_active = you.xl() <= v.xl
    if xl_force_mores_active[i] ~= should_be_active then
      xl_force_mores_active[i] = should_be_active
      BRC.set.force_more_message(v.pattern, should_be_active)
    end
  end
end

local function set_skill_options()
  -- If zero spellcasting, don't stop on spellbook pickup, and allow -Cast / antimagic
  local no_spells = #you.spells() == 0
  if ignore_all_magic ~= no_spells then
    ignore_all_magic = no_spells
    BRC.set.explore_stop_pickup_ignore(IGNORE_SPELLBOOKS_STRING, no_spells)
    if no_spells then
      util.remove(BRC.BAD_ART_PROPS, "-Cast")
      util.remove(BRC.RISKY_EGOS, "antimagic")
    else
      BRC.BAD_ART_PROPS[#BRC.BAD_ART_PROPS + 1] = "-Cast"
      BRC.RISKY_EGOS[#BRC.RISKY_EGOS + 1] = "antimagic"
    end
  end

  -- If heavy armour and low armour skill, ignore spellcasting items
  if ignore_all_magic and (you.race() ~= "Mountain Dwarf") then
    local worn = items.equipped_at("armour")
    local encumbered_magic = worn and worn.encumbrance > (4 + you.skill("Armour") / 2)
    if ignore_advanced_magic ~= encumbered_magic then
      ignore_advanced_magic = encumbered_magic
      BRC.set.autopickup_exceptions(HIGH_LVL_MAGIC_STRING, encumbered_magic)
    end
  end
end

---- Hook functions ----
function f_dynamic_options.init()
  cur_god = "No God"
  ignore_advanced_magic = false
  ignore_all_magic = false
  xl_force_mores_active = {}

  set_race_options()
  set_class_options()
  set_god_options()
end

function f_dynamic_options.ready()
  set_god_options()
  set_xl_options()
  set_skill_options()
end

}
############################### End lua/features/dynamic-options.lua ###############################
##########################################################################################

################################### Begin lua/features/exclude-dropped.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: exclude-dropped
Description: Excludes dropped items from autopickup, resumes on pickup.
Author: buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua
--]]

f_exclude_dropped = {}
f_exclude_dropped.BRC_FEATURE_NAME = "exclude-dropped"
f_exclude_dropped.Config = {
  not_weapon_scrolls = true, -- Don't exclude enchant/brand scrolls if holding an enchantable weapon
} -- f_exclude_dropped.Config (do not remove this comment)

---- Persistent variables ----
ed_dropped_items = BRC.Data.persist("ed_dropped_items", {})

---- Local functions ----
local function add_exclusion(item_name)
  if not util.contains(ed_dropped_items, item_name) then
    table.insert(ed_dropped_items, item_name)
  end
  BRC.set.autopickup_exceptions(item_name, true)
end

local function remove_exclusion(item_name)
  util.remove(ed_dropped_items, item_name)
  BRC.set.autopickup_exceptions(item_name, false)
end

local function enchantable_weap_in_inv()
  return util.exists(items.inventory(), function(i)
    return i.is_weapon
      and not BRC.is.magic_staff(i)
      and i.plus < 9
      and (not i.artefact or you.race() == "Mountain Dwarf")
  end)
end

local function clean_item_text(text)
  text = BRC.text.clean(text)
  text = text:gsub("{.*}", "")
  text = text:gsub("[.]", "")
  text = text:gsub("%(.*%)", "")
  return util.trim(text)
end

local function extract_jewellery_or_evoker(text)
  local idx = text:find("ring of", 1, true)
    or text:find("amulet of", 1, true)
    or text:find("wand of", 1, true)
  if idx then return text:sub(idx, #text) end

  for _, item_name in ipairs(BRC.MISC_ITEMS) do
    if text:find(item_name) then return item_name end
  end
end

local function extract_missile(text)
  for _, item_name in ipairs(BRC.MISSILES) do
    if text:find(item_name) then return item_name end
  end
end

local function extract_potion(text)
  local idx = text:find("potions? of")
  if idx then return "potions? of " .. util.trim(text:sub(idx + 10, #text)) end
end

local function extract_scroll(text)
  local idx = text:find("scrolls? of")
  if idx then return "scrolls? of " .. util.trim(text:sub(idx + 10, #text)) end
end

--[[
  get_item_name() - Tries to extract item name from text.
  Returns name of item, or nil if not recognized as an excludable item.
--]]
local function get_item_name(text)
  text = clean_item_text(text)
  return extract_jewellery_or_evoker(text)
    or extract_missile(text)
    or extract_potion(text)
    or extract_scroll(text)
end

local function should_exclude(item_name, full_msg)
  -- Enchant/Brand weapon scrolls continue pickup if they're still useful
  if
    f_exclude_dropped.Config.not_weapon_scrolls
    and (item_name:contains("enchant weapon") or item_name:contains("brand weapon"))
    and enchantable_weap_in_inv()
  then
    return false
  end

  -- Don't exclude if we dropped partial stack (except for jewellery)
  for _, inv in ipairs(items.inventory()) do
    if inv.name("qual"):contains(item_name) then
      return BRC.is.jewellery(inv)
        or inv.quantity == 1
        or full_msg:contains("ou drop " .. item_name .. " " .. inv.quantity)
    end
  end

  return true
end

---- Hook functions ----
function f_exclude_dropped.init()
  for _, v in ipairs(ed_dropped_items) do
    add_exclusion(v)
  end
end

function f_exclude_dropped.c_message(text, channel)
  if channel ~= "plain" then return end

  local picked_up = BRC.text.get_pickup_info(text)
  if not picked_up and not text:contains("ou drop ") then return end

  local item_name = get_item_name(text)
  if not item_name then return end

  if picked_up then
    remove_exclusion(item_name)
  elseif should_exclude(item_name, text) then
    add_exclusion(item_name)
  end
end

}
############################### End lua/features/exclude-dropped.lua ###############################
##########################################################################################

################################### Begin lua/features/fully-recover.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: fully-recover
Description: Rests until no negative duration statuses. Doesn't stop on each status message.
Author: buehler
Dependencies: core/util.lua
--]]

f_fully_recover = {}
f_fully_recover.BRC_FEATURE_NAME = "fully-recover"
f_fully_recover.Config = {
  rest_off_statuses = { -- Keep resting until these statuses are gone
    "berserk", "confused", "corroded", "diminished spells", "marked", "short of breath",
    "slowed", "sluggish", "tree%-form", "vulnerable", "weakened",
  },
} -- f_fully_recover.Config (do not remove this comment)

---- Local config alias ----
local Config = f_fully_recover.Config

---- Local constants ----
local MAX_TURNS_TO_WAIT = 500

---- Local variables ----
local recovery_start_turn
local explore_after_recovery

---- Local functions ----
local function abort_fully_recover()
  recovery_start_turn = 0
  explore_after_recovery = false
  you.stop_activity()
end

local function finish_fully_recover()
  local turns = you.turns() - recovery_start_turn
  BRC.mpr.lightgreen(string.format("Fully recovered (%d turns)", turns))

  recovery_start_turn = 0
  you.stop_activity()

  if explore_after_recovery then
    explore_after_recovery = false
    BRC.util.do_cmd("CMD_EXPLORE")
  end
end

local function should_ignore_status(s)
  if s == "corroded" then
    return BRC.you.by_slimy_wall() or you.branch() == "Dis"
  elseif s == "slowed" then
    return BRC.you.zero_stat()
  end
  return false
end

local function fully_recovered()
  if you.contaminated() > 0 then return false end
  local hp, mhp = you.hp()
  local mp, mmp = you.mp()
  if hp ~= mhp then return false end
  if mp ~= mmp then return false end

  local status = you.status()
  for _, s in ipairs(Config.rest_off_statuses) do
    if status:find(s) and not should_ignore_status(s) then return false end
  end

  return true
end

local function remove_statuses_from_config()
  local status = you.status()
  local to_remove = {}
  for _, s in ipairs(Config.rest_off_statuses) do
    if status:find(s) then table.insert(to_remove, s) end
  end
  for _, s in ipairs(to_remove) do
    util.remove(Config.rest_off_statuses, s)
    BRC.log.error("  Removed: " .. s)
  end
end

local function start_fully_recover()
  recovery_start_turn = you.turns()
  BRC.set.single_turn_mute("You start waiting.")
end

---- Macro function: Attach full recovery to auto-explore ----
function macro_brc_explore()
  if not BRC.active or f_fully_recover.Config.disabled then
    return BRC.util.do_cmd("CMD_EXPLORE")
  end

  if fully_recovered() then
    if recovery_start_turn > 0 then
      finish_fully_recover()
    else
      BRC.util.do_cmd("CMD_EXPLORE")
    end
  else
    if you.feel_safe() then explore_after_recovery = true end
    BRC.util.do_cmd("CMD_REST")
  end
end

---- Hook functions ----
function f_fully_recover.init()
  recovery_start_turn = 0
  explore_after_recovery = false

  BRC.set.runrest_ignore_message("recovery:.*", true)
  BRC.set.runrest_ignore_message("duration:.*", true)
  BRC.set.macro(BRC.get.command_key("CMD_EXPLORE") or "o", "macro_brc_explore")

  BRC.set.message_mute("^HP restored", true)
  BRC.set.message_mute("Magic restored", true)
end

function f_fully_recover.c_message(text, channel)
  if channel == "plain" then
    if text:contains("ou start waiting") or text:contains("ou start resting") then
      if not fully_recovered() then start_fully_recover() end
    end
  elseif recovery_start_turn > 0 then
    if channel == "timed_portal" then
      abort_fully_recover()
    elseif fully_recovered() then
      finish_fully_recover()
    end
  end
end

function f_fully_recover.ready()
  if recovery_start_turn > 0 then
    if fully_recovered() then
      finish_fully_recover()
    elseif not you.feel_safe() then
      abort_fully_recover()
    elseif you.turns() - recovery_start_turn > MAX_TURNS_TO_WAIT then
      BRC.log.error("fully-recover timed out after " .. MAX_TURNS_TO_WAIT .. " turns.", true)
      BRC.log.error("f_fully_recover.Config.rest_off_statuses:")
      remove_statuses_from_config()
      abort_fully_recover()
    else
      BRC.util.do_cmd("CMD_SAFE_WAIT")
    end
  else
    explore_after_recovery = false
  end
end

}
############################### End lua/features/fully-recover.lua ###############################
##########################################################################################

################################### Begin lua/features/hotkey.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: hotkey
Description: Configures a BRC hotkey that features can assign actions to
Author: buehler
Dependencies: core/data.lua, core/util.lua
--]]

f_hotkey = {}
f_hotkey.BRC_FEATURE_NAME = "hotkey"
f_hotkey.Config = {
  key = { keycode = "13", name = "[Enter]" },
  skip_keycode = BRC.KEYS.ESC,
  equip_hotkey = true,
} -- f_hotkey.Config (do not remove this comment)

---- Config alias ----
local Config = f_hotkey.Config

---- Local constants ----
local WAYPOINT_MUTES = {
  "Assign waypoint to what number",
  "Existing waypoints",
  "Delete which waypoint",
  "\\(\\d\\) ",
  "All waypoints deleted",
  "You're already here!",
  "Okay\\, then\\.",
  "Unknown command",
  --"Waypoint \\d re-assigned",
} -- WAYPOINT_MUTES (do not remove this comment)

---- Local variables ----
local action_queue
local cur_action

---- Local functions ----
local function load_next_action()
  if #action_queue == 0 then return end
  cur_action = action_queue[1]
  cur_action.t = you.turns() + cur_action.t
  table.remove(action_queue, 1)
  local msg = string.format("[BRC] Press %s to %s.", Config.key.name, cur_action.m)
  BRC.mpr.que(msg, BRC.COL.darkgrey)
end

local function expire_cur_action()
  if cur_action and cur_action.c then cur_action.c() end
  cur_action = nil
  load_next_action()
end

local function get_avail_waypoint()
  for i = 9, 0, -1 do
    if not travel.waypoint_delta(i) then return i end
  end

  BRC.log.debug("No available waypoint slots. Clearing them.")
  util.foreach(WAYPOINT_MUTES, function(m) BRC.set.single_turn_mute(m) end)
  crawl.sendkeys({ BRC.util.cntl("w"), "d", "*" })
  crawl.flush_input()
  return 9
end

---- Macro function: On BRC hotkey press ----
function macro_brc_hotkey()
  if cur_action then
    cur_action.f()
    cur_action = nil
  else
    BRC.mpr.darkgrey("Unknown command (no actions assigned to BRC hotkey).")
  end
end

function macro_brc_skip_hotkey()
  if cur_action then
    expire_cur_action()
    if not cur_action then BRC.mpr.darkgrey("[BRC] Hotkey cleared.") end
  else
    crawl.sendkeys({ Config.skip_keycode })
  end
end

---- Public API ----
--- Assign an action to the BRC hotkey
-- @param msg_action string - The action (equip/pickup/read/etc)
-- @param msg_suffix string - Printed after the action. Usually an item name
-- @param func function - The function to call when the hotkey is pressed
-- @param turns number - The number of turns to wait before skipping this action
-- @param push_front boolean - Push the action to the front of the queue
-- @param cleanup optional function - Function to call when the hotkey is not pressed
-- @return nil
function BRC.set_hotkey(msg_action, msg_suffix, func, turns, push_front, cleanup)
  local act = { m = BRC.text.lightgreen(msg_action), f = func, t = turns or 1 }
  if msg_suffix then act.m = act.m .. " " .. BRC.text.white(msg_suffix) end
  if cleanup then act.c = cleanup end

  if push_front then
    table.insert(action_queue, 1, act)
  else
    table.insert(action_queue, act)
  end

  -- If possible, load the action on same turn as the alert that triggered it
  if #action_queue == 1 and cur_action == nil then
    act.t = act.t + 1
    load_next_action()
  end
end

function BRC.set_pickup_hotkey(name, push_front)
  local do_pickup = function()
    for _, fl in ipairs(you.floor_items()) do
      if fl.name() == name then
        items.pickup(fl)
        return
      end
    end
    BRC.mpr.darkgrey(name .. " isn't here!")
  end

  BRC.set_hotkey("pickup", name, do_pickup, 1, push_front)
end

function BRC.set_equip_hotkey(it, push_front)
  if not (it.is_weapon or BRC.is.armour(it) or BRC.is.jewellery(it)) then return end
  local NAME = it.name():gsub(" {.*}", "")

  local do_equip = function()
    local inv_items = util.filter(function(i)
      return i.name():gsub(" {.*}", "") == NAME
    end, items.inventory())

    local already_eq = false
    for i = 1, #inv_items do
      if inv_items[i].equipped then
        already_eq = true
      else
        inv_items[i]:equip()
        return
      end
    end

    if already_eq then
      BRC.mpr.darkgrey("Already equipped.")
    else
      BRC.log.error("Could not find unequipped item '" .. NAME .. "' in inventory.")
    end
  end

  BRC.set_hotkey("equip", NAME, do_equip, 1, push_front)
end

function BRC.set_waypoint_hotkey(name, push_front)
  local x, y = BRC.get.item_xy(name)
  if x == nil then return BRC.log.debug(name .. " not found in LOS") end

  local waynum = get_avail_waypoint()
  BRC.set.single_turn_mute("Waypoint \\d assigned")
  travel.set_waypoint(waynum, x, y)

  local clear_waypoint = function()
    local keys = { BRC.util.cntl("w"), "d", tostring(waynum) }
    -- If other waypoints exist, need to send ESC to exit the prompt
    for i = 0, 9 do
      if i ~= waynum and travel.waypoint_delta(i) then
        keys[#keys + 1] = BRC.KEYS.ESC
      end
    end

    util.foreach(WAYPOINT_MUTES, function(m) BRC.set.single_turn_mute(m) end)
    crawl.sendkeys(keys)
    crawl.flush_input()
  end

  local move_to_waypoint = function()
    f_pickup_alert.pause_alerts() -- Don't interrupt hotkey travel with new alerts
    crawl.sendkeys({ BRC.get.command_key("CMD_INTERLEVEL_TRAVEL"), tostring(waynum) })

    -- Delete waypoint after travel, silence the prompts, push a pickup hotkey
    crawl.sendkeys({ BRC.util.cntl("w"), "d", tostring(waynum), BRC.KEYS.ESC })
    util.foreach(WAYPOINT_MUTES, function(m) BRC.set.single_turn_mute(m) end)

    BRC.set_pickup_hotkey(name, true)
  end

  BRC.set_hotkey("move to", name, move_to_waypoint, 1, push_front, clear_waypoint)
end

---- Hook functions ----
function f_hotkey.init()
  action_queue = {}
  cur_action = nil

  BRC.set.macro("\\{" .. Config.key.keycode .. "}", "macro_brc_hotkey")
  BRC.set.macro("\\{" .. Config.skip_keycode .. "}", "macro_brc_skip_hotkey")
end

function f_hotkey.c_assign_invletter(it)
  if Config.equip_hotkey then BRC.set_equip_hotkey(it, true) end
end

function f_hotkey.ready()
  if cur_action == nil or cur_action.t <= you.turns() then
    expire_cur_action()
  end
end

}
############################### End lua/features/hotkey.lua ###############################
##########################################################################################

################################### Begin lua/features/inscribe-stats.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: inscribe-stats
Description: Inscribes+updates weapon DPS/dmg/delay, or armour AC/EV/SH, on items in inventory
Author: buehler
Dependencies: core/constants.lua, core/util.lua, color-inscribe.lua
--]]

f_inscribe_stats = {}
f_inscribe_stats.BRC_FEATURE_NAME = "inscribe-stats"
f_inscribe_stats.Config = {
  inscribe_weapons = true, -- Inscribe weapon stats on pickup
  inscribe_armour = true, -- Inscribe armour stats on pickup
  dmg_type = BRC.DMG_TYPE.plain,
} -- f_inscribe_stats.Config (do not remove this comment)

---- Local config alias ----
local Config = f_inscribe_stats.Config

---- Local constants / configuration ----
local NUM_PATTERN = "[%+%-:]%d+%.%d*" -- Matches numbers w/ decimal

---- Local functions ----
local function inscribe_armour_stats(it)
  local abbr = BRC.is.shield(it) and "SH" or "AC"
  local ac_or_sh, ev = BRC.get.armour_stats(it)
  local sign_change = false

  local new_insc
  if it.inscription:find(abbr .. NUM_PATTERN) then
    new_insc = it.inscription:gsub(abbr .. NUM_PATTERN, ac_or_sh)
    if not it.inscription:contains(ac_or_sh:sub(1, 3)) then sign_change = true end

    if ev and ev ~= "" then
      new_insc = new_insc:gsub("EV" .. NUM_PATTERN, ev)
      if not it.inscription:contains(ev:sub(1, 3)) then sign_change = true end
    end
  else
    new_insc = ac_or_sh
    if ev and ev ~= "" then new_insc = string.format("%s, %s", new_insc, ev) end
    if it.inscription and it.inscription ~= "" then
      new_insc = string.format("%s; %s", new_insc, it.inscription)
    end
  end

  it.inscribe(new_insc, false)

  -- If f_color_inscribe is enabled, update the color
  if
    sign_change
    and f_color_inscribe
    and f_color_inscribe.Config
    and not f_color_inscribe.Config.disabled
    and f_color_inscribe.colorize
  then
    f_color_inscribe.colorize(it)
  end
end

local function inscribe_weapon_stats(it)
  local orig_inscr = it.inscription
  local dps_inscr = BRC.get.weapon_stats(it, BRC.DMG_TYPE[Config.dmg_type])
  local prefix, suffix = "", ""

  local idx = orig_inscr:find("DPS:", 1, true)
  if idx then
    if idx > 1 then prefix = orig_inscr:sub(1, idx - 1) .. "; " end
    if idx + #dps_inscr - 1 < #orig_inscr then
      suffix = orig_inscr:sub(idx + #dps_inscr, #orig_inscr)
    end
  elseif #orig_inscr > 0 then
    suffix = "; " .. orig_inscr
  end

  it.inscribe(table.concat({ prefix, dps_inscr, suffix }), false)
end

---- Hook functions ----
function f_inscribe_stats.do_stat_inscription(it)
  if Config.inscribe_weapons and it.is_weapon then
    inscribe_weapon_stats(it)
  elseif Config.inscribe_armour and BRC.is.armour(it) and not BRC.is.scarf(it) then
    inscribe_armour_stats(it)
  end
end

function f_inscribe_stats.ready()
  for _, inv in ipairs(items.inventory()) do
    f_inscribe_stats.do_stat_inscription(inv)
  end
end

}
############################### End lua/features/inscribe-stats.lua ###############################
##########################################################################################

################################### Begin lua/features/misc-alerts.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: misc-alerts
Description: Provides various single-purpose alerts: low HP, faith amulet, and spell level changes
Author: orig save w/msg by gammafunk, buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua, hotkey.lua
--]]

f_misc_alerts = {}
f_misc_alerts.BRC_FEATURE_NAME = "misc-alerts"
f_misc_alerts.Config = {
  save_with_msg = true, -- Shift-S to save and leave yourself a message
  alert_low_hp_threshold = 0.35, -- % max HP to alert; 0 to disable
  alert_spell_level_changes = true, -- Alert when you gain additional spell levels
  alert_remove_faith = true, -- Reminder to remove amulet at max piety
  remove_faith_hotkey = true, -- Hotkey remove amulet
} -- f_misc_alerts.Config (do not remove this comment)

---- Persistent variables ----
ma_alerted_max_piety = BRC.Data.persist("ma_alerted_max_piety", false)
ma_saved_msg = BRC.Data.persist("ma_saved_msg", "")

---- Local config alias ----
local Config = f_misc_alerts.Config

---- Local constants / configuration ----
local REMOVE_FAITH_MSG = "6 star piety! Maybe ditch that amulet soon."

---- Local variables ----
local below_hp_threshold
local prev_spell_levels

---- Local functions ----
local function alert_low_hp()
  local hp, mhp = you.hp()
  if below_hp_threshold then
    below_hp_threshold = hp ~= mhp
  elseif hp <= Config.alert_low_hp_threshold * mhp then
    below_hp_threshold = true
    local low_hp_msg = "Dropped below " .. 100 * Config.alert_low_hp_threshold .. "%% HP"
    BRC.mpr.que_optmore(true, BRC.text.wrap(BRC.text.magenta(low_hp_msg), BRC.EMOJI.EXCLAMATION))
  end
end

local function alert_remove_faith()
  if not ma_alerted_max_piety and you.piety_rank() == 6 then
    local am = items.equipped_at("amulet")
    if am and am.subtype() == "amulet of faith" and not am.artefact then
      if you.god() == "Uskayaw" then return end
      BRC.mpr.more(REMOVE_FAITH_MSG, BRC.COL.lightcyan)
      ma_alerted_max_piety = true
      if Config.remove_faith_hotkey then
        BRC.set_hotkey("remove", "amulet of faith", function()
          items.equipped_at("amulet"):remove()
        end, 1)
      end
    end
  end
end

local function alert_spell_level_changes()
  local new_spell_levels = you.spell_levels()
  if new_spell_levels > prev_spell_levels then
    local delta = new_spell_levels - prev_spell_levels
    local msg = string.format("Gained %s spell level%s", delta, delta > 1 and "s" or "")
    local suffix = string.format(" (%s available)", new_spell_levels)
    BRC.mpr.lightcyan(msg .. BRC.text.cyan(suffix))
  elseif new_spell_levels < prev_spell_levels then
    BRC.mpr.magenta(new_spell_levels .. " spell levels remaining")
  end

  prev_spell_levels = new_spell_levels
end

---- Macro function: Save with message feature ----
function macro_brc_save()
  if not BRC.active or f_misc_alerts.Config.disabled then
    return BRC.util.do_cmd("CMD_SAVE_GAME")
  end

  if not BRC.mpr.yesno("Save game and exit?", BRC.COL.lightcyan) then
    BRC.mpr.okay()
    return
  end

  BRC.mpr.white("Leave a message: ", "prompt")
  ma_saved_msg = crawl.c_input_line()
  BRC.util.do_cmd("CMD_SAVE_GAME_NOW")
end

---- Hook functions ----
function f_misc_alerts.init()
  below_hp_threshold = false
  prev_spell_levels = you.spell_levels()

  if Config.save_with_msg then
    BRC.set.macro(BRC.get.command_key("CMD_SAVE_GAME") or "S", "macro_brc_save")
    if ma_saved_msg and ma_saved_msg ~= "" then
      BRC.mpr.white("MESSAGE: " .. ma_saved_msg)
      ma_saved_msg = nil
    end
  end
end

function f_misc_alerts.ready()
  if Config.alert_remove_faith then alert_remove_faith() end
  if Config.alert_low_hp_threshold > 0 then alert_low_hp() end
  if Config.alert_spell_level_changes then alert_spell_level_changes() end
end

}
############################### End lua/features/misc-alerts.lua ###############################
##########################################################################################

################################### Begin lua/features/mute-messages.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: mute-messages
Description: Mutes various crawl messages, with configurable levels of reduction
Author: buehler
Dependencies: core/util.lua
--]]

f_mute_messages = {}
f_mute_messages.BRC_FEATURE_NAME = "mute-messages"
f_mute_messages.Config = {
  mute_level = 2,
  messages = {
    -- Light reduction; unnecessary messages
    [1] = {

      -- Unnecessary
      "You now have .* runes",
      "to see all the runes you have collected",
      "A chill wind blows around you",
      "An electric hum fills the air",
      "You reach to attack",

      -- Interface
      "for a list of commands and other information",
      "Marking area around",
      "(Reduced|Removed|Placed new) exclusion",
      "You can access your shopping list by pressing '\\$'",

      -- Wielding weapons
      "Your .* exudes an aura of protection",
      "Your .* glows with a cold blue light",

      -- Monsters /Allies / Neutrals
      "dissolves into shadows",
      "You swap places",
      "Your spectral weapon disappears",

      -- Spells
      "Your foxfire dissipates",

      -- Religion
      "accepts your kill",
      "is honoured by your kill",
    },

    -- Moderate reduction; potentially confusing but no info lost
    [2] = {
      -- Allies / monsters
      "Ancestor HP restored",
      "The (bush|fungus|plant) (looks sick|begins to die|is engulfed|is struck)",
      "evades? a web",
      "is (lightly|moderately|heavily|severely) (damaged|wounded)",
      "is almost (dead|destroyed)",

      -- Interface
      "Use which ability\\?",
      "Evoke which item\\?$",
      "Shift\\-Dir \\- straight line",

      -- Books
      "You pick up (?!a manual).*and begin reading",
      "Unfortunately\\, you learn nothing new",

      -- Ground items / features
      "There is a.*(door|gate|staircase|web).*here",
      "You see here .*(corpse|skeleton)",
      "You now have \\d+ gold piece",
      "You enter the shallow water",
      "Moving in this stuff is going to be slow",

      -- Religion
      "Your shadow attacks",
    },

    -- Heavily reduced messages for speed runs
    [3] = {
      "No target in view",
      "You (headbutt|bite|kick)",
      "You block",
      "but do(es)? no damage",
      "misses you",
    },
  },
} -- f_mute_messages.Config (do not remove this comment)

function f_mute_messages.init()
  if f_mute_messages.Config.mute_level and f_mute_messages.Config.mute_level > 0 then
    for i = 1, f_mute_messages.Config.mute_level do
      if not f_mute_messages.Config.messages[i] then break end
      for _, message in ipairs(f_mute_messages.Config.messages[i]) do
        BRC.set.message_mute(message, true)
      end
    end
  end
end

}
############################### End lua/features/mute-messages.lua ###############################
##########################################################################################

################################### Begin lua/features/quiver-reminders.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: quiver-reminders
Description: A handful of useful quiver-related reminders
Author: buehler
Dependencies: core/data.lua, core/util.lua
--]]

f_quiver_reminders = {}
f_quiver_reminders.BRC_FEATURE_NAME = "quiver-reminders"
f_quiver_reminders.Config = {
  confirm_consumables = true,
  warn_diff_missile_turns = 10,
} -- f_quiver_reminders.Config (do not remove this comment)

---- Local variables ----
local last_thrown
local last_thrown_turn

---- Local config alias ----
local Config = f_quiver_reminders.Config

---- Local functions ----
local function quiver_missile_by_name(name)
  local slot = nil
  for _, inv in ipairs(items.inventory()) do
    if inv.name("qual") == name then
      slot = inv.slot
      break
    end
  end

  if not slot then return end
  crawl.sendkeys(BRC.get.command_key("CMD_QUIVER_ITEM") .. "*(" .. BRC.util.int2char(slot))
end

---- Macro function: Fire from quiver ----
function macro_brc_fire()
  if not BRC.active or Config.disabled then return BRC.util.do_cmd("CMD_FIRE") end
  local quivered = items.fired_item()
  if not quivered then return end

  if Config.confirm_consumables then
    local cls = quivered.class(true)
    if cls == "potion" or cls == "scroll" then
      local action = cls == "potion" and "drink" or "read"
      local q = BRC.text.lightgreen(quivered.name())
      local msg = string.format("Really %s %s from quiver?", action, q)
      if not BRC.mpr.yesno(msg) then return BRC.mpr.okay() end
    end
  end

  if you.turns() - last_thrown_turn <= Config.warn_diff_missile_turns then
    if last_thrown ~= quivered.name("qual") then
      local q = BRC.text.lightgreen(quivered.name("qual"))
      if not BRC.mpr.yesno("Did you mean to throw " .. q .. "?") then
        local t = BRC.text.lightgreen(last_thrown)
        if BRC.mpr.yesno("Quiver and throw " .. t .. " instead?") then
          quiver_missile_by_name(last_thrown)
        else
          return BRC.mpr.okay()
        end
      end
    end
  end

  BRC.util.do_cmd("CMD_FIRE")
end

---- Hook functions ----
function f_quiver_reminders.init()
  last_thrown = nil
  last_thrown_turn = -1
  BRC.set.macro(BRC.get.command_key("CMD_FIRE") or "f", "macro_brc_fire")
end

function f_quiver_reminders.c_message(text, _)
  local cleaned = BRC.text.clean(text)
  local prefix = "You throw a "
  if cleaned:sub(1, #prefix) == prefix then
    last_thrown = cleaned:sub(#prefix + 1, #cleaned - 1):gsub(" {.*}", "")
    last_thrown_turn = you.turns()
  end
end

}
############################### End lua/features/quiver-reminders.lua ###############################
##########################################################################################

################################### Begin lua/features/remind-id.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: remind-id
Description: Reminds to read ID scrolls.
Before finding scroll of ID, stops exploration when largest un-ID'd stack sizes increase.
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua, hotkey.lua
--]]

f_remind_id = {}
f_remind_id.BRC_FEATURE_NAME = "remind-id"
f_remind_id.Config = {
  stop_on_scrolls_count = 2, -- Stop when largest un-ID'd scroll stack increases and is >= this
  stop_on_pots_count = 3, -- Stop when largest un-ID'd potion stack increases and is >= this
  emoji = BRC.Config.emojis and "🎁" or BRC.text.magenta("?"),
} -- f_remind_id.Config (do not remove this comment)

---- Persistent variables ----
ri_found_scroll_of_id = BRC.Data.persist("ri_found_scroll_of_id", false)

---- Local config alias ----
local Config = f_remind_id.Config

---- Local constants / configuration ----
local IDENTIFY_MSG = BRC.text.magenta(" You have something to identify. ")
if Config.emoji then IDENTIFY_MSG = Config.emoji .. IDENTIFY_MSG .. Config.emoji end

---- Local variables ----
local do_remind_id_check

---- Local functions ----
local function get_max_stack(class)
  local max_stack_size = 0
  local slot = nil
  for _, inv in ipairs(items.inventory()) do
    if inv.class(true) == class and not inv.is_identified then
      if inv.quantity > max_stack_size then
        max_stack_size = inv.quantity
        slot = inv.slot
      elseif inv.quantity == max_stack_size then
        slot = nil -- If tied for max, no slot set a new max
      end
    end
  end
  return max_stack_size, slot
end

local function have_scroll_of_id()
  return util.exists(items.inventory(), function(i)
    return i.name("qual") == "scroll of identify"
  end)
end

local function have_unid_item()
  return util.exists(items.inventory(), function(i)
    return not i.is_identified
  end)
end

---- Hook functions ----
function f_remind_id.init()
  do_remind_id_check = true
end

function f_remind_id.c_assign_invletter(it)
  if
    not it.is_identified and have_scroll_of_id()
    or it.name("qual") == "scroll of identify" and have_unid_item()
  then
    you.stop_activity()
    do_remind_id_check = true
  end
end

function f_remind_id.c_message(text, channel)
  if channel ~= "plain" then return end

  if text:find("scrolls? of identify") then
    ri_found_scroll_of_id = true
    if not text:contains("ou drop ") and have_unid_item() then
      you.stop_activity()
      do_remind_id_check = true
    end
  else
    local name, slot = BRC.text.get_pickup_info(text)
    if not name then return end

    local is_scroll = name:contains("scroll")
    local is_potion = name:contains("potion")
    if not (is_scroll or is_potion) then return end

    if ri_found_scroll_of_id then
      -- Check for pickup unidentified consumable
      if not name:contains(" of ") then do_remind_id_check = true end
    else
      -- Check if max stack size increased
      local num_scrolls, slot_scrolls = get_max_stack("scroll")
      local num_pots, slot_pots = get_max_stack("potion")
      if
        is_scroll and slot_scrolls == slot and num_scrolls >= Config.stop_on_scrolls_count
        or is_potion and slot_pots == slot and num_pots >= Config.stop_on_pots_count
      then
        you.stop_activity()
      end
    end
  end
end

function f_remind_id.ready()
  if do_remind_id_check then
    do_remind_id_check = false
    if have_unid_item() and have_scroll_of_id() then
      BRC.mpr.stop(IDENTIFY_MSG)
      BRC.set_hotkey("read", "scroll of identify", function()
        for _, inv in ipairs(items.inventory()) do
          if inv.name("qual") == "scroll of identify" then
            BRC.util.do_cmd("CMD_READ")
            crawl.sendkeys(BRC.util.int2char(inv.slot))
            return
          end
        end
      end, 1)
    end
  end
end

}
############################### End lua/features/remind-id.lua ###############################
##########################################################################################

################################### Begin lua/features/runrest-features.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: runrest-features
Description: Simple features related to auto-explore stops: altars, gauntlets, portals, stairs, etc
Author: buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua
--]]

f_runrest_features = {}
f_runrest_features.BRC_FEATURE_NAME = "runrest-features"
f_runrest_features.Config = {
  after_shaft = true, -- stop on stairs after being shafted, until returned to original floor
  ignore_altars = true, -- when you don't need a god
  ignore_portal_exits = true, -- don't stop explore on portal exits
  stop_on_hell_stairs = true, -- stop explore on hell stairs
  stop_on_pan_gates = true, -- stop explore on pan gates
  temple_search = true, -- on entering or exploring temple, auto-search
  gauntlet_search = true, -- on entering or exploring gauntlet, auto-search with filters
} -- f_runrest_features.Config (do not remove this comment)

---- Persistent variables ----
rr_autosearched_temple = BRC.Data.persist("rr_autosearched_temple", false)
rr_autosearched_gauntlet = BRC.Data.persist("rr_autosearched_gauntlet", false)
rr_shaft_location = BRC.Data.persist("rr_shaft_location", nil)

---- Local config alias ----
local Config = f_runrest_features.Config

---- Local constants / configuration ----
local GAUNTLET_CONCAT_STRING = " && !!"
local GAUNTLET_SEARCH_STRING = table.concat({
  "gauntlet", "gate leading", "a transporter", "gold piece",
  " trap", "translucent door", "translucent gate"
  }, GAUNTLET_CONCAT_STRING)

---- Local variables ----
local stop_on_altars
local stop_on_portals
local stop_on_stairs

---- Local functions ----
local function is_explore_done_msg(text)
  local cleaned = BRC.text.clean(text)
  return cleaned == "Done exploring." or cleaned:find("Partly explored, ", 1, true) == 1
end

local function set_stairs_stop_state()
  local should_be_active = Config.stop_on_pan_gates and you.branch() == "Pan"
    or Config.stop_on_hell_stairs and BRC.you.in_hell(true)
    or Config.after_shaft and rr_shaft_location ~= nil

  if stop_on_stairs and not should_be_active then
    stop_on_stairs = false
    BRC.set.explore_stop("stairs", false)
  elseif not stop_on_stairs and should_be_active then
    stop_on_stairs = true
    BRC.set.explore_stop("stairs", true)
  end
end

-- Altar/Religion functions
local function religion_is_handled()
  if you.race() == "Demigod" then return true end
  if you.god() == "No God" then return false end
  if you.good_god() then return you.xl() > 9 end
  return true
end

local function ready_ignore_altars()
  if stop_on_altars and religion_is_handled() then
    stop_on_altars = false
    BRC.set.explore_stop("altars", false)
  elseif not stop_on_altars and not religion_is_handled() then
    stop_on_altars = true
    BRC.set.explore_stop("altars", true)
  end
end

-- Temple functions
local function search_altars()
  local cmd_key = BRC.get.command_key("CMD_SEARCH_STASHES") or BRC.util.cntl("f")
  crawl.sendkeys({ cmd_key, "altar", "\r" })
end

local function ready_temple_macro()
  if you.branch() == "Temple" and not rr_autosearched_temple then
    search_altars()
    rr_autosearched_temple = true
  end
end

local function c_message_temple(text, _)
  if you.branch() == "Temple" then
    -- Search again after explore
    if is_explore_done_msg(text) then search_altars() end
  end
end

-- Gauntlet functions
local function search_gauntlet()
  local cmd_key = BRC.get.command_key("CMD_SEARCH_STASHES") or BRC.util.cntl("f")
  crawl.sendkeys({ cmd_key, GAUNTLET_SEARCH_STRING, "\r" })
end

local function ready_gauntlet_macro()
  if you.branch() == "Gauntlet" and not rr_autosearched_gauntlet then
    search_gauntlet()
    rr_autosearched_gauntlet = true
  end
end

local function c_message_gauntlet(text, _)
  -- Search again after explore
  if you.branch() == "Gauntlet" then
    if is_explore_done_msg(text) then search_gauntlet() end
  end
end

-- Portal exit functions
local function ready_ignore_portals()
  if stop_on_portals and util.contains(BRC.PORTAL_NAMES, you.branch()) then
    stop_on_portals = false
    BRC.set.explore_stop("portals", false)
  elseif not stop_on_portals and not util.contains(BRC.PORTAL_NAMES, you.branch()) then
    stop_on_portals = true
    BRC.set.explore_stop("portals", true)
  end
end

-- After shaft functions
local function c_message_after_shaft(text, channel)
  if channel ~= "plain" or rr_shaft_location then return end
  if text:contains("ou fall into a shaft") or text:contains("ou are sucked into a shaft") then
    rr_shaft_location = you.where()
  end
end

local function ready_after_shaft()
  if you.where() == rr_shaft_location then rr_shaft_location = nil end
end

---- Hook functions ----
function f_runrest_features.init()
  stop_on_altars = true
  stop_on_portals = true
  stop_on_stairs = false
  if you.turns() == 0 and you.class() == "Delver" then rr_shaft_location = "D:1" end
end

function f_runrest_features.c_message(text, _)
  if Config.temple_search then c_message_temple(text) end
  if Config.gauntlet_search then c_message_gauntlet(text) end
  if Config.after_shaft then c_message_after_shaft(text) end
end

function f_runrest_features.ready()
  if Config.ignore_altars then ready_ignore_altars() end
  if Config.ignore_portal_exits then ready_ignore_portals() end
  if Config.temple_search then ready_temple_macro() end
  if Config.gauntlet_search then ready_gauntlet_macro() end
  if Config.after_shaft then ready_after_shaft() end
  set_stairs_stop_state()
end

}
############################### End lua/features/runrest-features.lua ###############################
##########################################################################################

################################### Begin lua/features/safe-consumables.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: safe-consumables
Description: Automatically manages !q and !r inscriptions. An upgrade to using autoinscribe.
Author: buehler
Dependencies: core/util.lua
--]]

f_safe_consumables = {}
f_safe_consumables.BRC_FEATURE_NAME = "safe-consumables"

---- Local constants ----
local NO_INSCRIPTION_NEEDED = {
  "acquirement", "amnesia", "blinking", "brand weapon", "enchant armour", "enchant weapon",
  "identify", "immolation", "noise", "vulnerability", "attraction", "lignification", "mutation",
} -- NO_INSCRIPTION_NEEDED (do not remove this comment)

---- Local functions ----
local function inscription_needed(class, st)
  if util.contains(NO_INSCRIPTION_NEEDED, st) then return false end
  if class == "scroll" then
    if st == "poison" then return you.res_poison() > 0 end
    if st == "torment" then return you.torment_immune() end
  end
  return true
end

---- Hook functions ----
function f_safe_consumables.ready()
  -- Add / Remove inscriptions as appropriate
  for _, inv in ipairs(items.inventory()) do
    local inv_class = inv.class(true)
    if inv_class == "scroll" then
      if inscription_needed(inv_class, inv.subtype()) then
        if not inv.inscription:contains("!r") then inv.inscribe("!r") end
      elseif inv.inscription:contains("!r") then
        inv.inscribe(inv.inscription:gsub("%!r", ""), false)
      end
    elseif inv_class == "potion" then
      if inscription_needed(inv_class, inv.subtype()) then
        if not inv.inscription:contains("!q") then inv.inscribe("!q") end
      elseif inv.inscription:contains("!q") then
        inv.inscribe(inv.inscription:gsub("%!q", ""), false)
      end
    end
  end
end

}
############################### End lua/features/safe-consumables.lua ###############################
##########################################################################################

################################### Begin lua/features/safe-stairs.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: safe-stairs
Description: Prevent accidental stairs use and warn for Vaults:5 entry
Author: buehler, rypofalem (V5 warning idea)
Dependencies: core/data.lua, core/util.lua
--]]

f_safe_stairs = {}
f_safe_stairs.BRC_FEATURE_NAME = "safe-stairs"
f_safe_stairs.Config = {
  warn_backtracking = true, -- Warn if immediately taking stairs twice in a row
  warn_v5 = true, -- Prompt before entering Vaults:5
} -- f_safe_stairs.Config (do not remove this comment)

---- Persistent variables ----
ss_prev_location = BRC.Data.persist("ss_prev_location", you.where())
ss_v5_warned = BRC.Data.persist("ss_v5_warned", false)

---- Local config alias ----
local Config = f_safe_stairs.Config

---- Local variables ----
local ss_cur_location

---- Local functions ----
local function check_new_location(cmd)
  local feature = view.feature_at(0, 0)

  if Config.warn_backtracking and ss_prev_location ~= ss_cur_location then
    if
      cmd == "CMD_GO_DOWNSTAIRS" and (feature:contains("down") or feature:contains("shaft"))
      or cmd == "CMD_GO_UPSTAIRS" and feature:contains("up")
    then
      if not BRC.mpr.yesno("Really go right back?") then return BRC.mpr.okay() end
    end
  end

  if
    Config.warn_v5
    and not ss_v5_warned
    and ss_cur_location == "Vaults:4"
    and cmd == "CMD_GO_DOWNSTAIRS"
    and (feature:contains("down") or feature:contains("shaft"))
  then
    if not BRC.mpr.yesno("Really go to Vaults:5?") then return BRC.mpr.okay() end
    ss_v5_warned = true
  end

  BRC.util.do_cmd(cmd)
end

---- Macro functions ----
function macro_brc_downstairs()
  if BRC.active and not f_safe_stairs.Config.disabled then
    check_new_location("CMD_GO_DOWNSTAIRS")
  else
    BRC.util.do_cmd("CMD_GO_DOWNSTAIRS")
  end
end

function macro_brc_upstairs()
  if BRC.active and not f_safe_stairs.Config.disabled then
    check_new_location("CMD_GO_UPSTAIRS")
  else
    BRC.util.do_cmd("CMD_GO_UPSTAIRS")
  end
end

---- Hook functions ----
function f_safe_stairs.init()
  ss_cur_location = you.where()

  BRC.set.macro(BRC.get.command_key("CMD_GO_DOWNSTAIRS") or ">", "macro_brc_downstairs")
  BRC.set.macro(BRC.get.command_key("CMD_GO_UPSTAIRS") or "<", "macro_brc_upstairs")
end

function f_safe_stairs.ready()
  ss_prev_location = ss_cur_location
  ss_cur_location = you.where()
end

}
############################### End lua/features/safe-stairs.lua ###############################
##########################################################################################

################################### Begin lua/features/startup.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: startup
Description: Handles startup features like skill menu display and auto-setting skill targets
Author: rwbarton, buehler
Dependencies: core/constants.lua, core/util.lua
--]]

f_startup = {}
f_startup.BRC_FEATURE_NAME = "startup"
f_startup.Config = {
  show_skills_menu = false, -- Show skills menu on startup
  set_all_targets = true, -- Set all targets, even if only focusing one
  focus_one_skill = true, -- Focus one skill at a time, even if setting all targets
  auto_set_skill_targets = {
    { "Stealth", 2.0 }, -- First, focus stealth to 2.0
    { "Fighting", 2.0 }, -- If already have stealth, focus fighting to 2.0
  },

  -- For non-spellcasters, add preferred weapon type as 3rd skill target
  init = [[
    if you.skill("Spellcasting") == 0 then
      local t = f_startup.Config.auto_set_skill_targets
      t[#t + 1] = { BRC.get.preferred_weapon_type(), 8.0 }
    end
  ]],
} -- f_startup.Config (do not remove this comment)

---- Local config alias ----
local Config = f_startup.Config

---- Hook functions ----
function f_startup.ready()
  if you.turns() == 0 then
    -- Disable all skills by default
    for _, s in ipairs(BRC.TRAINING_SKILLS) do
      if s ~= Config.auto_set_skill_targets[1][1] then you.train_skill(s, 0) end
    end

    -- Auto-set skill targets
    if Config.auto_set_skill_targets and you.race() ~= "Gnoll" then
      for i, skill_target in ipairs(Config.auto_set_skill_targets) do
        local skill, target = unpack(skill_target)
        if you.skill(skill) < target then
          you.set_training_target(skill, target)
          if i == 1 or not Config.focus_one_skill then you.train_skill(skill, 1) end
          if not Config.set_all_targets then break end
        end
      end
    end
  end

  -- Show skills menu: Disable for non-Wanderer Gnolls
  if Config.show_skills_menu and (you.race() ~= "Gnoll" or you.class() == "Wanderer") then
    BRC.util.do_cmd("CMD_DISPLAY_SKILLS")
  end
end

}
############################### End lua/features/startup.lua ###############################
##########################################################################################

################################### Begin lua/features/weapon-slots.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: weapon-slots
Description: Automatically keeps weapons in slots a/b/w. Prioritizes slots by weapon type + skill.
Author: buehler
Dependencies: core/util.lua
--]]

f_weapon_slots = {}
f_weapon_slots.BRC_FEATURE_NAME = "weapon-slots"

---- Local variables ----
local do_cleanup_weapon_slots
local slots_changed
local priorities_ab
local priorities_w

---- Local functions ----
local function get_first_empty_slot()
  -- First try to avoid same slot as a consumable, then find first empty equipment slot
  local used_slots = {}
  for _, inv in ipairs(items.inventory()) do
    used_slots[inv.slot] = true
  end

  for slot = 0, 51 do
    if not used_slots[slot] then return slot end
  end

  for slot = 0, 51 do
    if not items.inslot(slot) then return slot end
  end
end

local function get_priority_ab(it)
  if not it.is_weapon then return -1 end
  if it.equipped then return 1 end

  if BRC.is.magic_staff(it) then return 3 end
  if it.is_ranged then return (you.skill("Ranged Weapons") >= 4) and 2 or 5 end
  if BRC.is.polearm(it) then return (you.skill("Polearms") >= 4) and 2 or 4 end
  return 2
end

local function get_priority_w(it)
  if not it.is_weapon then return -1 end
  if it.is_ranged then return 1 end
  if BRC.is.polearm(it) then return 2 end
  if BRC.is.magic_staff(it) then return 3 end
  return 4
end

local function generate_priorities()
  priorities_ab = { -1, -1, -1, -1, -1 }
  priorities_w = { -1, -1, -1, -1 }

  for _, inv in ipairs(items.inventory()) do
    local p = get_priority_w(inv)
    if p > 0 then
      if priorities_w[p] == -1 then
        priorities_w[p] = inv.slot
      else
        priorities_w[p + 1] = inv.slot
      end
    end

    p = get_priority_ab(inv)
    if p > 0 then
      if priorities_ab[p] == -1 then
        priorities_ab[p] = inv.slot
      else
        priorities_ab[p + 1] = inv.slot
      end
    end
  end
end

local function cleanup_ab(slot)
  local inv = items.inslot(slot)
  if inv and inv.is_weapon then return end

  for p = 1, #priorities_ab do
    if priorities_ab[p] > slot then -- Not from earlier slot
      items.swap_slots(priorities_ab[p], slot)
      slots_changed = true
      priorities_ab[p] = -1
      return
    end
  end
end

local function cleanup_w()
  local slot_w = items.letter_to_index("w")
  local inv = items.inslot(slot_w)
  if inv and inv.is_weapon then return end

  for p = 1, #priorities_w do
    if priorities_w[p] > 1 then -- Not from slots a or b
      items.swap_slots(priorities_w[p], slot_w)
      slots_changed = true
      return
    end
  end
end

local function cleanup_weapon_slots()
  generate_priorities()
  cleanup_ab(0)
  cleanup_ab(1)
  cleanup_w()
end

---- Hook functions ----
function f_weapon_slots.init()
  do_cleanup_weapon_slots = false
  slots_changed = false
  priorities_ab = nil
  priorities_w = nil
end

function f_weapon_slots.c_assign_invletter(it)
  if not it.is_weapon then return end

  for _, s in ipairs({ "a", "b", "w" }) do
    local slot = items.letter_to_index(s)
    local inv = items.inslot(slot)
    if not (inv and inv.is_weapon) then
      items.swap_slots(slot, get_first_empty_slot())
      slots_changed = true
      return slot
    end
  end
end

function f_weapon_slots.c_message(text, channel)
  do_cleanup_weapon_slots = channel == "plain" and text:contains("ou drop ")
end

function f_weapon_slots.ready()
  if do_cleanup_weapon_slots then
    cleanup_weapon_slots()
    do_cleanup_weapon_slots = false
  end
  if slots_changed then
    BRC.mpr.darkgrey("Weapon slots updated (ab+w).")
    crawl.redraw_screen()
    slots_changed = false
  end
end

}
############################### End lua/features/weapon-slots.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##

### Pickup and alert ###

################################### Begin lua/features/pickup-alert/pa-config.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-config
Description: Configuration for the pickup-alert system
Author: buehler
Dependencies: core/constants.lua
--]]

f_pickup_alert = f_pickup_alert or {}
f_pickup_alert.Config = {}
f_pickup_alert.Config.Pickup = {
  armour = true,
  weapons = true,
  weapons_pure_upgrades_only = true, -- Only pick up better versions of same exact weapon
  staves = true,
} -- f_pickup_alert.Config.Pickup (do not remove this comment)

f_pickup_alert.Config.Alert = {
  armour_sensitivity = 1.0, -- Adjust all armour alerts; 0 to disable all (typical range 0.5-2.0)
  weapon_sensitivity = 1.0, -- Adjust all weapon alerts; 0 to disable all (typical range 0.5-2.0)
  orbs = true,
  staff_resists = true,
  talismans = true,

  -- Only alert a plain talisman if its min_skill <= Shapeshifting + talisman_lvl_diff
  talisman_lvl_diff = you.class() == "Shapeshifter" and 27 or 6,

  -- Each usable item is alerted once.
  one_time = {
    "wand of digging", "buckler", "kite shield", "tower shield", "crystal plate armour",
    "gold dragon scales", "pearl dragon scales", "storm dragon scales", "shadow dragon scales",
    "quick blade", "demon blade", "eudemon blade", "double sword", "triple sword",
    "broad axe", "executioner's axe",
    "demon whip", "eveningstar", "giant spiked club", "morningstar", "sacred scourge",
    "lajatang", "bardiche", "demon trident", "partisan", "trishula",
    "hand cannon", "triple crossbow",
  },

  -- Only do one-time alerts if your skill >= this value, in weap_school/armour/shield
  OTA_require_skill = { weapon = 2, armour = 2.5, shield = 0 },

  -- Which alerts generate a force_more
  More = {
    early_weap = false, -- Good weapons found early
    upgrade_weap = false, -- Better DPS / weapon_score
    weap_ego = false, -- New or diff egos
    body_armour = false,
    shields = true,
    aux_armour = false,
    armour_ego = true, -- New or diff egos
    high_score_weap = false, -- Highest damage found
    high_score_armour = true, -- Highest AC found
    one_time_alerts = true,
    artefact = false, -- Any artefact
    trained_artefacts = true, -- Artefacts where you have corresponding skill > 0
    orbs = false,
    talismans = you.class() == "Shapeshifter", -- True for shapeshifter, false for everyone else
    staff_resists = false,
  },
} -- f_pickup_alert.Config.Alert (do not remove this comment)

---- Heuristics for tuning the pickup/alert system. Advanced behavior customization.
f_pickup_alert.Config.Tuning = {}

--[[
  f_pickup_alert.Config.Tuning.Armour: Magic numbers for the armour pickup/alert system.
  For armour with different encumbrance, alert when ratio of gain/loss (AC|EV) is > value
  Lower values mean more alerts. gain/diff/same/lose refers to egos.
  min_gain/max_loss block alerts for new egos, when AC or EV delta is outside limits
  ignore_small: if abs(AC+EV) <= this, ignore ratios and alert any gain/diff ego
--]]
f_pickup_alert.Config.Tuning.Armour = {
  Lighter = {
    gain_ego = 0.6,
    new_ego = 0.7,
    diff_ego = 0.9,
    same_ego = 1.2,
    lost_ego = 2.0,
    min_gain = 3.0,
    max_loss = 4.0,
    ignore_small = 3.5,
  },
  Heavier = {
    gain_ego = 0.4,
    new_ego = 0.5,
    diff_ego = 0.6,
    same_ego = 0.7,
    lost_ego = 2.0,
    min_gain = 3.0,
    max_loss = 8.0,
    ignore_small = 5,
  },
  encumb_penalty_weight = 0.7, -- [0-2.0] Penalty to heavy armour when training magic/ranged
  early_xl = 6, -- Alert all usable runed body armour if XL <= early_xl
  diff_body_ego_is_good = false, -- More alerts for diff_ego in body armour (skips min_gain check)
} -- f_pickup_alert.Config.Tuning.Armour (do not remove this comment)

--[[
  f_pickup_alert.Config.Tuning.Weap: Magic numbers for the weapon pickup/alert system, namely:
    1. Cutoffs for pickup/alert weapons (when DPS ratio exceeds a value)
    2. Cutoffs for when alerts are active (XL, skill_level)
  Pickup/alert system will try to upgrade ANY weapon in your inventory.
  "DPS ratio" is (new_weapon_score / inventory_weapon_score). Score considers DPS/brand/accuracy.
--]]
f_pickup_alert.Config.Tuning.Weap = {}
f_pickup_alert.Config.Tuning.Weap.Pickup = {
  add_ego = 1.0, -- Pickup weapon that gains a brand if DPS ratio > add_ego
  same_type_melee = 1.2, -- Pickup melee weap of same school if DPS ratio > same_type_melee
  same_type_ranged = 1.1, -- Pickup ranged weap if DPS ratio > same_type_ranged
  accuracy_weight = 0.25, -- Treat +1 Accuracy as +accuracy_weight DPS
} -- f_pickup_alert.Config.Tuning.Weap.Pickup (do not remove this comment)

f_pickup_alert.Config.Tuning.Weap.Alert = {
  -- Alerts for weapons not requiring an extra hand
  pure_dps = 1.0, -- Alert if DPS ratio > pure_dps
  gain_ego = 0.8, -- Gaining ego; Alert if DPS ratio > gain_ego
  new_ego = 0.8, -- Get ego not in inventory; Alert if DPS ratio > new_ego
  low_skill_penalty_damping = 8, -- [0-20] Reduces penalty to weapons of lower-trained schools

  -- Alerts for 2-handed weapons, when carrying 1-handed
  AddHand = {
    ignore_sh_lvl = 4.0, -- Treat offhand as empty if shield_skill < ignore_sh_lvl
    add_ego_lose_sh = 0.8, -- Alert 1h -> 2h (using shield) if DPS ratio > add_ego_lose_sh
    not_using = 1.0, --  Alert 1h -> 2h (not using 2nd hand) if DPS ratio > not_using
  },

  -- Alerts for good early weapons of all types
  Early = {
    xl = 7, -- Alert early weapons if XL <= xl
    skill = { factor = 1.5, offset = 2.0 }, -- Ignore weapons with skill_diff > XL*factor+offset
    branded_min_plus = 4, -- Alert branded weapons with plus >= branded_min_plus
  },

  -- Alerts for particularly strong ranged weapons
  EarlyRanged = {
    xl = 14, -- Alert strong ranged weapons if XL <= xl
    min_plus = 7, -- Alert ranged weapons with plus >= min_plus
    branded_min_plus = 4, -- Alert branded ranged weapons with plus >= branded_min_plus
    max_shields = 8.0, -- Alert 2h ranged, despite a wearing shield, if shield_skill <= max_shields
  },
} -- f_pickup_alert.Config.Tuning.Weap.Alert (do not remove this comment)

f_pickup_alert.Config.AlertColor = {
  weapon = { desc = BRC.COL.magenta, item = BRC.COL.yellow, stats = BRC.COL.lightgrey },
  body_arm = { desc = BRC.COL.lightblue, item = BRC.COL.lightcyan, stats = BRC.COL.lightgrey },
  aux_arm = { desc = BRC.COL.lightblue, item = BRC.COL.yellow },
  orb = { desc = BRC.COL.green, item = BRC.COL.lightgreen },
  talisman = { desc = BRC.COL.green, item = BRC.COL.lightgreen },
  misc = { desc = BRC.COL.brown, item = BRC.COL.white },
} -- f_pickup_alert.Config.AlertColor (do not remove this comment)

f_pickup_alert.Config.Emoji = not BRC.Config.emojis and {}
  or {
    RARE_ITEM = "💎",
    ARTEFACT = "💠",
    ORB = "🔮",
    TALISMAN = "🧬",
    STAFF_RES = "🔥",

    WEAPON = "⚔️",
    RANGED = "🏹",
    POLEARM = "🔱",
    TWO_HAND = "✋🤚",

    EGO = "✨",
    ACCURACY = "🎯",
    STRONGER = "💪",
    STRONGEST = "💪💪",
    LIGHTER = "⏬",
    HEAVIER = "⏫",
  } -- f_pickup_alert.Config.Emoji (do not remove this comment)

}
############################### End lua/features/pickup-alert/pa-config.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-main.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert
Description: Comprehensive pickup and alert system for weapons, armour, and miscellaneous items
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/data.lua, core/util.lua,
  pa-armour.lua, pa-config.lua, pa-data.lua, pa-misc.lua, pa-weapons.lua
--]]

f_pickup_alert = f_pickup_alert or {}
f_pickup_alert.BRC_FEATURE_NAME = "pickup-alert"

---- Local config alias ----
local Config = f_pickup_alert.Config

---- Local variables ----
local pause_pa_system
local hold_alerts_for_next_turn

---- Local functions ----
local function has_configured_force_more(it)
  if it.artefact then
    if Config.Alert.More.artefact then return true end
    if Config.Alert.More.trained_artefacts then
      -- Accept artefacts with any relevant training, or no training required
      local s = BRC.get.skill_with(it)
      if s == nil or s > 0 then return true end
    end
  end

  return Config.Alert.More.armour_ego and BRC.is.armour(it) and BRC.get.ego(it)
end

local function track_unique_egos(it)
  local ego = BRC.get.ego(it)
  if
    ego
    and not util.contains(pa_egos_alerted, ego)
    and not (it.artefact and BRC.is.risky_item(it))
  then
    pa_egos_alerted[#pa_egos_alerted+1] = ego
  end
end

---- Public API ----
function f_pickup_alert.pause_alerts()
  hold_alerts_for_next_turn = true
end

function f_pickup_alert.do_alert(it, alert_type, emoji, force_more)
  local item_name = f_pa_data.get_keyname(it, true)
  local alert_col

  if it.is_weapon then
    f_pa_data.update_high_scores(it)
    alert_col = Config.AlertColor.weapon
    local weapon_info = string.format(" (%s)", BRC.get.weapon_stats(it))
    item_name = item_name .. BRC.text.color(Config.AlertColor.weapon.stats, weapon_info)
  elseif BRC.is.orb(it) then
    alert_col = Config.AlertColor.orb
  elseif BRC.is.talisman(it) then
    alert_col = Config.AlertColor.talisman
  elseif BRC.is.armour(it) then
    if BRC.is.body_armour(it) then
      f_pa_data.update_high_scores(it)
      alert_col = Config.AlertColor.body_arm
      local ac, ev = BRC.get.armour_stats(it)
      local armour_info = string.format(" {%s, %s}", ac, ev)
      item_name = item_name .. BRC.text.color(Config.AlertColor.body_arm.stats, armour_info)
    else
      alert_col = Config.AlertColor.aux_arm
    end

    track_unique_egos(it)
  else
    alert_col = Config.AlertColor.misc
  end

  local tokens = {}
  tokens[1] = emoji and emoji or BRC.text.cyan("----")
  tokens[#tokens + 1] = BRC.text.color(alert_col.desc, string.format(" %s:", alert_type))
  tokens[#tokens + 1] = BRC.text.color(alert_col.item, string.format(" %s ", item_name))
  tokens[#tokens + 1] = tokens[1]
  BRC.mpr.que_optmore(force_more or has_configured_force_more(it), table.concat(tokens))

  f_pa_data.insert(pa_recent_alerts, it)
  f_pa_data.insert(pa_items_alerted, it)

  if not hold_alerts_for_next_turn then you.stop_activity() end

  if util.exists(you.floor_items(), function(fl) return fl.name() == it.name() end) then
    BRC.set_pickup_hotkey(it.name(), true)
  elseif you.feel_safe() then
    BRC.set_waypoint_hotkey(it.name())
  end

  return true
end

---- Hook functions ----
function f_pickup_alert.init()
  pause_pa_system = false
  hold_alerts_for_next_turn = false

  BRC.log.debug("Initialize pickup-alert submodules...")
  f_pa_data.init()
  BRC.log.debug("  pa-data loaded")

  if f_pa_armour then
    if f_pa_armour.init then f_pa_armour.init() end
    BRC.log.debug("  pa-armour loaded")
  end

  if f_pa_weapons then
    if f_pa_weapons.init then f_pa_weapons.init() end
    BRC.log.debug("  pa-weapons loaded")
  end

  if f_pa_misc then
    if f_pa_misc.init then f_pa_misc.init() end
    BRC.log.debug("  pa-misc loaded")
  end
end

function f_pickup_alert.autopickup(it, _)
  if
    not BRC.active
    or pause_pa_system
    or you.have_orb()
    or not it.is_identified and (it.branded or it.artefact or BRC.is.magic_staff(it))
  then
    return
  end

  local unworn_aux_item = nil -- Track carried aux armour for mutation scenarios
  if it.is_useless then
    -- Allow alerts for useless aux armour, iff you're carrying one (implies a temporary mutation)
    if not BRC.is.aux_armour(it) then return end
    local st = it.subtype()
    for _, inv in ipairs(items.inventory()) do
      if inv.subtype() == st then
        unworn_aux_item = inv
        break
      end
    end
    if not unworn_aux_item then return end
  else
    -- Pickup main
    if f_pa_armour and Config.Pickup.armour and BRC.is.armour(it) then
      if f_pa_armour.pickup_armour(it) then return true end
    elseif f_pa_misc and Config.Pickup.staves and BRC.is.magic_staff(it) then
      if f_pa_misc.pickup_staff(it) then return true end
    elseif f_pa_weapons and Config.Pickup.weapons and it.is_weapon then
      if f_pa_weapons.pickup_weapon(it) then return true end
    elseif f_pa_misc and f_pa_misc.is_unneeded_ring(it) then
      return false
    end
  end

  -- Item not picked up - check if it should trigger alerts
  if f_pa_data.find(pa_items_alerted, it) then return end

  if f_pa_misc and Config.Alert.one_time and #Config.Alert.one_time > 0 then
    if f_pa_misc.alert_OTA(it) then return end
  end

  if f_pa_misc and Config.Alert.staff_resists and BRC.is.magic_staff(it) then
    if f_pa_misc.alert_staff(it) then return end
  elseif f_pa_misc and Config.Alert.orbs and BRC.is.orb(it) then
    if f_pa_misc.alert_orb(it) then return end
  elseif f_pa_misc and Config.Alert.talismans and BRC.is.talisman(it) then
    if f_pa_misc.alert_talisman(it) then return end
  elseif f_pa_armour and Config.Alert.armour_sensitivity > 0 and BRC.is.armour(it) then
    if f_pa_armour.alert_armour(it, unworn_aux_item) then return end
  elseif f_pa_weapons and Config.Alert.weapon_sensitivity > 0 and it.is_weapon then
    if f_pa_weapons.alert_weapon(it) then return end
  end
end

function f_pickup_alert.c_assign_invletter(it)
  f_pa_misc.alert_OTA(it)
  f_pa_data.remove(pa_recent_alerts, it)

  -- Re-enable the alert, iff we are able to use another one
  if BRC.get.num_equip_slots(it) > 1 then f_pa_data.remove(pa_items_alerted, it) end

  -- Ensure we always stop for these autopickup types
  if it.is_weapon or BRC.is.armour(it) then
    f_pa_data.update_high_scores(it)
    you.stop_activity()
  end
end

function f_pickup_alert.c_message(text, channel)
  -- Avoid firing alerts when changing armour/weapons
  if channel == "multiturn" then
    if not pause_pa_system and text:contains("ou start ") then pause_pa_system = true end
  elseif channel == "plain" then
    if pause_pa_system and (text:contains("ou stop ") or text:contains("ou finish ")) then
      pause_pa_system = false
    elseif text:contains("one exploring") or text:contains("artly explored") then
      local tokens = { "Recent alerts:" }
      for _, v in ipairs(pa_recent_alerts) do
        tokens[#tokens + 1] = string.format("\n  %s", v)
      end
      if #tokens > 1 then BRC.mpr.que(table.concat(tokens), BRC.COL.magenta) end
      pa_recent_alerts = {}
    end
  end
end

function f_pickup_alert.ready()
  hold_alerts_for_next_turn = false
  if pause_pa_system then return end
  f_pa_weapons.ready()
  f_pa_data.update_high_scores(items.equipped_at("armour"))
end

}
############################### End lua/features/pickup-alert/pa-main.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-data.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-data
Description: Data management and persistent storage for the pickup-alert system
Author: buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua, pa-config.lua
--]]

f_pa_data = {}

---- Persistent variables ----
pa_items_alerted = BRC.Data.persist("pa_items_alerted", {})
pa_recent_alerts = BRC.Data.persist("pa_recent_alerts", {})
pa_OTA_items = BRC.Data.persist("pa_OTA_items", f_pickup_alert.Config.Alert.one_time)
pa_high_score = BRC.Data.persist("pa_high_score", { ac = 0, weapon = 0, plain_dmg = 0 })
pa_egos_alerted = BRC.Data.persist("pa_egos_alerted", {})

---- Local functions ----
local function get_pa_keys(it, use_plain_name)
  if it.class(true) == "bauble" then
    return it.name("qual"):gsub('"', ""), 0
  elseif BRC.is.talisman(it) or BRC.is.orb(it) then
    return it.name():gsub('"', ""), 0
  elseif BRC.is.magic_staff(it) then
    return it.name("base"):gsub('"', ""), 0
  else
    local name = it.name(use_plain_name and "plain" or "base"):gsub('"', "")
    local value = tonumber(name:sub(1, 3))
    if not value then return name, 0 end
    return util.trim(name:sub(4)), value
  end
end

---- Public API ----
-- Return name of first entry found in item name, or nil if not found
function f_pa_data.find(table_ref, it)
  if table_ref == pa_OTA_items then
    local qualname = it.name("qual")
    for _, v in ipairs(pa_OTA_items) do
      if v and qualname:find(v) then return v end
    end
  else
    local name, value = get_pa_keys(it)
    if table_ref[name] ~= nil and tonumber(table_ref[name]) >= value then return name end
  end
end

function f_pa_data.insert(table_ref, it)
  local is_armour = BRC.is.armour(it, true)
  if not (it.is_weapon or is_armour or BRC.is.talisman(it)) then return end

  if table_ref == pa_recent_alerts then
    pa_recent_alerts[#pa_recent_alerts + 1] = f_pa_data.get_keyname(it)
  else
    local name, value = get_pa_keys(it)
    local cur_val = tonumber(table_ref[name])
    if not cur_val or value > cur_val then table_ref[name] = value end

    -- For armour with good brand, also add the unbranded version to the table
    if is_armour and it.branded and not (it.artefact or BRC.is.risky_item(it)) then
      name = it.name("qual")
      cur_val = tonumber(table_ref[name])
      if not cur_val or value > cur_val then table_ref[name] = value end
    end
  end
end

function f_pa_data.remove(table_ref, it)
  if table_ref == pa_OTA_items then
    repeat
      local item_name = f_pa_data.find(pa_OTA_items, it)
      if item_name == nil then return end
      util.remove(pa_OTA_items, item_name)
    until item_name == nil
  elseif table_ref == pa_recent_alerts then
    util.remove(pa_recent_alerts, f_pa_data.get_keyname(it))
  else
    local name, _ = get_pa_keys(it)
    table_ref[name] = nil
  end
end

-- Get name with plus included and quotes removed; stored in pa_recent_alerts table
function f_pa_data.get_keyname(it, use_plain_name)
  local name, value = get_pa_keys(it, use_plain_name)
  if not (BRC.is.armour(it) or it.is_weapon) then return name end
  if value >= 0 then value = string.format("+%s", value) end
  return string.format("%s %s", value, name)
end

-- Returns a string of the high score type if item sets a new high score, else nil
function f_pa_data.update_high_scores(it)
  if not it then return end
  local ret_val = nil

  if BRC.is.armour(it) then
    local ac = BRC.get.armour_ac(it)
    if ac > pa_high_score.ac then
      pa_high_score.ac = ac
      if not ret_val then ret_val = "Highest AC" end
    end
  elseif it.is_weapon then
    -- Don't alert for unusable weapons
    if BRC.get.hands(it) == 2 and not BRC.you.free_offhand() then return end

    local dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.branded)
    if dmg > pa_high_score.weapon then
      pa_high_score.weapon = dmg
      if not ret_val then ret_val = "Highest damage" end
    end

    dmg = BRC.get.weap_damage(it, BRC.DMG_TYPE.plain)
    if dmg > pa_high_score.plain_dmg then
      pa_high_score.plain_dmg = dmg
      if not ret_val then ret_val = "Highest plain damage" end
    end
  end

  return ret_val
end

---- Hook functions ----
function f_pa_data.init()
  -- Update alerts & tables for starting items
  for _, inv in ipairs(items.inventory()) do
    f_pa_data.remove(pa_OTA_items, inv)
  end
end

}
############################### End lua/features/pickup-alert/pa-data.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-armour.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-armour
Description: Armour pickup logic and alert system for the pickup-alert system
Author: Original Equipment autopickup by Medar, gammafunk, and various others. Extended by buehler.
Dependencies: core/config.lua, core/constants.lua, core/util.lua,
  pa-config.lua, pa-data.lua, pa-main.lua
--]]

f_pa_armour = {}

---- Local config aliases ----
local Heur = f_pickup_alert.Config.Tuning.Armour
local Emoji = f_pickup_alert.Config.Emoji
local Alert = f_pickup_alert.Config.Alert
local More = f_pickup_alert.Config.Alert.More

---- Local constants / configuration ----
local ENCUMB_ARMOUR_DIVISOR = 2 -- Encumbrance penalty is offset by (Armour / ENCUMB_ARMOUR_DIVISOR)
local SAME = "same_ego"
local LOST = "lost_ego"
local GAIN = "gain_ego"
local NEW = "new_ego"
local DIFF = "diff_ego"
local HEAVIER = "Heavier"
local LIGHTER = "Lighter"

local ARMOUR_ALERT = {
  artefact = { msg = "Artefact armour", emoji = Emoji.ARTEFACT },
  [GAIN] = { msg = "Gain ego", emoji = Emoji.EGO },
  [NEW] = { msg = "New ego", emoji = Emoji.EGO },
  [DIFF] = { msg = "Diff ego", emoji = Emoji.EGO },
  [LIGHTER] = {
    [GAIN] = { msg = "Gain ego (Lighter armour)", emoji = Emoji.EGO },
    [NEW] = { msg = "New ego (Lighter armour)", emoji = Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Lighter armour)", emoji = Emoji.EGO },
    [SAME] = { msg = "Lighter armour", emoji = Emoji.LIGHTER },
    [LOST] = { msg = "Lighter armour (Lost ego)", emoji = Emoji.LIGHTER },
  },
  [HEAVIER] = {
    [GAIN] = { msg = "Gain ego (Heavier armour)", emoji = Emoji.EGO },
    [NEW] = { msg = "New ego (Heavier armour)", emoji = Emoji.EGO },
    [DIFF] = { msg = "Diff ego (Heavier armour)", emoji = Emoji.EGO },
    [SAME] = { msg = "Heavier Armour", emoji = Emoji.HEAVIER },
    [LOST] = { msg = "Heavier Armour (Lost ego)", emoji = Emoji.HEAVIER },
  },
} -- ARMOUR_ALERT (do not remove this comment)

---- Local functions ----
local function aux_slot_is_impaired(it)
  local st = it.subtype()
  -- Skip boots/gloves/helmet if wearing Lear's hauberk
  local worn = items.equipped_at("armour")
  if worn and worn.name("qual") == "Lear's hauberk" and st ~= "cloak" then return true end

  -- Mutation interference
  if st == "gloves" then
    return BRC.get.mut("demonic touch") >= 3 and not BRC.you.free_offhand()
        or BRC.get.mut("claws") > 0 and not items.equipped_at("weapon")
  elseif st == "boots" then
    return BRC.get.mut("hooves") > 0
        or BRC.get.mut("talons") > 0
  elseif it.name("base"):contains("helmet") then
    return BRC.get.mut("horns") > 0
        or BRC.get.mut("beak") > 0
        or BRC.get.mut("antennae") > 0
  end

  return false
end

local function get_adjusted_ev_delta(encumb_delta, ev_delta)
  local encumb_skills = you.skill("Spellcasting")
    + you.skill("Ranged Weapons")
    - you.skill("Armour") / ENCUMB_ARMOUR_DIVISOR
  local encumb_impact = encumb_skills / you.xl()
  encumb_impact = math.max(0, math.min(1, encumb_impact)) -- Clamp to 0-1

  -- Subtract weighted encumbrance penalty, to align with ev_delta (heavier is negative)
  return ev_delta - encumb_delta * encumb_impact * Heur.encumb_penalty_weight
end

local function get_ego_change_type(cur_ego, it_ego)
  if it_ego == cur_ego then
    return SAME
  elseif not it_ego then
    return LOST
  elseif not cur_ego then
    return GAIN
  elseif not util.contains(pa_egos_alerted, it_ego) then
    return NEW
  else
    return DIFF
  end
end

--- Decides if an ego change is good enough to skip the min_gain check.
--- For DIFF egos (neutral change), true for Shields/Aux, configurable for body armour
local function is_good_ego_change(ego_change, is_body_armour)
  if ego_change == DIFF then return not is_body_armour or Heur.diff_body_ego_is_good end
  return ego_change == GAIN or ego_change == NEW
end

local function send_armour_alert(it, t_alert)
  return f_pickup_alert.do_alert(it, t_alert.msg, t_alert.emoji, More.body_armour)
end

-- Local functions: Pickup
local function pickup_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end -- surely am naked for a reason

  -- No pickup if wearing an artefact
  if cur.artefact then return false end

  -- No pickup if adding encumbrance or losing AC
  local encumb_delta = it.encumbrance - cur.encumbrance
  if encumb_delta > 0 then return false end
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  if ac_delta < 0 then return false end

  -- Pickup: Pure upgrades
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if it_ego == cur_ego then return (ac_delta > 0 or encumb_delta < 0) end
  return not cur_ego and (ac_delta >= 0 or encumb_delta <= 0)
end

local function pickup_shield(it)
  -- Don't replace these
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end
  if cur.encumbrance ~= it.encumbrance then return false end
  if cur.artefact then return false end

  -- Pickup: artefact
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_plus = it.plus or 0
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  if it_ego == cur_ego then return it_plus > cur.plus end
  return not cur_ego and it_plus >= cur.plus
end

local function pickup_aux_armour(it)
  -- Pickup: Anything if the slot is empty, unless downside from mutation
  if aux_slot_is_impaired(it) then return false end
  local all_equipped, num_slots = BRC.get.equipped_at(it)
  if #all_equipped < num_slots then
    -- If we're carrying one (implying a blocking mutation), don't pickup another
    if num_slots == 1 then
      local ST = it.subtype()
      return not util.exists(items.inventory(), function(inv) return inv.subtype() == ST end)
    end
    return true
  end

  -- Pickup: artefact, unless slot(s) already full of artefact(s)
  for i, cur in ipairs(all_equipped) do
    if not cur.artefact then break end
    if i == num_slots then return false end
  end
  if it.artefact then return true end

  -- Pickup: Pure upgrades
  local it_ac = BRC.get.armour_ac(it)
  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local cur_ac = BRC.get.armour_ac(cur)
    local cur_ego = BRC.get.ego(cur)
    if it_ego == cur_ego then
      if it_ac > cur_ac then return true end
    elseif not cur_ego then
      if it_ac >= cur_ac then return true end
    end
  end
  return false
end

-- Local functions: Alerting
local function should_alert_body_armour(weight, gain, loss, ego_change)
  -- Check if armour stat trade-off meets configured ratio thresholds
  local meets_ratio = loss <= 0
    or (gain / loss > Heur[weight][ego_change] / Alert.armour_sensitivity)
  if not meets_ratio then return false end

  -- Additional ego-specific restrictions
  if ego_change == SAME or is_good_ego_change(ego_change, true) then
    return loss <= Heur[weight].max_loss * Alert.armour_sensitivity
  else
    return gain >= Heur[weight].min_gain / Alert.armour_sensitivity
  end
end

-- Alert when finding higher AC than previously seen, unless training spells/ranged and NOT armour
local function alert_highest_ac(it)
  if you.xl() > 12 then return false end
  local total_skill = you.skill("Spellcasting") + you.skill("Ranged Weapons")
  if total_skill > 0 and you.skill("Armour") == 0 then return false end

  if pa_high_score.ac == 0 then
    local worn = items.equipped_at("armour")
    if not worn then return false end
    pa_high_score.ac = BRC.get.armour_ac(worn)
  else
    local itAC = BRC.get.armour_ac(it)
    if itAC > pa_high_score.ac then
      pa_high_score.ac = itAC
      return f_pickup_alert.do_alert(it, "Highest AC", Emoji.STRONGEST, More.high_score_armour)
    end
  end

  return false
end

local function alert_body_armour(it)
  local cur = items.equipped_at("armour")
  if not cur then return false end

  -- Always alert artefacts once identified
  if it.artefact then return send_armour_alert(it, ARMOUR_ALERT.artefact) end

  -- Get changes to ego, AC, EV, encumbrance
  local it_ego = BRC.get.ego(it)
  local cur_ego = BRC.get.ego(cur)
  local ego_change = get_ego_change_type(cur_ego, it_ego)
  local ac_delta = BRC.get.armour_ac(it) - BRC.get.armour_ac(cur)
  local ev_delta = BRC.get.armour_ev(it) - BRC.get.armour_ev(cur)
  local encumb_delta = it.encumbrance - cur.encumbrance

  -- Alert new egos if same encumbrance, or small change to total (AC+EV)
  if is_good_ego_change(ego_change, true) then
    if encumb_delta == 0 then return send_armour_alert(it, ARMOUR_ALERT[ego_change]) end

    local weight = encumb_delta < 0 and LIGHTER or HEAVIER
    if math.abs(ac_delta + ev_delta) <= Heur[weight].ignore_small * Alert.armour_sensitivity then
      BRC.log.debug("small change: AC:" .. ac_delta .. ", EV:" .. ev_delta)
      return send_armour_alert(it, ARMOUR_ALERT[weight][ego_change])
    end
  end

  -- Check if lighter/heavier armour meets stat trade-off thresholds
  if encumb_delta < 0 then
    if should_alert_body_armour(LIGHTER, ev_delta, -ac_delta, ego_change) then
      BRC.log.debug("Lighter: AC:" .. ac_delta .. ", EV:" .. ev_delta .. ", " .. ego_change)
      return send_armour_alert(it, ARMOUR_ALERT[LIGHTER][ego_change])
    end
  elseif encumb_delta > 0 then
    local adj_ev_delta = get_adjusted_ev_delta(encumb_delta, ev_delta)
    if should_alert_body_armour(HEAVIER, ac_delta, -adj_ev_delta, ego_change) then
      BRC.log.debug("Heavier: AC:" .. ac_delta .. ", EV:" .. ev_delta .. ", " .. ego_change)
      return send_armour_alert(it, ARMOUR_ALERT[HEAVIER][ego_change])
    end
  end

  -- Check for record AC values or early-game ego armour
  if alert_highest_ac(it) then return true end
  if it_ego and you.xl() <= Heur.early_xl then
    return f_pickup_alert.do_alert(it, "Early armour", Emoji.EGO)
  end
end

local function alert_shield(it)
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact shield", Emoji.ARTEFACT, More.shields)
  end

  -- Don't alert shields if not wearing one (one_time_alerts fire for the first of each type)
  local cur = items.equipped_at("offhand")
  if not BRC.is.shield(cur) then return false end

  -- Alert: New ego, Gain SH
  local ego_change = get_ego_change_type(BRC.get.ego(cur), BRC.get.ego(it))
  if is_good_ego_change(ego_change, false) then
    local alert_msg = BRC.text.capitalize(ego_change):gsub("_", " ")
    return f_pickup_alert.do_alert(it, alert_msg, Emoji.EGO, More.shields)
  elseif BRC.get.shield_sh(it) > BRC.get.shield_sh(cur) then
    return f_pickup_alert.do_alert(it, "Higher SH", Emoji.STRONGER, More.shields)
  end
end

local function alert_aux_armour(it, unworn_inv_item)
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact aux armour", Emoji.ARTEFACT, More.aux_armour)
  end

  local all_equipped, num_slots = BRC.get.equipped_at(it)
  if #all_equipped < num_slots then
    if unworn_inv_item then
      all_equipped[#all_equipped + 1] = unworn_inv_item
    else
      -- Catch dangerous brands or items blocked by non-innate mutations
      return f_pickup_alert.do_alert(it, "Aux armour", BRC.EMOJI.EXCLAMATION, More.aux_armour)
    end
  end

  local it_ego = BRC.get.ego(it)
  for _, cur in ipairs(all_equipped) do
    local ego_change = get_ego_change_type(BRC.get.ego(cur), it_ego)
    if is_good_ego_change(ego_change, false) then
      local alert_msg = BRC.text.capitalize(ego_change):gsub("_", " ")
      return f_pickup_alert.do_alert(it, alert_msg, Emoji.EGO, More.aux_armour)
    elseif BRC.get.armour_ac(it) > BRC.get.armour_ac(cur) then
      return f_pickup_alert.do_alert(it, "Higher AC", Emoji.STRONGER, More.aux_armour)
    end
  end
end

---- Public API ----
function f_pa_armour.pickup_armour(it)
  if BRC.is.risky_item(it) then return false end

  if BRC.is.body_armour(it) then
    return pickup_body_armour(it)
  elseif BRC.is.shield(it) then
    return pickup_shield(it)
  else
    return pickup_aux_armour(it)
  end
end

--- Alerts armour items that didn't auto-pickup but are worth considering.
--- This comes after pickup, so there will be no pure upgrades.
-- @param unworn_inv_item (optional) to compare against an unworn aux armour item in inventory.
function f_pa_armour.alert_armour(it, unworn_inv_item)
  if BRC.is.body_armour(it) then
    return alert_body_armour(it)
  elseif BRC.is.shield(it) then
    return alert_shield(it)
  else
    return alert_aux_armour(it, unworn_inv_item)
  end
end

}
############################### End lua/features/pickup-alert/pa-armour.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-misc.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-misc
Description: Miscellaneous item pickup logic and alert system for the pickup-alert system
Author: buehler
Dependencies: core/config.lua, core/constants.lua, core/util.lua
  pa-config.lua, pa-data.lua, pa-main.lua
--]]

f_pa_misc = {}

---- Local config alias ----
local Emoji = f_pickup_alert.Config.Emoji
local Alert = f_pickup_alert.Config.Alert

---- Public API ----
function f_pa_misc.alert_orb(it)
  return f_pickup_alert.do_alert(it, "New orb", Emoji.ORB, Alert.More.orbs)
end

function f_pa_misc.alert_OTA(it)
  local ota_item = f_pa_data.find(pa_OTA_items, it)
  if not ota_item then return end

  local do_alert = true

  if BRC.is.shield(it) then
    if you.skill("Shields") < Alert.OTA_require_skill.shield then return end

    -- Don't alert if already wearing a larger shield
    if ota_item == "buckler" then
      if BRC.you.have_shield() then do_alert = false end
    elseif ota_item == "kite shield" then
      local sh = items.equipped_at("offhand")
      if sh and sh.name("qual") == "tower shield" then do_alert = false end
    end
  elseif BRC.is.armour(it) then
    if you.skill("Armour") < Alert.OTA_require_skill.armour then return end
  elseif it.is_weapon then
    if you.skill(it.weap_skill) < Alert.OTA_require_skill.weapon then return end
  end

  f_pa_data.remove(pa_OTA_items, it)
  if not do_alert then return false end
  return f_pickup_alert.do_alert(it, "Found first", Emoji.RARE_ITEM, Alert.More.one_time_alerts)
end

function f_pa_misc.alert_staff(it)
  local needRes = false
  local basename = it.name("base")

  if basename == "staff of fire" then
    needRes = you.res_fire() == 0
  elseif basename == "staff of cold" then
    needRes = you.res_cold() == 0
  elseif basename == "staff of air" then
    needRes = you.res_shock() == 0
  elseif basename == "staff of poison" then
    needRes = you.res_poison() == 0
  elseif basename == "staff of death" then
    needRes = you.res_draining() == 0
  end

  if not needRes then return false end
  return f_pickup_alert.do_alert(it, "Staff resistance", Emoji.STAFF_RES, Alert.More.staff_resists)
end

function f_pa_misc.alert_talisman(it)
  if not it.is_identified then return false end -- Necessary to avoid firing on '\' menu
  if it.artefact then
    return f_pickup_alert.do_alert(it, "Artefact talisman", Emoji.TALISMAN, Alert.More.talismans)
  end
  local required_skill = BRC.get.talisman_min_level(it) - Alert.talisman_lvl_diff
  if required_skill > BRC.you.shapeshifting_skill() then return false end
  return f_pickup_alert.do_alert(it, "New talisman", Emoji.TALISMAN, Alert.More.talismans)
end

function f_pa_misc.is_unneeded_ring(it)
  if not BRC.is.ring(it) or it.artefact or you.race() == "Octopode" then return false end
  local missing_hand = BRC.get.mut("missing a hand") > 0
  local st = it.subtype()
  local found_first = false
  for _, inv in ipairs(items.inventory()) do
    if BRC.is.ring(inv) and inv.subtype() == st then
      if found_first or missing_hand then return true end
      found_first = true
    end
  end
  return false
end

function f_pa_misc.pickup_staff(it)
  return BRC.get.skill(BRC.get.staff_school(it)) > 0
end

}
############################### End lua/features/pickup-alert/pa-misc.lua ###############################
##########################################################################################

################################### Begin lua/features/pickup-alert/pa-weapons.lua ###################################
############### https://github.com/brianfaires/crawl-rc/ ###############
{
--[[
Feature: pickup-alert-weapons
Description: Weapon pickup logic, caching, and alert system for the pickup-alert system
Author: buehler
Dependencies: core/constants.lua, core/data.lua, core/util.lua,
  pa-config.lua, pa-data.lua, pa-main.lua
--]]

f_pa_weapons = {}

---- Persistent variables ----
pa_lowest_hands_alerted = BRC.Data.persist("pa_lowest_hands_alerted", {
  ["Ranged Weapons"] = 3, -- Track lowest hand count alerted for this weapon school
  ["Polearms"] = 3, -- Track lowest hand count alerted for this weapon school
})

---- Local config alias ----
local Config = f_pickup_alert.Config
local Heur = f_pickup_alert.Config.Tuning.Weap
local Emoji = f_pickup_alert.Config.Emoji

---- Local constants ----
local FIRST_WEAPON_XL_CUTOFF = 6 -- Stop first-weapon alerts after this experience level
local POLEARM_RANGED_CUTOFF = 3 -- Stop polearm alerts when ranged skill reaches this level
local UPGRADE_SKILL_FACTOR = 0.5 -- No upgrade alerts if weapon skill is this % of top skill
-- Weapon cache constants
local RANGED_PREFIX = "range_"
local MELEE_PREFIX = "melee_"
local WEAP_CACHE_KEYS = {
  "melee_1", "melee_1b", "melee_2", "melee_2b", "range_1", "range_1b", "range_2", "range_2b"
}

---- Local variables ----
local top_attack_skill
local _weapon_cache = {} -- Cache info for inventory weapons to avoid repeat calculations

---- Local functions ----
local function get_score(it, no_brand_bonus)
  if it.dps and it.acc then
    -- Handle cached /  high-score tuples in _weapon_cache
    return it.dps + it.acc * Heur.Pickup.accuracy_weight
  end
  local dmg_type = no_brand_bonus and BRC.DMG_TYPE.unbranded or BRC.DMG_TYPE.scoring
  local acc_bonus = (it.accuracy + (it.plus or 0)) * Heur.Pickup.accuracy_weight
  return BRC.get.weap_dps(it, dmg_type) + acc_bonus
end

local function is_valid_upgrade(it, cur)
  return cur.is_ranged == it.is_ranged
    and BRC.is.polearm(cur) == BRC.is.polearm(it)
    and (
      you.race() == "Gnoll"
      or BRC.get.skill(it.weap_skill) >= UPGRADE_SKILL_FACTOR * BRC.get.skill(cur.weap_skill)
    )
end

-- is_weapon_upgrade() -> boolean: compares floor weapon to one in inventory
-- `cur` comes from _weapon_cache - it has some pre-computed values
local function is_weapon_upgrade(it, cur, strict)
  if not cur.allow_upgrade then return false end
  if strict then
    -- Pure upgrades only
    if cur.artefact or it.subtype() ~= cur.subtype() then return false end
    if it.artefact then return true end
    local it_plus = it.plus or 0
    local cur_ego = BRC.get.ego(cur)
    if BRC.get.ego(it) == cur_ego then return it_plus > cur.plus end
    return not cur_ego and it_plus >= cur.plus
  end

  -- Check if it's a very likely upgrade
  if it.subtype() == cur.subtype() then
    if it.artefact then return true end
    if cur.artefact then return false end

    local it_ego = BRC.get.ego(it)
    local cur_ego = BRC.get.ego(cur)
    if cur_ego and not it_ego then return false end
    if it_ego and not cur_ego then return get_score(it) / cur.score > Heur.Pickup.add_ego end
    return it_ego == cur_ego and (it.plus or 0) > cur.plus
  elseif it.weap_skill == cur.weap_skill or you.race() == "Gnoll" then
    if BRC.get.hands(it) > cur.hands then return false end
    if cur.is_ranged ~= it.is_ranged then return false end
    if BRC.is.polearm(cur) ~= BRC.is.polearm(it) then return false end

    if it.artefact then return true end
    if cur.artefact then return false end

    local min_ratio = it.is_ranged and Heur.Pickup.same_type_ranged or Heur.Pickup.same_type_melee
    return get_score(it) / cur.score > min_ratio
  end

  return false
end

local function make_alert(it, msg, emoji, fm_option)
  return { it = it, msg = msg, emoji = emoji, fm_option = fm_option }
end

local function need_first_weapon()
  return you.xl() < FIRST_WEAPON_XL_CUTOFF
    and _weapon_cache.is_empty()
    and you.skill("Unarmed Combat") == 0
    and BRC.get.mut("claws") == 0
end

-- Local functions: Weapon cache
function _weapon_cache.get_primary_key(it)
  local tokens = {}
  tokens[1] = it.is_ranged and RANGED_PREFIX or MELEE_PREFIX
  tokens[2] = tostring(it.hands)
  if BRC.get.ego(it) then tokens[3] = "b" end
  return table.concat(tokens)
end

--- Get all categories this weapon fits into (including more-restrictive categories)
function _weapon_cache.get_keys(is_ranged, hands, is_branded)
  local ranged_types = is_ranged and { RANGED_PREFIX, MELEE_PREFIX } or { MELEE_PREFIX }
  local handed_types = hands == 1 and { "1", "2" } or { "2" }
  local branded_types = is_branded and { "b", "" } or { "" }

  -- Generate all combinations
  local keys = {}
  for _, r in ipairs(ranged_types) do
    for _, h in ipairs(handed_types) do
      for _, b in ipairs(branded_types) do
        keys[#keys + 1] = table.concat({ r, h, b })
      end
    end
  end

  return keys
end

function _weapon_cache.add_weapon(it)
  local weap_data = {}
  weap_data.is_weapon = it.is_weapon
  weap_data.basename = it.name("base")
  weap_data._subtype = it.subtype()
  weap_data.subtype = function() -- For consistency with crawl item.subtype()
    return weap_data._subtype
  end
  weap_data.weap_skill = it.weap_skill
  weap_data.skill_lvl = BRC.get.skill(it.weap_skill)
  weap_data.is_ranged = it.is_ranged
  weap_data.hands = BRC.get.hands(it)
  weap_data.artefact = it.artefact
  weap_data._ego = BRC.get.ego(it)
  weap_data.ego = function() -- For consistency with crawl item.ego()
    return weap_data._ego
  end
  weap_data.plus = it.plus or 0
  weap_data.acc = it.accuracy + weap_data.plus
  weap_data.damage = it.damage
  weap_data.dps = BRC.get.weap_dps(it)
  weap_data.score = get_score(it)
  weap_data.unbranded_score = get_score(it, true)

  -- Check for exclusion tags
  local lower_insc = it.inscription:lower()
  weap_data.allow_upgrade = not (lower_insc:contains("!u") or lower_insc:contains("!brc"))

  -- Track unique egos
  if weap_data._ego and not util.contains(_weapon_cache.egos, weap_data._ego) then
    _weapon_cache.egos[#_weapon_cache.egos + 1] = weap_data._ego
  end

  -- Track max damage for applicable weapon categories
  local keys = _weapon_cache.get_keys(weap_data.is_ranged, weap_data.hands, weap_data._ego ~= nil)

  -- Update the max DPS for each category
  for _, key in ipairs(keys) do
    if weap_data.dps > _weapon_cache.max_dps[key].dps then
      _weapon_cache.max_dps[key].dps = weap_data.dps
      _weapon_cache.max_dps[key].acc = weap_data.acc
    end
  end

  _weapon_cache.weapons[#_weapon_cache.weapons + 1] = weap_data
  return weap_data
end

function _weapon_cache.is_empty()
  return _weapon_cache.max_dps["melee_2"].dps == 0 -- The most restrictive category
end

function _weapon_cache.refresh()
  local cur_turn = you.turn()
  if _weapon_cache.turn and _weapon_cache.turn == cur_turn then return end
  _weapon_cache.turn = cur_turn
  _weapon_cache.weapons = {}
  _weapon_cache.egos = {}

  -- Can reuse max_dps table
  if _weapon_cache.max_dps then
    for _, key in ipairs(WEAP_CACHE_KEYS) do
      _weapon_cache.max_dps[key].dps = 0
      _weapon_cache.max_dps[key].acc = 0
    end
  else
    _weapon_cache.max_dps = {}
    for _, key in ipairs(WEAP_CACHE_KEYS) do
      _weapon_cache.max_dps[key] = { dps = 0, acc = 0 }
    end
  end

  for _, inv in ipairs(items.inventory()) do
    if inv.is_weapon and not BRC.is.magic_staff(inv) then
      _weapon_cache.add_weapon(inv)
      f_pa_data.update_high_scores(inv)
    end
  end
end

-- Local functions: Alerting
local function get_first_of_skill_alert(it, silent)
  local skill = it.weap_skill
  if not pa_lowest_hands_alerted[skill] then return end

  local hands = BRC.get.hands(it)
  if pa_lowest_hands_alerted[skill] > hands then
    -- Some early checks to skip alerts
    if hands == 2 and BRC.you.have_shield() then return end
    if skill == "Polearms" and you.skill("Ranged Weapons") >= POLEARM_RANGED_CUTOFF then return end

    -- Update lowest # hands alerted, and alert
    pa_lowest_hands_alerted[skill] = hands
    if silent then return end
    local msg = "First " .. string.sub(skill, 1, -2) .. (hands == 1 and " (1-handed)" or "")
    return make_alert(it, msg, Emoji.WEAPON, Config.Alert.More.early_weap)
  end
end

local function get_early_weapon_alert(it)
  -- Alert really good usable ranged weapons
  if it.is_ranged and you.xl() <= Heur.Alert.EarlyRanged.xl then
    local min_plus = Heur.Alert.EarlyRanged[BRC.get.ego(it) and "branded_min_plus" or "min_plus"]
    if (it.plus or 0) >= min_plus / Config.Alert.weapon_sensitivity then
      local low_shield_training = you.skill("Shields") <= Heur.Alert.EarlyRanged.max_shields
      if BRC.get.hands(it) == 1 or not BRC.you.have_shield() or low_shield_training then
        return make_alert(it, "Ranged weapon", Emoji.RANGED, Config.Alert.More.early_weap)
      end
    end
  end

  if you.xl() <= Heur.Alert.Early.xl then
    -- Ignore items if we're clearly going another route
    local skill_setting = Heur.Alert.Early.skill
    local skill_diff = BRC.get.skill(top_attack_skill) - BRC.get.skill(it.weap_skill)
    if skill_diff > you.xl() * skill_setting.factor + skill_setting.offset then return false end

    local it_plus = it.plus or 0
    if
      BRC.get.ego(it)
      or it_plus >= Heur.Alert.Early.branded_min_plus / Config.Alert.weapon_sensitivity
    then
      return make_alert(it, "Early weapon", Emoji.WEAPON, Config.Alert.More.early_weap)
    end
  end

  return false
end

local function get_weap_high_score_alert(it)
  if _weapon_cache.is_empty() then return end -- Skip if not using weapons
  local category = f_pa_data.update_high_scores(it)
  if not category then return end
  return make_alert(it, category, Emoji.WEAPON, Config.Alert.More.high_score_weap)
end

local function get_upgrade_alert_same_type(it, cur, best_dps, best_score)
  -- Alert: new egos, highest DPS or highest weap_score
  local it_ego = BRC.get.ego(it, true) -- Don't overvalue speed/heavy (only consider their DPS)
  local cur_ego = BRC.get.ego(cur)
  if not cur.artefact and it_ego and it_ego ~= cur_ego then
    local change = cur_ego and "Diff ego" or "Gain ego"
    return make_alert(it, change, Emoji.EGO, Config.Alert.More.weap_ego)
  else
    local s = Config.Alert.weapon_sensitivity
    if get_score(it) > best_score / s or BRC.get.weap_dps(it) > best_dps / s then
      return make_alert(it, "Weapon upgrade", Emoji.WEAPON, Config.Alert.More.upgrade_weap)
    end
  end
end

--- Check if weapon is worth alerting for, compared against one weapon currently in inventory
-- @param cur (weapon) comes from _weapon_cache - it has some pre-computed values
local function get_upgrade_alert(it, cur, best_dps, best_score)
  -- Ensure the non-strict upgrade is checked, if not already done in pickup_weapon()
  if Config.Pickup.weapons_pure_upgrades_only and is_weapon_upgrade(it, cur, false) then
    return make_alert(it, "Weapon upgrade", Emoji.WEAPON, Config.Alert.More.upgrade_weap)
  end

  if it.artefact then return make_alert(it, "Artefact weapon", Emoji.ARTEFACT) end
  if cur.subtype() == it.subtype() then
    return get_upgrade_alert_same_type(it, cur, best_dps, best_score)
  end
  if not is_valid_upgrade(it, cur) then return end

  -- Get ratio of weap_score / best_score. Penalize lower-trained skills
  local damp = Heur.Alert.low_skill_penalty_damping
  local penalty = (BRC.get.skill(it.weap_skill) + damp) / (BRC.get.skill(top_attack_skill) + damp)
  local ratio = penalty * get_score(it) / best_score * Config.Alert.weapon_sensitivity

  if BRC.get.hands(it) <= cur.hands then
    if cur.artefact then return false end
    if BRC.get.ego(it, true) then -- Don't overvalue Speed/Heavy egos (only consider their DPS)
      local it_ego = BRC.get.ego(it)
      if not BRC.get.ego(cur) then
        if ratio > Heur.Alert.gain_ego then
          return make_alert(it, "Gain ego", Emoji.EGO, Config.Alert.More.weap_ego)
        end
      elseif not util.contains(_weapon_cache.egos, it_ego) and ratio > Heur.Alert.new_ego then
        return make_alert(it, "New ego", Emoji.EGO, Config.Alert.More.weap_ego)
      end
    end
    if ratio > Heur.Alert.pure_dps then
      return make_alert(it, "DPS increase", Emoji.WEAPON, Config.Alert.More.upgrade_weap)
    end
  elseif BRC.you.free_offhand() or (you.skill("Shields") < Heur.Alert.AddHand.ignore_sh_lvl) then
    local it_ego = BRC.get.ego(it)
    if it_ego and not util.contains(_weapon_cache.egos, it_ego) and ratio > Heur.Alert.new_ego then
      return make_alert(it, "New ego (2-handed)", Emoji.EGO, Config.Alert.More.weap_ego)
    elseif ratio > Heur.Alert.AddHand.not_using then
      return make_alert(it, "2-handed weapon", Emoji.TWO_HAND, Config.Alert.More.upgrade_weap)
    end
  elseif
    BRC.get.ego(it)
    and not BRC.get.ego(cur)
    and ratio > Heur.Alert.AddHand.add_ego_lose_sh
  then
    return make_alert(it, "2-handed weapon (Gain ego)", Emoji.TWO_HAND, Config.Alert.More.weap_ego)
  end
end

local function get_inventory_upgrade_alert(it)
  -- Once, find the top dps & score for inventory weapons of the same category
  local inv_best = _weapon_cache.max_dps[_weapon_cache.get_primary_key(it)]
  local top_dps = inv_best and inv_best.dps or 0
  local top_score = inv_best and get_score(inv_best) or 0

  -- Compare against all inventory weapons, even from other categories
  for _, inv in ipairs(_weapon_cache.weapons) do
    local best_dps = math.max(inv.dps, top_dps)
    local best_score = math.max(inv.score, top_score)
    local a = get_upgrade_alert(it, inv, best_dps, best_score)
    if a then return a end
  end
end

local function get_weapon_alert(it)
  return get_inventory_upgrade_alert(it)
    or get_first_of_skill_alert(it)
    or get_early_weapon_alert(it)
    or get_weap_high_score_alert(it)
end

---- Public API ----
function f_pa_weapons.serialize_weapon_cache()
  _weapon_cache.refresh()
  local tokens = { BRC.text.cyan("\n---INVENTORY WEAPONS---") }
  for _, weap in ipairs(_weapon_cache.weapons) do
    tokens[#tokens + 1] = string.format("\n%s\n", weap.basename)
    for k, v in pairs(weap) do
      if k ~= "basename" then tokens[#tokens + 1] = string.format("  %s: %s\n", k, tostring(v)) end
    end
  end
  return table.concat(tokens)
end

function f_pa_weapons.pickup_weapon(it)
  _weapon_cache.refresh()
  if need_first_weapon() then
    -- Check if we're carrying a weapon that didn't go into _weapon_cache (like a staff)
    return not util.exists(items.inventory(), function(i) return i.is_weapon end)
  end

  if BRC.is.risky_item(it) then return false end
  for _, inv in ipairs(_weapon_cache.weapons) do
    if is_weapon_upgrade(it, inv, Config.Pickup.weapons_pure_upgrades_only) then
      -- Confirm after updating cache, to avoid spurious alerts from XP gain.
      f_pa_weapons.ready()
      if is_weapon_upgrade(it, inv, Config.Pickup.weapons_pure_upgrades_only) then return true end
    end
  end
end

function f_pa_weapons.alert_weapon(it)
  _weapon_cache.refresh()
  if get_weapon_alert(it) then
    -- Confirm after updating cache, to avoid spurious alerts from XP gain.
    f_pa_weapons.ready()
    local a = get_weapon_alert(it)
    if a then return f_pickup_alert.do_alert(a.it, a.msg, a.emoji, a.fm_option) end
  end
  return false
end

---- Hook functions ----
function f_pa_weapons.init()
  top_attack_skill = BRC.get.preferred_weapon_type() or "Unarmed Combat"
  _weapon_cache.refresh()
end

function f_pa_weapons.ready()
  top_attack_skill = BRC.get.preferred_weapon_type() or "Unarmed Combat"
end

}
############################### End lua/features/pickup-alert/pa-weapons.lua ###############################
##########################################################################################

## (Resuming rc/init.txt) ##


############## Lua Hook Functions ##############
{
function ready()
  BRC.ready()
end

function c_message(text, channel)
  BRC.c_message(text, channel)
end

function c_answer_prompt(prompt)
  return BRC.c_answer_prompt(prompt)
end

function c_assign_invletter(it)
  return BRC.c_assign_invletter(it)
end


BRC.init()
}
